---
layout: paper
headline: Publications
title: 'Search Combinators'
authors: '<a href="http://users.ugent.be/~tschrijv/">Tom Schrijvers</a>, <a href="http://www.ps.uni-sb.de/~tack/">Guido Tack</a>, <a href="http://people.cs.kuleuven.be/~pieter.wuille/">Pieter Wuille</a>, <a href="http://www.cs.toronto.edu/~horst/">Horst Samulowitz</a>, <a href="http://www.cs.mu.oz.au/~pjs/">Peter J. Stuckey</a>'
howpublished: >
  <b>CoRR entry</b>, 2012.
link: <a href="http://arxiv.org/abs/1203.1095">more</a>
bibtex: >
  @Misc{SchrijversEtAl:CoRR:2012,
   Author =    "Tom Schrijvers and Guido Tack and Pieter Wuille and Horst Samulowitz and Peter J. Stuckey",
   Title =     "Search Combinators",
   Year =      2012,
   Month =     mar,
   URL =       "http://arxiv.org/abs/1203.1095"
  }

relation: >
  Experimental implementation based on Gecode
shorthowpub: >
  CoRR entry, 2012. 
---

<p>
The ability to model search in a constraint solver can be an essential asset for solving combinatorial problems. However, existing infrastructure for defining search heuristics is often inadequate. Either modeling capabilities are extremely limited or users are faced with a general-purpose programming language whose features are not tailored towards writing search heuristics. As a result, major improvements in performance may remain unexplored. 
</p>
<p>
This article introduces search combinators, a lightweight and solver-independent method that bridges the gap between a conceptually simple modeling language for search (high-level, functional and naturally compositional) and an efficient implementation (low-level, imperative and highly non-modular). By allowing the user to define application-tailored search strategies from a small set of primitives, search combinators effectively provide a rich domain-specific language (DSL) for modeling search to the user. Remarkably, this DSL comes at a low implementation cost to the developer of a constraint solver. 
</p>
<p>
The article discusses two modular implementation approaches and shows, by empirical evaluation, that search combinators can be implemented without overhead compared to a native, direct implementation in a constraint solver.
</p>