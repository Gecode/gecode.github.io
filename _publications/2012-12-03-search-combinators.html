---
layout: paper
headline: Publications
title: 'Search Combinators'
authors: '<a href="http://users.ugent.be/~tschrijv/">Tom Schrijvers</a>, <a href="http://www.ps.uni-sb.de/~tack/">Guido Tack</a>, <a href="http://people.cs.kuleuven.be/~pieter.wuille/">Pieter Wuille</a>, <a href="http://www.cs.toronto.edu/~horst/">Horst Samulowitz</a>, <a href="http://www.cs.mu.oz.au/~pjs/">Peter J. Stuckey</a>'
howpublished: >
  <b>To appear in:</b> <i>Constraints</i>. Springer-Verlag, 2012. 
copyright: Copyright Springer-Verlag, the original publication is available at <a href="http://www.springerlink.com/">www.springerlink.com</a>
link: <a href="papers/SchrijversEtAl_Constraints_2012.pdf">pdf</a>
bibtex: >
  @Article{SchrijversEtAl:Constraints:2012,
   Author =    "Tom Schrijvers and Guido Tack and Pieter Wuille and Horst Samulowitz and Peter J. Stuckey",
   Title =     "Search Combinators",
   Journal =   "Constraints",
   Year =      2012,
   Publisher = "Springer-Verlag",
   Note =      "To appear.",
  }

Linnea Ingmar, Christian Schulte.
[pdf | bibtex] 
The compact-table propagator for table constraints appears to be a strong candidate for inclusion into any constraint solver due to its efficiency and simplicity. However, successful integration into a constraint solver based on copying rather than trailing is not obvious: while the underlying bit-set data structure is sparse for efficiency it is not compact for memory, which is essential for a copying solver. 
The paper introduces techniques to make compact-table an excellent fit for a copying solver. The key is to make sparse bit-sets dynamically compact (only their essential parts occupy memory and their implementation is dynamically adapted during search) and tables shared (their read-only parts are shared among copies). Dynamically compact bit-sets reduce peak memory by 7.2% and runtime by 13.6% on average and by up to 66.3% and 33.2%. Shared tables even further reduce runtime and memory usage. The reduction in runtime exceeds the reduction in memory and a cache analysis indicates that our techniques might also be beneficial for trailing solvers. The proposed implementation has replaced Gecode's original implementations as it runs on average almost an order of magnitude faster while using half the memory. 
In: John Hooker, editor, Twentyforth International Conference on Principles and Practice of Constraint Programming, Lille, France, volume 11008 of Lecture Notes in Computer Science, pages 210-218. Springer-Verlag, August, 2018. DOI 10.1007/978-3-319-98334-9_14.
Copyright Springer-Verlag, the original publication is available at www.springerlink.com

relation: >
  Experimental implementation based on Gecode
shorthowpub: >
  Constraints, 2012. To appear. 
---

<p>
The ability to model search in a constraint solver can be an essential asset
for solving combinatorial problems. However, existing infrastructure for
defining search heuristics is often inadequate. Either modeling capabilities
are extremely limited or users are faced with a general-purpose programming
language whose features are not tailored towards writing search heuristics.
As a result, major improvements in performance may remain unexplored.
</p>
<p>
This article introduces <em>search combinators</em>, a lightweight and solver-independent 
method that bridges the gap between a conceptually simple modeling language for search
(high-level, functional and naturally compositional) and
an efficient implementation (low-level, imperative and highly non-modular).
By allowing the user to define application-tailored search strategies from a small
set of primitives, search combinators effectively provide a rich
<em>domain-specific language</em> (DSL) for modeling search to the user.
Remarkably, this DSL comes at a low implementation cost to the developer of a constraint solver. 
</p>
<p>
The article discusses two modular implementation approaches and shows, by empirical evaluation, that search combinators can be implemented without overhead compared to a native, direct implementation in a constraint solver.
</p>