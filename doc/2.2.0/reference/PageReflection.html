<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Gecode: The Reflection API</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
<!--[if IE]><style type="text/css">
  @media screen {
    html, body {
      height: 100%; overflow-y: hidden;
      background:#FFFFFF url(back.png) repeat-y;
      font-family:Arial,Helvetica,sans-serif;
      color:#000000;
      margin:0;
      padding:0;
    }
    #scrollable {
      height: 100%; width: 100%; overflow: auto;
    }
  }
</style><![endif]-->
</head>

<body>

<div id="logo">
<img src='gecode-logo-100.png' alt="Gecode logo" /></div>

<div id="navigation">
  <div id="navigation2">
    <a class="navigation" href="index.html">main page</a>
    <a class="navigation" href="modules.html">modules</a>
    <a class="navigation" href="namespaces.html">namespaces</a>
    <a class="navigation" href="annotated.html">classes</a>
    <a class="navigation" href="files.html">files</a>
    <br>
    <a class="navigation" href="http://www.gecode.org/index.html">Gecode home</a>
<form action="search.php" method="get"><a class="navigation" title="Search for keywords in the entire documentation">search&nbsp;for&nbsp;<input type="text" name="query" value="" size="20" accesskey="s"/></a></form>
    </div>
</div>

<div id="footline">
<address style="text-align: right;"><small>
Generated on Mon Aug 25 11:35:46 2008 for Gecode by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.5.6</small></address>
</div>

<div id="scrollable">
<div id="content">
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="PageReflection">The Reflection API </a></h1>Reflection in Gecode provides information about all the actors (propagators and branchings) and the variables in a Space. Gecode also enables the reverse direction: creating a variable or actor in a space, given a specification. Some use cases for reflection are<ul>
<li><b>Serialization</b>, which creates an external, platform-independent representation of a space that can be used to recreate a copy of the original space. This facilitates the development of distributed search engines, makes it possible to store instances of constraint problems, and can be used to transfer a problem instance from one solver to another.</li></ul>
<p>
<ul>
<li><b>Visualization</b> of variable domains or the propagators in a space can help with debugging scripts or propagators. Gecode's Gist uses reflection for visualization.</li></ul>
<p>
<ul>
<li><b>Interfacing</b> to other programming languages becomes easy, because only the generic unreflection functions have to be made available. The Qt-based <a class="el" href="classJavaScript.html" title="Example: Gecode/JavaScript interpreter">JavaScript</a> interpreter in <a class="el" href="examples_2javascript_8cc.html">examples/javascript.cc</a> builds on reflection.</li></ul>
<p>
<ul>
<li><b>Heuristics</b> can be based on properties of the constraint graph, which is effectively exposed by the reflection API.</li></ul>
<p>
This tutorial is split in two parts:<ul>
<li><a class="el" href="PageReflection.html#SecReflUsage">Using the reflection API</a></li><li><a class="el" href="PageReflection.html#SecReflAddSupport">Adding reflection support to actors and variables</a></li></ul>
<h2><a class="anchor" name="SecReflUsage">
Using the reflection API</a></h2>
The starting point for reflection in Gecode is a Space. The basic work cycle is to iterate over all the actors in a space using an ActorSpecIter, collecting the variables that the actors reference in a VarMap. The iterator returns an ActorSpec for each actor, and the VarMap contains a VarSpec for each variable. All the specifications in the VarMap can be accessed using a VarMapIter.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classGecode_1_1Space.html" title="Computation spaces.">Gecode::Space</a>* space = ...
Gecode::Reflection::VarMap vm;
<a class="code" href="classGecode_1_1Reflection_1_1VarMapIter.html" title="Iterating a variable map.">Gecode::Reflection::VarMapIter</a> vmi(vm);
<span class="keywordflow">for</span> (<a class="code" href="classGecode_1_1Reflection_1_1ActorSpecIter.html" title="Iterating actor specifications.">Gecode::Reflection::ActorSpecIter</a> si(space, vm); si(); ++si) {
  <a class="code" href="classGecode_1_1Reflection_1_1ActorSpec.html" title="Actor specification">Gecode::Reflection::ActorSpec</a> aSpec = si.actor();
  doSomethingForAnActor(aSpec);
  <span class="keywordflow">for</span> (; vmi(); ++vmi) {
    <a class="code" href="classGecode_1_1Reflection_1_1VarSpec.html" title="Variable specification">Gecode::Reflection::VarSpec</a> vSpec = vmi.spec();
    doSomethingForAVariable(vSpec);
  }
}
</pre></div><p>
Note that new variables are added to <code>vm</code> when the specification for an actor is accessed (using <code>si.actor()</code>). The VarMapIter therefore always iterates all those variables that were added to <code>vm</code> for the current actor.<p>
We will now go into the details of ActorSpec and VarSpec, and after that discuss the VarMap and the unreflection mechanism.<h3><a class="anchor" name="SecReflUsageSpecs">
Accessing the specifications</a></h3>
Specifications for actors and variables are similar. For each actor or variable, a specification contains a Symbol (a string) representing its type (accessed as <code>ActorSpec::ati</code> resp. <code>VarSpec::vti</code>), and a term representing its state (e.g. the current variable domain for variables, or the arguments of a propagator). Terms are represented as objects of the class Reflection::Arg and can be summarized by the following grammar:<p>
<div class="fragment"><pre class="fragment">
term ::= INT | VAR | STRING
       | [term,...,term] | [INT,...,INT]  | (term,term)
       | sharedObject(term) | sharedReference(INT)
</pre></div><p>
The upper-case constructors stand for actual values; signed integers for <code>INT</code>, character pointers for <code>STRING</code>, and <em>integers for <code>VAR</code> </em>: variables are represented as indices into the VarMap.<p>
The second line shows term constructors for arrays and pairs. There is special support for integer arrays. The constructors for shared objects in the third line have a similar purpose as the <code>VAR</code> constructor: a term, e.g. an array, that is shared between several actors, is introduced using a <code>sharedObject</code> constructor, and later referenced by a <code>sharedReference</code>. The shared references are counted in the order in which the shared objects are encountered.<p>
The concrete representation of a variable's or actor's state depends on its concrete implementation. The following list will give you an idea of possible encodings:<ul>
<li>Domains of integer variables are encoded as arrays of integers, where two consecutive integers represent a range in the domain. For example, the domain <img class="formulaInl" alt="$\{0,1,2,4,5,8\}$" src="form_0.png"> would be represented as <code></code>[0,2,4,5,8,8].</li><li>The arguments of the distinct constraint with offsets are encoded as an array of pairs of integers and variables, like <code></code>[(0,q0),(-1,q1),(-2,q2),(-3,q3)] for the <a class="el" href="classQueens.html" title="Example: n-Queens puzzle">Queens</a> model.</li><li>The DFA of an extensional constraint that uses a LayeredGraph is encoded into an array of integers, where each transition is represented by three integers, one for the input state, one for the symbol, and one for the output state. As DFAs can be shared between several propagators, they are wrapped in a <code>sharedObject</code> or <code>sharedReference</code>.</li></ul>
<h3><a class="anchor" name="SecReflUsageVarMap">
The VarMap</a></h3>
Several propagators can share the same variable, and reflection makes this sharing explicit. The VarMap contains one entry per variable that is referenced by an actor, and it is filled by iterating over the actors. The specification of an actor only contains an integer reference into the VarMap that was used when the specification was created.<p>
Reflection of variables is similar to copying, as only those variables will be put into a VarMap that are reachable from the actors. As with copying, variables can be added manually. Furthermore, a VarMap can store a <em>name</em> for each variable. The Space class has a virtual function <a class="el" href="classGecode_1_1Space.html#752f0e93e2a81c82ea54211734548c4c" title="Enter variables into m.">Gecode::Space::getVars</a>, which is used to fill a VarMap with the variables that the user is interested in.<p>
The <a class="el" href="classQueens.html" title="Example: n-Queens puzzle">Queens</a> example shows how to use <code>getVars:</code> <p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span><a class="code" href="classQueens.html" title="Example: n-Queens puzzle">Queens</a> : <span class="keyword">public</span> <a class="code" href="classExample.html" title="Base-class for Gecode examples.">Example</a> {
<span class="keyword">public</span>:
  <span class="keyword">virtual</span> <span class="keywordtype">void</span>
  getVars(<a class="code" href="classGecode_1_1Reflection_1_1VarMap.html" title="Mapping Gecode variable implementations to variable specifications.">Gecode::Reflection::VarMap</a>&amp; vm, <span class="keywordtype">bool</span> registerOnly) {
    vm.<a class="code" href="classGecode_1_1Reflection_1_1VarMap.html#097cdcc1b2eaf0b407530a4071b9ce9a" title="Insert specifications for variables in x with name n.">putArray</a>(<span class="keyword">this</span>,q,<span class="stringliteral">"q"</span>, registerOnly);
  }  
};
</pre></div><p>
The parameter <code>registerOnly</code> is needed for unreflection.<h3><a class="anchor" name="SecReflUsageUnref">
Unreflection</a></h3>
With unreflection, Gecode can create variables and actors in a space from a VarSpec or ActorSpec. The unreflection mechanism can be used for deserialization, or to implement an interface to Gecode.<p>
Assuming that the actor and variable specifications were stored in vectors, the basic setup for unreflection looks like this:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> unreflect(Space* home, std::vector&lt;ActorSpec&gt;&amp; as, std::vector&lt;VarSpec&gt;&amp; vs) {
  <a class="code" href="classGecode_1_1Reflection_1_1VarMap.html" title="Mapping Gecode variable implementations to variable specifications.">Gecode::Reflection::VarMap</a> vm;
  <a class="code" href="classGecode_1_1Reflection_1_1Unreflector.html" title="Unreflection from VarSpec and ActorSpecAn Unreflector allows you to install variables...">Gecode::Reflection::Unreflector</a> ur(home, vm);
  <span class="keywordflow">for</span> (std::vector&lt;VarSpec&gt;::iterator it=vs.begin(); it != vs.end(); ++it) {
    ur.var(*it);   <span class="comment">// Create variables from specifications</span>
  }
  <span class="keywordflow">for</span> (std::vector&lt;ActorSpec&gt;::iterator it=as.begin(); it != as.end(); ++it) {
    ur.post(*it);  <span class="comment">// Post actors from specifications</span>
  }
}
</pre></div><p>
After unreflection, the VarMap contains the created variables. If the variable specifications had names for the variables, the new variables can be accessed via their names, otherwise, they can only be accessed by their index into the VarMap. The indices are consecutive integers, starting at 0, and assigned in the order in which the variables were created.<p>
The VarMap can be filled <em>before</em> you use unreflection. That way, existing variables can be mapped to the new variables via names, and the actors created by unreflection are posted on the existing variables. This is the purpose of the <code>registerOnly</code> argument of <a class="el" href="classGecode_1_1Space.html#752f0e93e2a81c82ea54211734548c4c" title="Enter variables into m.">Gecode::Space::getVars</a>. If it is <code>true</code>, only the names of the variables will be registered, but no index will be assigned for the variable in the VarMap:<p>
<div class="fragment"><pre class="fragment">...
Gecode::Reflection::VarMap vm;
home-&gt;getVars(vm, <span class="keyword">true</span>);   <span class="comment">// Register variables</span>
<a class="code" href="classGecode_1_1Reflection_1_1Unreflector.html" title="Unreflection from VarSpec and ActorSpecAn Unreflector allows you to install variables...">Gecode::Reflection::Unreflector</a> ur(home, vm);
<span class="keywordflow">for</span> (std::vector&lt;VarSpec&gt;::iterator it=vs.begin(); it != vs.end(); ++it) {
...
</pre></div><h3><a class="anchor" name="SecReflUsageGenericVars">
Generic variables</a></h3>
Gecode provides a generic variable class, <a class="el" href="classGecode_1_1Reflection_1_1Var.html" title="Generic variables.">Gecode::Reflection::Var</a>. Generic variables can be obtained from any variable class that supports reflection. They provide a dynamically type-safe way of handling inhomogeneous collections of variables, for instance a <code>VarArray</code> that contains both integer and set variables.<p>
All variables can be constructed from a generic variable. At construction, a dynamic check is performed that guarantees that the generic variable is actually an instance of the variable type that is constructed. The variables in a VarMap can be accessed as generic variables: <div class="fragment"><pre class="fragment">...
Gecode::Space* home = ...
Gecode::Reflection::VarMap vm;
space-&gt;<a class="code" href="classGecode_1_1Space.html#752f0e93e2a81c82ea54211734548c4c" title="Enter variables into m.">getVars</a>(vm);
<a class="code" href="classGecode_1_1Reflection_1_1Var.html" title="Generic variables.">Gecode::Reflection::Var</a> <a class="code" href="group__TaskTestIntDistinct.html#g88d28911fdae6401c7fd912024898502">v</a> = vm.<a class="code" href="classGecode_1_1Reflection_1_1VarMap.html#1ca7ba0c17a8e3eb77d8028a491e74ee" title="Return variable with name n.">var</a>(0); <span class="comment">// Get variable at index 0</span>
<a class="code" href="classGecode_1_1IntVar.html" title="Integer variables.">Gecode::IntVar</a> i(v);                   <span class="comment">// Construct IntVar (with dynamic type check)</span>
</pre></div><h3><a class="anchor" name="SecReflUsageBranchingSpec">
Branching specifications</a></h3>
A <a class="el" href="classGecode_1_1Reflection_1_1BranchingSpec.html" title="Branching specification">Gecode::Reflection::BranchingSpec</a> provides a human-readable description of a <a class="el" href="classGecode_1_1BranchingDesc.html" title="Branch description for batch recomputation.">Gecode::BranchingDesc</a>. This is e.g. used by Gist, so that the user can see what actions the branchings took at each branch in the search tree.<p>
A BranchingSpec contains one ArrayArg per alternative, and each ArrayArg may only contain strings and variable references. The string concatenation of these arguments yields a human-readable description of the alternative:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> printAlternatives(<a class="code" href="classGecode_1_1Space.html" title="Computation spaces.">Gecode::Space</a>* home) {
  <span class="keywordflow">if</span> (home-&gt;<a class="code" href="group__TaskSearch.html#g2ff3a26e78da2825ff5dc4ffb1056cb7" title="Query space status.">status</a>() != <a class="code" href="group__TaskSearch.html#ggf2c31e4405deb7f40175130957c3058522586483a7be4a59eeb383f5f0c4a185" title="Space must be branched (at least one branching left)">SS_BRANCH</a>) {
    std::cout &lt;&lt; <span class="stringliteral">"no alternatives left"</span> &lt;&lt; std::endl;
    <span class="keywordflow">return</span>;
  }
  <span class="keyword">const</span> <a class="code" href="classGecode_1_1BranchingDesc.html" title="Branch description for batch recomputation.">Gecode::BranchingDesc</a>* <a class="code" href="kakuro_8cc.html#c3c6774907f43a8df237d4f61b5c9c65" title="The previously computed DFA.">d</a> = space-&gt;<a class="code" href="group__TaskSearch.html#g48169314b2066175448dfe33c51d600b" title="Create new branching description for current branching.">description</a>();
  <a class="code" href="classGecode_1_1Reflection_1_1VarMap.html" title="Mapping Gecode variable implementations to variable specifications.">Gecode::Reflection::VarMap</a> vm;
  space-&gt;<a class="code" href="classGecode_1_1Space.html#752f0e93e2a81c82ea54211734548c4c" title="Enter variables into m.">getVars</a>(vm, <span class="keyword">false</span>);
  <a class="code" href="classGecode_1_1Reflection_1_1BranchingSpec.html" title="Branching specification">Gecode::Reflection::BranchingSpec</a> bs = space-&gt;<a class="code" href="classGecode_1_1Space.html#56ed154a3e1a146ff4649de3dba1e1a7" title="Get reflection for BranchingDesc d.">branchingSpec</a>(vm,d);
  <span class="keyword">delete</span> d;
  std::cout &lt;&lt; <span class="stringliteral">"Alternatives:"</span> &lt;&lt; std::endl;
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;bs.<a class="code" href="classGecode_1_1Reflection_1_1BranchingSpec.html#ea26a6a8a5310f50235ea5ee31d5a663" title="Return number of alternatives.">alternatives</a>(); i++) {
    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">": "</span>;
    <a class="code" href="classGecode_1_1Reflection_1_1ArrayArg.html" title="Array arguments.">Gecode::Reflection::ArrayArg</a>&amp; aa = *bs[i]-&gt;toArray();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;aa.<a class="code" href="classGecode_1_1Reflection_1_1ArrayArg.html#54e08367772c1c5f3d5edb62dca5f330" title="Size of the array.">size</a>(); j++) {
      <span class="keywordflow">if</span> (aa[j]-&gt;isString()) {
        std::cout &lt;&lt; aa[j]-&gt;<a class="code" href="classGecode_1_1Reflection_1_1Arg.html#a775dd3f8ca150694b92d6963f40be35" title="Return the string that this argument represents.">toString</a>();
      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (aa[j]-&gt;isVar()) {
        <span class="keywordtype">int</span> v = aa[j]-&gt;<a class="code" href="classGecode_1_1Reflection_1_1Arg.html#9bf16186d847c3bbaa37b2ebd19f2906" title="Return the variable index that this argument represents.">toVar</a>();
        <span class="keywordflow">if</span> (vm.<a class="code" href="classGecode_1_1Reflection_1_1VarMap.html#31cfa5932474b517350d72cee0c0644d" title="Return if variable implementation x has a name.">hasName</a>(v))
          std::cout &lt;&lt; vm.<a class="code" href="classGecode_1_1Reflection_1_1VarMap.html#8853b92c1af1f9dac7f06f04072b874c" title="Return name for variable implementation x.">name</a>(v).toString();
        <span class="keywordflow">else</span>
          std::cout &lt;&lt; <span class="stringliteral">"_v"</span> &lt;&lt; v;
      }
    }
    std::cout &lt;&lt; std::endl;
  }
}
</pre></div><h3><a class="anchor" name="SecReflUsageMemory">
Memory management</a></h3>
All the reflection classes provide memory management. This means that you must not free the argument objects, they are automatically deallocated when the ActorSpec, VarSpec, or BranchingSpec is deallocated. Copying specifications is cheap, as all classes use reference counting.<h3><a class="anchor" name="SecReflUsageInterfacing">
Interfacing to Gecode through reflection</a></h3>
The (un-)reflection API makes interfacing to Gecode very easy. We provide a full <a class="el" href="classJavaScript.html" title="Example: Gecode/JavaScript interpreter">JavaScript</a> interface (through TrollTech's Qt library), and it only requires 150 lines of code.<p>
An interface can benefit from reflection in three ways:<p>
<ul>
<li>The generic <a class="el" href="classGecode_1_1Reflection_1_1Var.html" title="Generic variables.">Gecode::Reflection::Var</a> class leaves the C++ part of the interface independent of the actual variable types that are supported. Every variable type supported by Gecode is automatically supported by the interface.</li></ul>
<p>
<ul>
<li>Instead of a post function for every propagator and branching and variable creation functions for all the variable types, only the <a class="el" href="classGecode_1_1Reflection_1_1Unreflector.html" title="Unreflection from VarSpec and ActorSpecAn Unreflector allows you to install variables...">Gecode::Reflection::Unreflector</a> has to be exported.</li></ul>
<p>
<ul>
<li>All propagators and branchings that are supported by Gecode are immediately available through the interface. When propagators are added to Gecode, no new interfacing code has to be written. If the propagators are added as additional libraries, the interface does not even have to be recompiled.</li></ul>
<p>
Please refer to <a class="el" href="PageReflectionRegistry.html">The Reflection Registry</a> for more information on the propagators that are available through unreflection.<h2><a class="anchor" name="SecReflAddSupport">
Adding reflection support to actors and variables</a></h2>
When the ActorSpecIter iterates over the actors of a space, each actor has to deliver its specification through the virtual function Actor::spec. When this function is called, the actor creates an ActorSpec with its <em>actor type identifier</em> (ati) and fills it with a representation of its arguments, encoded into objects of type Reflection::Arg. The specification for the views is delegated to the views or view arrays that the actor uses.<p>
We now go through the steps that are needed for reflection of actors and variables.<h3><a class="anchor" name="SecReflAddSupportProp">
Propagators</a></h3>
Propagators implement the virtual function Gecode::Reflection::Actor::spec. It creates an ActorSpec with a proper actor type identifier and arguments. The following example provides reflection for a propagator with an IntView <code>x</code>, a ViewArray of IntViews <code>y</code>, and an integer constant <code>c:</code> <p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyPropagator : <span class="keyword">public</span> Gecode::Propagator {
<span class="keyword">protected</span>:
  IntView            <a class="code" href="kakuro_8cc.html#e928e6fd222358d27be0a56a8ade81ce" title="The variables.">x</a>;
  ViewArray&lt;IntView&gt; y;
  <span class="keywordtype">int</span>                <a class="code" href="kakuro_8cc.html#4e1e0e72dd773439e333c84dd762a9c3" title="Sum of variables.">c</a>;
<span class="keyword">public</span>:
  <span class="comment">// Return specification for reflection</span>
  <span class="keyword">virtual</span> <a class="code" href="classGecode_1_1Reflection_1_1ActorSpec.html" title="Actor specification">Gecode::Reflection::ActorSpec</a>
  spec(<span class="keyword">const</span> Space* home, <a class="code" href="classGecode_1_1Reflection_1_1VarMap.html" title="Mapping Gecode variable implementations to variable specifications.">Gecode::Reflection::VarMap</a>&amp; <a class="code" href="namespaceGecode_1_1Int_1_1Arithmetic.html#da77a1517d22d663b4526bb7e2e53f4d" title="Multiply x and y as type Val.">m</a>)<span class="keyword"> const </span>{
    <a class="code" href="classGecode_1_1Support_1_1Symbol.html" title="Immutable Symbols.">Gecode::Support::Symbol</a> ati(<span class="stringliteral">"MyPropagator"</span>);
    <a class="code" href="classGecode_1_1Reflection_1_1ActorSpec.html" title="Actor specification">Gecode::Reflection::ActorSpec</a> spec(ati);
    spec &lt;&lt; <a class="code" href="kakuro_8cc.html#e928e6fd222358d27be0a56a8ade81ce" title="The variables.">x</a>.spec(home, m);
    spec &lt;&lt; y.spec(home, m);
    spec &lt;&lt; <a class="code" href="kakuro_8cc.html#4e1e0e72dd773439e333c84dd762a9c3" title="Sum of variables.">c</a>;
    <span class="keywordflow">return</span> spec;
  }
};
</pre></div><p>
For a generic propagator, the types of its views must be part of the actor type identifier. All views have a static function <code>type</code> to enable this, and the reflection library contains name mangling functions:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">class</span> View0, <span class="keyword">class</span> View1&gt;
<span class="keyword">class </span>MyGenericPropagator : <span class="keyword">public</span> Gecode::Propagator {
<span class="keyword">protected</span>:
  View0            <a class="code" href="kakuro_8cc.html#e928e6fd222358d27be0a56a8ade81ce" title="The variables.">x</a>;
  ViewArray&lt;View1&gt; y;
  <span class="keywordtype">int</span>              <a class="code" href="kakuro_8cc.html#4e1e0e72dd773439e333c84dd762a9c3" title="Sum of variables.">c</a>;
<span class="keyword">public</span>:
  <span class="comment">// Return specification for reflection</span>
  <span class="keyword">virtual</span> <a class="code" href="classGecode_1_1Reflection_1_1ActorSpec.html" title="Actor specification">Gecode::Reflection::ActorSpec</a>
  spec(<span class="keyword">const</span> Space* home, <a class="code" href="classGecode_1_1Reflection_1_1VarMap.html" title="Mapping Gecode variable implementations to variable specifications.">Gecode::Reflection::VarMap</a>&amp; m)<span class="keyword"> const </span>{
    <a class="code" href="classGecode_1_1Support_1_1Symbol.html" title="Immutable Symbols.">Gecode::Support::Symbol</a> ati =
      Gecode::Reflection::mangle&lt;View0,View1&gt;(<span class="stringliteral">"MyGenericPropagator"</span>);
    <a class="code" href="classGecode_1_1Reflection_1_1ActorSpec.html" title="Actor specification">Gecode::Reflection::ActorSpec</a> spec(ati);
    spec &lt;&lt; <a class="code" href="kakuro_8cc.html#e928e6fd222358d27be0a56a8ade81ce" title="The variables.">x</a>.spec(home, m);
    spec &lt;&lt; y.spec(home, m);
    spec &lt;&lt; <a class="code" href="kakuro_8cc.html#4e1e0e72dd773439e333c84dd762a9c3" title="Sum of variables.">c</a>;
    <span class="keywordflow">return</span> spec;
  }
};
</pre></div><p>
For unreflection, the actor must be <em>registered</em>. Gecode contains a global <a class="el" href="group__TaskReflection.html#gf5e6f44640f0e80db581b0c4ce9f520b" title="The registry object.">Gecode::Reflection::registry</a>, mapping actor type identifiers to post functions.<p>
In order to register a propagator, the propagator class has to provide two static functions, <code>ati</code> and <code>post</code>. Then the <a class="el" href="classGecode_1_1Reflection_1_1ActorRegistrar.html" title="Class used for registering actors.">Gecode::Reflection::ActorRegistrar</a> class can be used, or more conveniently, the <code>GECODE_REGISTER</code> macros. Here is a complete example:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">class</span> View0, <span class="keyword">class</span> View1&gt;
<span class="keyword">class </span>MyGenericPropagator : <span class="keyword">public</span> Gecode::Propagator {
<span class="keyword">protected</span>:
  View0            <a class="code" href="kakuro_8cc.html#e928e6fd222358d27be0a56a8ade81ce" title="The variables.">x</a>;
  ViewArray&lt;View1&gt; y;
  <span class="keywordtype">int</span>              <a class="code" href="kakuro_8cc.html#4e1e0e72dd773439e333c84dd762a9c3" title="Sum of variables.">c</a>;
<span class="keyword">public</span>:
  <span class="comment">// Constructor</span>
  MyGenericPropagator(Space*,View0,ViewArray&lt;View1&gt;&amp;,<span class="keywordtype">int</span>);
  <span class="comment">// Actor type identifier</span>
  <span class="keyword">static</span> <a class="code" href="classGecode_1_1Support_1_1Symbol.html" title="Immutable Symbols.">Gecode::Support::Symbol</a> ati(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{
    <span class="keywordflow">return</span> Gecode::Reflection::mangle&lt;View0,View1&gt;(<span class="stringliteral">"MyGenericPropagator"</span>);
  }
  <span class="comment">// Return specification for reflection</span>
  <span class="keyword">virtual</span> <a class="code" href="classGecode_1_1Reflection_1_1ActorSpec.html" title="Actor specification">Gecode::Reflection::ActorSpec</a>
  spec(<span class="keyword">const</span> Space* home, <a class="code" href="classGecode_1_1Reflection_1_1VarMap.html" title="Mapping Gecode variable implementations to variable specifications.">Gecode::Reflection::VarMap</a>&amp; m)<span class="keyword"> const </span>{
    <a class="code" href="classGecode_1_1Reflection_1_1ActorSpec.html" title="Actor specification">Gecode::Reflection::ActorSpec</a> spec(ati());
    spec &lt;&lt; <a class="code" href="kakuro_8cc.html#e928e6fd222358d27be0a56a8ade81ce" title="The variables.">x</a>.spec(home, m);
    spec &lt;&lt; y.spec(home, m);
    spec &lt;&lt; <a class="code" href="kakuro_8cc.html#4e1e0e72dd773439e333c84dd762a9c3" title="Sum of variables.">c</a>;
    <span class="keywordflow">return</span> spec;
  }
  <span class="comment">// Posting the propagator from a specification</span>
  <span class="keyword">static</span> <span class="keywordtype">void</span>
  <a class="code" href="group__FuncIntProp.html#g9ae9a9285d03850255b9c14c2ac88411" title="Post propagator for linear constraint over Booleans.">post</a>(Space* home, Reflection::VarMap&amp; vars, <span class="keyword">const</span> Reflection::ActorSpec&amp; spec) {
    spec.checkArity(3);
    View0 <a class="code" href="kakuro_8cc.html#e928e6fd222358d27be0a56a8ade81ce" title="The variables.">x</a>(home, vars, spec[0]);
    ViewArray&lt;View1&gt; y(home, vars, spec[1]);
    <span class="keywordtype">int</span> <a class="code" href="kakuro_8cc.html#4e1e0e72dd773439e333c84dd762a9c3" title="Sum of variables.">c</a> = spec[2]-&gt;toInt();
    (void) <span class="keyword">new</span> (home) MyGenericPropagator&lt;View0,View1&gt;(home,<a class="code" href="kakuro_8cc.html#e928e6fd222358d27be0a56a8ade81ce" title="The variables.">x</a>,y,c);
  }
};
</pre></div><p>
Using the static function <code>ati</code> for both registration and reflection (in <code>spec</code>) makes sure that the type identifiers are the same.<p>
The function <code>checkArity</code> makes sure that <code>spec</code> contains exactly 3 arguments and throws an exception otherwise. The accessor functions (like <a class="el" href="classGecode_1_1Reflection_1_1Arg.html#4ffe372b6ce4b69311deccaee197e734" title="Return the integer that this argument represents.">Gecode::Reflection::Arg::toInt</a>) also check that the argument type matches. The reflection constructors for views and view arrays use these accesor functions, so an incorrect view type will be detected.<p>
Now we can register the propagator. Note that we have to register each <em>instance</em> separately:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>{
  <a class="code" href="group__TaskReflection.html#g740e1c9dbc748586d1b5151084a017a1" title="Register a propagator with two template arguments.">GECODE_REGISTER2</a>(MyGenericPropagator&lt;IntView,IntView&gt;);
  <a class="code" href="group__TaskReflection.html#g740e1c9dbc748586d1b5151084a017a1" title="Register a propagator with two template arguments.">GECODE_REGISTER2</a>(MyGenericPropagator&lt;IntView,OffsetView&gt;);
}
</pre></div><h3><a class="anchor" name="SecReflAddSupportBranching">
Branchings</a></h3>
Actor reflection for branchings is, in principle, the same as for propagators. However, if you subclass <a class="el" href="classGecode_1_1ViewValBranching.html" title="Generic branching.">Gecode::ViewValBranching</a>, all you have to provide are <code>type</code> functions in your view and value selection classes. See <a class="el" href="classGecode_1_1Int_1_1Branch_1_1ByNone.html#4dce5e007e367cdf687648d006dda4f9" title="Type of this view selection (for reflection).">Gecode::Int::Branch::ByNone&lt;View&gt;::type</a> and <a class="el" href="classGecode_1_1Int_1_1Branch_1_1ValMin.html#9de2fca53ec8834e7437610db917bdef" title="Type of this value selection (for reflection).">Gecode::Int::Branch::ValMin&lt;View&gt;::type</a> for examples.<p>
Branchings provide a second type of reflection. Given a <a class="el" href="classGecode_1_1BranchingDesc.html" title="Branch description for batch recomputation.">Gecode::BranchingDesc</a>, they can deliver a <a class="el" href="classGecode_1_1Reflection_1_1BranchingSpec.html" title="Branching specification">Gecode::Reflection::BranchingSpec</a>. For this to work, you have to implement the virtual function <a class="el" href="classGecode_1_1Branching.html#bede909cc3039bc178793e5c32505926" title="Specification for BranchingDesc d.">Gecode::Branching::branchingSpec</a>.<p>
Please see the <a class="el" href="classGecode_1_1ViewValBranching.html" title="Generic branching.">Gecode::ViewValBranching</a> and the corresponding value selectors (<a class="el" href="classGecode_1_1Int_1_1Branch_1_1ValMin.html#5eb21646b70920488baf768de725d56d" title="Specification of a branch (for reflection).">Gecode::Int::Branch::ValMin&lt;View&gt;::branchingSpec</a>) for examples.<h3><a class="anchor" name="SecReflAddSupportVar">
Variables and Views</a></h3>
Reflection for variables and views is similar to reflection for actors. Each view class provides two functions: <div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyView {
<span class="keyword">public</span>:
  Reflection::Arg* spec(<span class="keyword">const</span> Space* home, Reflection::VarMap&amp; m) <span class="keyword">const</span>;
  <span class="keyword">static</span> Support::Symbol type(<span class="keywordtype">void</span>);
};
</pre></div><p>
Views delegate the reflection of the underlying variable to the variable implementation and just add their own arguments. For a concrete example, see <a class="el" href="classGecode_1_1Int_1_1IntVarImp.html#97b2b9019ee5c2bb105683f3d114712d" title="Return specification.">Gecode::Int::IntVarImp::spec</a> and <a class="el" href="classGecode_1_1Int_1_1OffsetView.html#34612499f6d98b97b523f43b10d669b1" title="Return specification for this view, using variable map m.">Gecode::Int::OffsetView::spec</a>.<p>
The <code>spec</code> function of a view returns a <em>reference to a variable</em>. As a side effect, the actual VarSpec is entered into the VarMap.<p>
Views and variables also have constructors for unreflection. Again, the Views delegate unreflection of the underlying variable. See <a class="el" href="classGecode_1_1IntVar.html#b3ff3e693c041eee88b3fd9c40af36ab" title="Initialize from reflection variable x.">Gecode::IntVar::IntVar(const Gecode::Reflection::Var&amp;)</a> and <a class="el" href="classGecode_1_1Int_1_1IntView.html#8801e80d2f3e964f507cc6f963c10fb4" title="Initialize from specification.">Gecode::Int::IntView::IntView(Space*, const Reflection::VarMap&amp;, Reflection::Arg*)</a>.<p>
For unreflection, the registry contains functions for creating, constraining, updating, and printing variable implementations. If a variable implementation implements the two functions <code>create</code> and <code>constrain</code>, it can be registered using a <a class="el" href="classGecode_1_1Reflection_1_1VarImpRegistrar.html" title="Class used for registering variable implementations.">Gecode::Reflection::VarImpRegistrar</a>. The generic variables (<a class="el" href="classGecode_1_1Reflection_1_1Var.html" title="Generic variables.">Gecode::Reflection::Var</a>) use the registry to perform updates. For an example of how to implement the necessary functionality, see <a class="el" href="classGecode_1_1Int_1_1IntVarImp.html" title="Integer variable implementation.">Gecode::Int::IntVarImp</a>. </div>
</div></div>
</body>
</html>
