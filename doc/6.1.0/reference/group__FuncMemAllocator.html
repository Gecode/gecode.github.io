<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Gecode: Using allocators with Gecode</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
<!--[if IE]><style type="text/css">
  @media screen {
    html, body {
      height: 100%; overflow-y: hidden;
      background:#FFFFFF url(back.png) repeat-y;
      font-family:Arial,Helvetica,sans-serif;
      color:#000000;
      margin:0;
      padding:0;
    }
    #scrollable {
      height: 100%; width: 100%; overflow: auto;
    }
  }
</style><![endif]-->
</head>

<body>

<div id="logo">
<img src='gecode-logo-100.png' alt="Gecode logo" /></div>

<div id="navigation">
  <div id="navigation2">
    <a class="navigation" href="index.html">main page</a>
    <a class="navigation" href="modules.html">modules</a>
    <a class="navigation" href="namespaces.html">namespaces</a>
    <a class="navigation" href="annotated.html">classes</a>
    <a class="navigation" href="files.html">files</a>
    <br>
    <a class="navigation" href="http://www.gecode.org/index.html">Gecode home</a>
    </div>
</div>

<div id="footline">
<address style="text-align: right;"><small>
Generated on Fri Oct 19 11:25:36 2018 for Gecode by&nbsp;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.6.3</small></address>
</div>

  <script type="text/javascript">
    function showInfo(i, show) {
      var moreinfo = "moreinfo"+i;
      var morelink = "morelink"+i;
      var lesslink = "lesslink"+i;
      var linkstyle = "inline";
      var infostyle = "block";
      if (show) {
        document.getElementById(lesslink).style.display="none";
        document.getElementById(morelink).style.display=linkstyle;
        document.getElementById(moreinfo).style.display=infostyle;
      } else {
        document.getElementById(lesslink).style.display=linkstyle;
        document.getElementById(morelink).style.display="none";
        document.getElementById(moreinfo).style.display="none";
      }
    }
  </script>


<div id="scrollable">
<div id="content">
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>Using allocators with Gecode<br/>
<small>
[<a class="el" href="group__FuncMem.html">Memory management</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGecode_1_1space__allocator.html">Gecode::space_allocator&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocator that allocates memory from a space heap.  <a href="structGecode_1_1space__allocator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGecode_1_1region__allocator.html">Gecode::region_allocator&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocator that allocates memory from a region.  <a href="structGecode_1_1region__allocator.html#_details">More...</a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Gecode provides two allocator classes that can be used with generic data structures such as those of the STL (e.g. <code>std::set</code>). Memory can be allocated from the space heap (see <a class="el" href="classGecode_1_1Space.html" title="Computation spaces.">Space</a>) or from a region (see <a class="el" href="classGecode_1_1Region.html" title="Handle to region.">Region</a>).</p>
<h2><a class="anchor" id="FuncMemAllocatorA">
Using allocators with dynamic data structures</a></h2>
<p>There are two possible scenarios for allocator usage. One is to let the dynamic data structure allocate memory from the space or region:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MySpace : <span class="keyword">public</span> Space {
  <span class="keyword">typedef</span> std::set&lt;int, std::less&lt;int&gt;, <a class="code" href="structGecode_1_1space__allocator.html" title="Allocator that allocates memory from a space heap.">Gecode::space_allocator&lt;int&gt;</a> &gt; S;
  S safe_set;

  MySpace(<span class="keywordtype">void</span>)
    : safe_set(S::key_compare(), S::allocator_type(*this))
  {}

  MySpace(<span class="keywordtype">bool</span> share, MySpace&amp; other)
    : Space(share, other),
      safe_set(other.safe_set.begin(), other.safe_set.end(),
               S::key_compare(), S::allocator_type(*this))
  {}

  ...
};
</pre></div><p>In this example, <em>S</em> is a set that allocates its nodes from the space heap. Note that we pass an instance of <a class="el" href="structGecode_1_1space__allocator.html" title="Allocator that allocates memory from a space heap.">space_allocator</a> bound to this space to the constructor of the set. A similar thing must be done in the copying constructor, where we must be sure to pass an allocator that allocates memory from the destination ("this") space, not "other". Note that the set itself is a member of <em>MySpace</em>, so it is destroyed within <em>MySpace::~MySpace</em> as usual. The set destructor destroys all contained items and deallocates all nodes in its destructors.</p>
<h2><a class="anchor" id="FuncMemAllocatorB">
Preventing unnecessary destruction overhead</a></h2>
<p>In the above example, we know that the value type in <em>S</em> is a builtin type and does not have a destructor. So what happens during <em>safe_set</em> destruction is that it just deallocates all nodes. However, we know that all nodes were allocated from the space heap, which is going to disappear with the space anyway. If we prevent calling <em>safe_set</em> destructor, we may save a significant amount of time during space destruction. A safe way of doing this is to allocate the set object itself on the space heap, and keep only a reference to it as a member of the space. We can use the convenience helpers <a class="el" href="classGecode_1_1Space.html#a10db2595668fc3dd8b4e50fd4fc788c0" title="Construction routines.">Space::construct</a> for the construction.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MySpace : <span class="keyword">public</span> Space {
  <span class="keyword">typedef</span> std::set&lt;int, std::less&lt;int&gt;, <a class="code" href="structGecode_1_1space__allocator.html" title="Allocator that allocates memory from a space heap.">Gecode::space_allocator&lt;int&gt;</a> &gt; S;
  S&amp; fast_set;

  MySpace(<span class="keywordtype">void</span>)
    : fast_set(construct&lt;S&gt;(S::key_compare(), S::allocator_type(*this)))
  {}

  MySpace(MySpace&amp; other)
    : Space(other),
        fast_set(construct&lt;S&gt;(other.safe_set.begin(), other.safe_set.end(),
        S::key_compare(), S::allocator_type(*this)))
  {}

  ...
};
</pre></div><h2><a class="anchor" id="FuncMemAllocatorC">
Region example</a></h2>
<p>The above examples were using a <a class="el" href="structGecode_1_1space__allocator.html" title="Allocator that allocates memory from a space heap.">space_allocator</a>. A <a class="el" href="structGecode_1_1region__allocator.html" title="Allocator that allocates memory from a region.">region_allocator</a> works similarly, one just should keep in mind that regions never really release any memory. Similar to <a class="el" href="classGecode_1_1Space.html" title="Computation spaces.">Space</a>, <a class="el" href="classGecode_1_1Region.html" title="Handle to region.">Region</a> provides helper functions <a class="el" href="classGecode_1_1Region.html#ae894c3ed3aefb1e18ab68b8cb0aa8104" title="Constructs a single object of type T from region using the default constructor.">Region::construct</a> to make non-stack allocation easy.</p>
<div class="fragment"><pre class="fragment">Space&amp; home = ...;
<span class="keyword">typedef</span> std::set&lt;int, std::less&lt;int&gt;, <a class="code" href="structGecode_1_1region__allocator.html" title="Allocator that allocates memory from a region.">Gecode::region_allocator&lt;int&gt;</a> &gt; SR;
<span class="comment">// Create a set with the region allocator. Note that the set destructor is still quite costly...</span>
{
  Region <a class="code" href="bool-expr_8cpp.html#ad249d5ef98e6c30c655f43872c05647e" title="Right subtree.">r</a>;
  SR r_safe_set(SR::key_compare(), (SR::allocator_type(r)));
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="group__TaskTestIntBasic.html#ga26f3478377f859b0c282d6ca1f1c4a9c">i</a>=0; <a class="code" href="group__TaskTestIntBasic.html#ga26f3478377f859b0c282d6ca1f1c4a9c">i</a>&lt;10000; ++<a class="code" href="group__TaskTestIntBasic.html#ga26f3478377f859b0c282d6ca1f1c4a9c">i</a>)
    r_safe_set.insert(<a class="code" href="group__TaskTestIntBasic.html#ga26f3478377f859b0c282d6ca1f1c4a9c">i</a>*75321%10000);
}
<span class="comment">// Create a set directly in the region (not on the stack). No destructors will be called.</span>
{
  Region r;
  SR&amp; r_fast_set=r.construct&lt;SR&gt;(SR::key_compare(), SR::allocator_type(r));
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="group__TaskTestIntBasic.html#ga26f3478377f859b0c282d6ca1f1c4a9c">i</a>=0; <a class="code" href="group__TaskTestIntBasic.html#ga26f3478377f859b0c282d6ca1f1c4a9c">i</a>&lt;10000; ++<a class="code" href="group__TaskTestIntBasic.html#ga26f3478377f859b0c282d6ca1f1c4a9c">i</a>)
    r_fast_set.insert(<a class="code" href="group__TaskTestIntBasic.html#ga26f3478377f859b0c282d6ca1f1c4a9c">i</a>*75321%10000);
}
</pre></div> </div>
</div></div>
</body>
</html>
