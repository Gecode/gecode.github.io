From ottenl at student.chalmers.se  Fri Feb  3 01:39:07 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Fri, 03 Feb 2006 00:39:07 +0000
Subject: [gecode-users] Unexpected propagation/search behaviour
In-Reply-To: <000d01c621b4$66ec9b50$0401a8c0@tiny>
References: <000d01c621b4$66ec9b50$0401a8c0@tiny>
Message-ID: <43E2A62B.7060703@student.chalmers.se>

Hi,

On 01/25/06 13:36, Christian Schulte wrote:
> I meant to simplify your program to find the fault. Maybe try to
> incrementally go for the solution you want to obtain in the end (just
> remebering for some propagators but not for all, maybe exclude element?).

I did as you suggested and was thereby able to determine the 'critical'
part. As soon as I do not perform the 'remembering' for the first of the two
element propagators posted in each run of Tunneling::propagate(Space*) I get
the different behaviour mentioned before.

In other words, reposting the element propagators for the IntVarArray suc
makes the program find a solution rather quickly, not reposting those makes
the program run 'forever' (i.e. more than a few minutes, at which point I
aborted).

I also added some diagnostic output to the constructors and destructors of
the element propagator and as expected the two versions start out the same.
Just after the first few element propagators being posted the
non-remembering version posts the constraints for some indices over and over
again whereas the remembering version doesn't...

Any more ideas about this? I am really at a loss here...

/Lars



From schulte at imit.kth.se  Fri Feb  3 14:17:01 2006
From: schulte at imit.kth.se (Christian Schulte)
Date: Fri, 3 Feb 2006 14:17:01 +0100
Subject: [gecode-users] Unexpected propagation/search behaviour
In-Reply-To: <43E2A62B.7060703@student.chalmers.se>
Message-ID: <004401c628c4$1e9dd8c0$acd4ed82@beule>

How do you remember. Globally? That you can't do. You have to remember for
each space (like: does this space already have the propagators posted). Do
you do that? 

Otherwise your logic appears to be flawed somehow. It looks as if you
continue with spaces that lack the propagators! 

Sorry that's all what comes to mind
Christian

--
Christian Schulte, http://www.imit.kth.se/~schulte/ 

-----Original Message-----
From: Lars Otten [mailto:ottenl at student.chalmers.se] 
Sent: Friday, February 03, 2006 1:39 AM
To: schulte at imit.kth.se; users at gecode.org
Subject: Re: [gecode-users] Unexpected propagation/search behaviour


Hi,

On 01/25/06 13:36, Christian Schulte wrote:
> I meant to simplify your program to find the fault. Maybe try to 
> incrementally go for the solution you want to obtain in the end (just 
> remebering for some propagators but not for all, maybe exclude 
> element?).

I did as you suggested and was thereby able to determine the 'critical'
part. As soon as I do not perform the 'remembering' for the first of the two
element propagators posted in each run of Tunneling::propagate(Space*) I get
the different behaviour mentioned before.

In other words, reposting the element propagators for the IntVarArray suc
makes the program find a solution rather quickly, not reposting those makes
the program run 'forever' (i.e. more than a few minutes, at which point I
aborted).

I also added some diagnostic output to the constructors and destructors of
the element propagator and as expected the two versions start out the same.
Just after the first few element propagators being posted the
non-remembering version posts the constraints for some indices over and over
again whereas the remembering version doesn't...

Any more ideas about this? I am really at a loss here...

/Lars




From ottenl at student.chalmers.se  Fri Feb  3 15:44:14 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Fri, 03 Feb 2006 14:44:14 +0000
Subject: [gecode-users] Unexpected propagation/search behaviour
In-Reply-To: <004401c628c4$1e9dd8c0$acd4ed82@beule>
References: <004401c628c4$1e9dd8c0$acd4ed82@beule>
Message-ID: <43E36C3E.3080607@student.chalmers.se>

On 02/03/06 13:17, Christian Schulte wrote:
> How do you remember. Globally? That you can't do. You have to remember for
> each space (like: does this space already have the propagators posted). Do
> you do that?

Sort of, yes: I don't remember for the individual spaces but for each
instance of my tunneling propagator (which in turn each space has exactly
one instance of).

Each of these tunneling instances has fields of type set<int> that
'remember' if the respective element propagator has been posted.

And clones of these fields are made upon cloning of the tunneling propagator
-- also clones of the existing element propagators should be made upon space
cloning, so the overall state should remain consistent.

> Otherwise your logic appears to be flawed somehow. It looks as if you
> continue with spaces that lack the propagators!

Yes, that was my thought as well -- but, apart from when a space fails,
propagators should only 'disappear' if they return ES_SUBSUMED, i.e. the
resp. variables have been fixed and the implied constraint is satisfied. And
then reposting the propagator shouldn't make a difference.

Is it possible for a propagator to vanish although it is not subsumed yet?

/Lars




From ottenl at student.chalmers.se  Tue Feb  7 17:15:49 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Tue, 07 Feb 2006 16:15:49 +0000
Subject: [gecode-users] Value selection when branching
Message-ID: <43E8C7B5.3000904@student.chalmers.se>

Hi and Hello,

I still haven't solved the previous problem (about the strange propagation
behaviour), but since for the moment there is a workaround, I have started
to work on some other things at the same time, one of them random value
selection when branching.

By just looking at the existing classes in int/branch/select-val.icc (and
int/branch.hh) I wrote with the following:

  class ValRand {
  public:
   /// Return random value of view \a x, uniformly distributed
   int val(IntView x);
   /// Tell \f$x=n\f$ (\a a = 0) or \f$x\neq n\f$ (\a a = 1)
   ModEvent tell(Space* home, unsigned int a, IntView x, int n);
  };

  forceinline int
  ValRand::val(IntView x) {
    ViewValues<IntView> vv(x);
    int choice = (int) (x.size() * (rand() / (RAND_MAX + 1.0)));
    while (choice--) { ++vv; }
    return vv.val();
  }
  forceinline ModEvent
  ValRand::tell(Space* home, unsigned int a, IntView x, int n) {
    assert((a == 0) || (a == 1));
    return (a == 0) ? x.eq(home,n) : x.nq(home,n);
  }

I've also added the value BVAL_RAND to BvalSel for the case distinction
inside the create method in select-val.icc, everything compiles and runs
without errors. Moreover I've added a command line parameter "-seed" to set
the global random seed.

To just test this new part I changed some existing examples to use
BVAL_RAND, e.g. all-intervall.cc.

Still using the default BVAL_MIN I obtain:
$ /examples/all-interval 10 -solutions 200 | grep solutions
	solutions:    74

But then, after the change to BVAL_RAND:
$ ./examples/all-interval 10 -solutions 200 -seed 1 | grep solutions
	solutions:    3
$ ./examples/all-interval 10 -solutions 200 -seed 2 | grep solutions
	solutions:    118
$ ./examples/all-interval 10 -solutions 200 -seed 3 | grep solutions
	solutions:    100
$ ./examples/all-interval 10 -solutions 200 -seed 37582 | grep solutions
	solutions:    125

...and so on, you get the idea. Clearly something is wrong here. ;) Even
though values are chosen randomly, in the end the number of solutions should
be the same. And since for this setting all that was changed/added are the
things above, the error should be within there. Still I can't see the
problem, esp. when comparing it to the existing value selection classes.

Just to rule out other factors I've donwnloaded a fresh copy of the v1.0.0
sources into a different folder and made just the changes described above,
but to no avail...

Any ideas?

Thanks and best regards,

/Lars





From tack at ps.uni-sb.de  Tue Feb  7 16:38:28 2006
From: tack at ps.uni-sb.de (Guido Tack)
Date: Tue, 7 Feb 2006 16:38:28 +0100
Subject: [gecode-users] Value selection when branching
In-Reply-To: <43E8C7B5.3000904@student.chalmers.se>
References: <43E8C7B5.3000904@student.chalmers.se>
Message-ID: <200602071638.28310.tack@ps.uni-sb.de>

Hi.

> I still haven't solved the previous problem (about the strange propagation
> behaviour), but since for the moment there is a workaround, I have started
> to work on some other things at the same time, one of them random value
> selection when branching.

Uh, I tried that too and failed miserably ;-)

> I've also added the value BVAL_RAND to BvalSel for the case distinction
> inside the create method in select-val.icc, everything compiles and runs
> without errors. Moreover I've added a command line parameter "-seed" to set
> the global random seed.
>
> To just test this new part I changed some existing examples to use
> BVAL_RAND, e.g. all-intervall.cc.
>
> Still using the default BVAL_MIN I obtain:
> $ /examples/all-interval 10 -solutions 200 | grep solutions
> 	solutions:    74
>
> But then, after the change to BVAL_RAND:
> $ ./examples/all-interval 10 -solutions 200 -seed 1 | grep solutions
> 	solutions:    3
> $ ./examples/all-interval 10 -solutions 200 -seed 2 | grep solutions
> 	solutions:    118
> $ ./examples/all-interval 10 -solutions 200 -seed 3 | grep solutions
> 	solutions:    100
> $ ./examples/all-interval 10 -solutions 200 -seed 37582 | grep solutions
> 	solutions:    125
>
> ...and so on, you get the idea. Clearly something is wrong here. ;) Even
> though values are chosen randomly, in the end the number of solutions
> should be the same. And since for this setting all that was changed/added
> are the things above, the error should be within there. Still I can't see
> the problem, esp. when comparing it to the existing value selection
> classes.

To understand this behaviour, you have to understand how the search engine 
works. One severe problem is recomputation: this requires that the branching 
is deterministic, i.e. for equivalent spaces it must always result in the 
same choice. This is clearly not the case here. You could switch off 
recomputation by giving -c_d 1 -a_d 1 as command line parameters. Please try 
out if that changes anything.
It might still not work, because even if you never recompute spaces, you are 
not guaranteed that for one space at one point in the search tree the 
branching is evaluated only once. The only way out of this trap is to use 
something that will be completely deterministic, so that for equivalent 
spaces you will always get the same choice.

Cheers,
	Guido

-- 
Guido Tack
Programming Systems Lab, Saarland University, Germany
http://www.ps.uni-sb.de/~tack



From schulte at imit.kth.se  Tue Feb  7 16:49:59 2006
From: schulte at imit.kth.se (Christian Schulte)
Date: Tue, 7 Feb 2006 16:49:59 +0100
Subject: [gecode-users] Value selection when branching
In-Reply-To: <200602071638.28310.tack@ps.uni-sb.de>
Message-ID: <002c01c62bfe$264b1460$acd4ed82@beule>

It is all true what Guido says, but something more useful is the following:
also random number generators are deterministic programs. The only problem
is when you use the OS random number generator: here the state of the random
number generator is hidden.

So what you can do is the following: look up a random number generator (such
as in Knuth "Seminumerical Algorithms"). Store the state of the generator in
the branching. Then your branching can guarantee that for the same state of
the branching you will always return the same random values. 

This then also works with recomputation.

Christian

--
Christian Schulte, http://www.imit.kth.se/~schulte/ 

-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Guido Tack
Sent: Tuesday, February 07, 2006 4:38 PM
To: users at gecode.org
Subject: Re: [gecode-users] Value selection when branching


Hi.

> I still haven't solved the previous problem (about the strange 
> propagation behaviour), but since for the moment there is a 
> workaround, I have started to work on some other things at the same 
> time, one of them random value selection when branching.

Uh, I tried that too and failed miserably ;-)

> I've also added the value BVAL_RAND to BvalSel for the case 
> distinction inside the create method in select-val.icc, everything 
> compiles and runs without errors. Moreover I've added a command line 
> parameter "-seed" to set the global random seed.
>
> To just test this new part I changed some existing examples to use 
> BVAL_RAND, e.g. all-intervall.cc.
>
> Still using the default BVAL_MIN I obtain:
> $ /examples/all-interval 10 -solutions 200 | grep solutions
> 	solutions:    74
>
> But then, after the change to BVAL_RAND:
> $ ./examples/all-interval 10 -solutions 200 -seed 1 | grep solutions
> 	solutions:    3
> $ ./examples/all-interval 10 -solutions 200 -seed 2 | grep solutions
> 	solutions:    118
> $ ./examples/all-interval 10 -solutions 200 -seed 3 | grep solutions
> 	solutions:    100
> $ ./examples/all-interval 10 -solutions 200 -seed 37582 | grep solutions
> 	solutions:    125
>
> ...and so on, you get the idea. Clearly something is wrong here. ;) 
> Even though values are chosen randomly, in the end the number of 
> solutions should be the same. And since for this setting all that was 
> changed/added are the things above, the error should be within there. 
> Still I can't see the problem, esp. when comparing it to the existing 
> value selection classes.

To understand this behaviour, you have to understand how the search engine 
works. One severe problem is recomputation: this requires that the branching

is deterministic, i.e. for equivalent spaces it must always result in the 
same choice. This is clearly not the case here. You could switch off 
recomputation by giving -c_d 1 -a_d 1 as command line parameters. Please try

out if that changes anything.
It might still not work, because even if you never recompute spaces, you are

not guaranteed that for one space at one point in the search tree the 
branching is evaluated only once. The only way out of this trap is to use 
something that will be completely deterministic, so that for equivalent 
spaces you will always get the same choice.

Cheers,
	Guido

-- 
Guido Tack
Programming Systems Lab, Saarland University, Germany
http://www.ps.uni-sb.de/~tack

_______________________________________________
Gecode users mailing list
users at gecode.org https://www.gecode.org/mailman/listinfo/gecode-users




From ottenl at student.chalmers.se  Tue Feb  7 17:54:42 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Tue, 07 Feb 2006 16:54:42 +0000
Subject: [gecode-users] Value selection when branching
In-Reply-To: <200602071638.28310.tack@ps.uni-sb.de>
References: <43E8C7B5.3000904@student.chalmers.se>
	<200602071638.28310.tack@ps.uni-sb.de>
Message-ID: <43E8D0D2.10604@student.chalmers.se>

Hi,

On 02/07/06 15:38, Guido Tack wrote:
>> I still haven't solved the previous problem (about the strange propagation
>> behaviour), but since for the moment there is a workaround, I have started
>> to work on some other things at the same time, one of them random value
>> selection when branching.
> 
> Uh, I tried that too and failed miserably ;-)

That does not sound promising... :-/

> To understand this behaviour, you have to understand how the search engine 
> works. One severe problem is recomputation: this requires that the branching 
> is deterministic, i.e. for equivalent spaces it must always result in the 
> same choice. This is clearly not the case here. You could switch off 
> recomputation by giving -c_d 1 -a_d 1 as command line parameters. Please try 
> out if that changes anything.

Nope, doesn't help. Thanks nevertheless.

> It might still not work, because even if you never recompute spaces, you are 
> not guaranteed that for one space at one point in the search tree the 
> branching is evaluated only once. The only way out of this trap is to use 
> something that will be completely deterministic, so that for equivalent 
> spaces you will always get the same choice.

Well, the whole point here is (pseudo-)nondeterminism. ;-)
I will have to think about the problem a little bit and see what I can come
up with.

/Lars




From ottenl at student.chalmers.se  Tue Feb  7 18:16:05 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Tue, 07 Feb 2006 17:16:05 +0000
Subject: [gecode-users] Value selection when branching
In-Reply-To: <002c01c62bfe$264b1460$acd4ed82@beule>
References: <002c01c62bfe$264b1460$acd4ed82@beule>
Message-ID: <43E8D5D5.2000801@student.chalmers.se>

Hi,

On 02/07/06 15:49, Christian Schulte wrote:
> It is all true what Guido says, but something more useful is the following:
> also random number generators are deterministic programs. The only problem
> is when you use the OS random number generator: here the state of the random
> number generator is hidden.

In principle it is hidden, yes. However upon initialisation with the same
seed, the same numbers should be produced. So the trick might lie in making
sure the seed is the same when performing recomputation...

> So what you can do is the following: look up a random number generator (such
> as in Knuth "Seminumerical Algorithms"). Store the state of the generator in
> the branching. Then your branching can guarantee that for the same state of
> the branching you will always return the same random values. 

Yeah, I had something similar in mind, but I had not yet thought it through
completely. Thanks for the pointer.

If I recall correctly there's a function rand_r(int*) that might be useful
for my purposes, as an alternative to implementing my own generator --
which, on the other hand, shouldn't be that much work after all (a basic one
is given in the manpage for rand() as well).

> This then also works with recomputation.

I've just put up an order for Knuth's book at our library, I will look into
this and let you know how it works out. Thanks for the hints so far. :)

/Lars



From zayenz at gmail.com  Tue Feb  7 17:47:18 2006
From: zayenz at gmail.com (Mikael 'Zayenz' Lagerkvist)
Date: Tue, 7 Feb 2006 17:47:18 +0100
Subject: [gecode-users] Value selection when branching
In-Reply-To: <43E8D5D5.2000801@student.chalmers.se>
References: <002c01c62bfe$264b1460$acd4ed82@beule>
	<43E8D5D5.2000801@student.chalmers.se>
Message-ID: <63b5c8b00602070847x34563999rec99ab6b7c926dcb@mail.gmail.com>

On 2/7/06, Lars Otten <ottenl at student.chalmers.se> wrote:
> If I recall correctly there's a function rand_r(int*) that might be useful
> for my purposes, as an alternative to implementing my own generator --
> which, on the other hand, shouldn't be that much work after all (a basic one
> is given in the manpage for rand() as well).

In test/random.cc in the gecode directory, there is a linear
congruential random number generator suggested as "good enough" by
Knuth for applications where "true" randomness is not that important.
It is simple, and has a clear value for it's state. This could be a
good starting-point for you.

Cheers
Mikael

--
Mikael 'Zayenz' Lagerkvist, http://www.imit.kth.se/~zayenz/



From schulte at imit.kth.se  Tue Feb  7 17:56:44 2006
From: schulte at imit.kth.se (Christian Schulte)
Date: Tue, 7 Feb 2006 17:56:44 +0100
Subject: [gecode-users] CP 2006: Call for Workshop and Tutorial Proposals
Message-ID: <003401c62c07$79b5f940$acd4ed82@beule>


              CP 2006 -- CALL FOR WORKSHOP AND TUTORIAL PROPOSALS

                    Twelfth International Conference on
               Principles and Practice of Constraint Programming

                     http://www.sciences.univ-nantes.fr/cp06/


The CP 2006 Program Committee invites proposals for the Workshop and
Tutorial
Program. CP 2006 will be held in Nantes, France from September 25th-29th.



WORKSHOPS

CP 2006 workshops will provide an informal setting where workshop
participants will have the opportunity to discuss specific technical topics
in an atmosphere that facilitates the active exchange of ideas. It is an
opportunity to disseminate work in progress or to promote new and emerging
areas within the field of constraints. The topics of the workshops can cover
any area related to constraints and any related cross-disciplinary areas.

Workshops will be half-day long, except special cases motivated by the
organizers. The internal format of the workshop will be determined by the
organizers. 

Important Dates for Workshops
    * March 31, 2006: Proposal submission deadline
    * April 14, 2006: Acceptance notification
    * April 28, 2006: Deadline for receipt of URL for workshop web page
    * Mid August, 2006: Deadline for workshop notes (TBD)
    * September 25, 2006: CP 2006 workshops



TUTORIALS

CP 2006 tutorials are ideally targeted at the whole constraint community and
should give a state-of-the-art description of a field of research related to
constraint programming or of a large area of application. As an example, the
topics of tutorials in the previous CP conferences were: numerical CSPs,
global
constraints, soft constraints, mathematical programming, cooperation between
methods, areas of application (eg. bioinformatics), etc.

Tutorials will take place during the technical program.

Important Dates for Tutorials
    * May 19, 2006: Proposal submission deadline
    * June 16, 2006: Acceptance notification
    * Mid August, 2006: Deadline for tutorial notes (TBD)
    * September 25-29, 2006: CP technical program and tutorials


A summary of the submission procedures for workshops and tutorials are
available from the CP-06 web-site: http://www.sciences.univ-nantes.fr/cp06/



WORKSHOP AND TUTORIAL CHAIR

Barry O'Sullivan
Cork Constraint Computation Centre
 




From ottenl at student.chalmers.se  Wed Feb  8 19:03:46 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Wed, 08 Feb 2006 18:03:46 +0000
Subject: [gecode-users] Unexpected propagation/search behaviour
In-Reply-To: <43E36C3E.3080607@student.chalmers.se>
References: <004401c628c4$1e9dd8c0$acd4ed82@beule>
	<43E36C3E.3080607@student.chalmers.se>
Message-ID: <43EA3282.60100@student.chalmers.se>

Ok, I have spent some more time on this issue and came up with the following:

Instead of posting one 'global' propagator which repeatedly checks all array
entries, I have implemented the equivalent individual propagators for each
of the individual variables. These constraints are derived from
UnaryPropagator<IntView,PC_INT_VAL> and, for their respective variable, post
the appropriate new 'child constraints' upon value assignment (due to
PC_INT_VAL).

(I have thus traded a constant number of propagators with linear running
time against a linear number of propagators with constant running time, so
performance-wise that should be OK)

Furthermore I can now rule out potential flaws in my logic about remembering
which variables have been processed before, since this logic is gone and
Gecode logic is used instead.

Unfortunately this didn't help: in contrast to the previous version, where I
keep reposting the said child constraints, no solution is found for several
minutes (where I cancel the program as my computer is out of memory), just
as in the old version with 'memory' to avoid reposting.

So I'm again running out of ideas... :-P I guess I will leave it at that for
now.

/Lars



From ottenl at student.chalmers.se  Thu Feb  9 12:50:25 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Thu, 09 Feb 2006 11:50:25 +0000
Subject: [gecode-users] Shared datastructures & CopyNode fields
Message-ID: <43EB2C81.5040008@student.chalmers.se>

Hello,

while delving into the details of the DFS engine I encountered an unclear
statement in the documentation for Space::clone(bool, unsigned long int&).
It is written that "[...] a clone of the space is returned. If \a shared is
true, all shared datastructures are shared among the clone on the original
space. [...]"

What exactly are these "shared datastructures" here? Furthermore, in a
strict sense, isn't it strange to define the sharing of datastructures that
are, judging by their name, already shared? Do you perhaps mean /shareable/
datastructures?

Another issue on which I'd grealy appreciate some clarification: What
exactly is the purpose of the fields _alt and _last in the class
Gecode::Search::CopyNode? I have some rough ideas but as I've still not
completely understood all of the DFS code it's hard to verify those...

Thanks,

/Lars






From schulte at imit.kth.se  Thu Feb  9 13:18:56 2006
From: schulte at imit.kth.se (Christian Schulte)
Date: Thu, 9 Feb 2006 13:18:56 +0100
Subject: [gecode-users] Shared datastructures & CopyNode fields
In-Reply-To: <43EB2C81.5040008@student.chalmers.se>
Message-ID: <001301c62d72$ffae6a20$acd4ed82@beule>

You are aright about shareable, I just clariefied the docs. Shareable means
"can be shared among spaces in one thread". 

For DFS, _alt refers to the number of the next alternative to be explored,
and _last to the total number of alternatives.

Christian

--
Christian Schulte, http://www.imit.kth.se/~schulte/ 

-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Lars Otten
Sent: Thursday, February 09, 2006 12:50 PM
To: users at gecode.org
Subject: [gecode-users] Shared datastructures & CopyNode fields


Hello,

while delving into the details of the DFS engine I encountered an unclear
statement in the documentation for Space::clone(bool, unsigned long int&).
It is written that "[...] a clone of the space is returned. If \a shared is
true, all shared datastructures are shared among the clone on the original
space. [...]"

What exactly are these "shared datastructures" here? Furthermore, in a
strict sense, isn't it strange to define the sharing of datastructures that
are, judging by their name, already shared? Do you perhaps mean /shareable/
datastructures?

Another issue on which I'd grealy appreciate some clarification: What
exactly is the purpose of the fields _alt and _last in the class
Gecode::Search::CopyNode? I have some rough ideas but as I've still not
completely understood all of the DFS code it's hard to verify those...

Thanks,

/Lars




_______________________________________________
Gecode users mailing list
users at gecode.org https://www.gecode.org/mailman/listinfo/gecode-users




From ottenl at student.chalmers.se  Thu Feb  9 14:13:29 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Thu, 09 Feb 2006 13:13:29 +0000
Subject: [gecode-users] Value selection when branching
In-Reply-To: <63b5c8b00602070847x34563999rec99ab6b7c926dcb@mail.gmail.com>
References: <002c01c62bfe$264b1460$acd4ed82@beule>	
	<43E8D5D5.2000801@student.chalmers.se>
	<63b5c8b00602070847x34563999rec99ab6b7c926dcb@mail.gmail.com>
Message-ID: <43EB3FF9.1030400@student.chalmers.se>

On 02/07/06 16:47, Mikael 'Zayenz' Lagerkvist wrote:
> In test/random.cc in the gecode directory, there is a linear
> congruential random number generator suggested as "good enough" by
> Knuth for applications where "true" randomness is not that important.
> It is simple, and has a clear value for it's state. This could be a
> good starting-point for you.

Thanks for the hint, this did indeed prove to be a good starting point,
together with the details in Knuth's book.

By the way, I think there's a little bug in the random.cc code:

  void seed(unsigned int val) {
    if(val) x = val % m;
    else    val = 1;  // shouldn't that be x=1 ?
  }

Cheers,
/Lars



From zayenz at gmail.com  Thu Feb  9 17:23:08 2006
From: zayenz at gmail.com (Mikael 'Zayenz' Lagerkvist)
Date: Thu, 9 Feb 2006 17:23:08 +0100
Subject: [gecode-users] Value selection when branching
In-Reply-To: <43EB3FF9.1030400@student.chalmers.se>
References: <002c01c62bfe$264b1460$acd4ed82@beule>
	<43E8D5D5.2000801@student.chalmers.se>
	<63b5c8b00602070847x34563999rec99ab6b7c926dcb@mail.gmail.com>
	<43EB3FF9.1030400@student.chalmers.se>
Message-ID: <63b5c8b00602090823yaa1241at262f9dbde09ca911@mail.gmail.com>

On 2/9/06, Lars Otten <ottenl at student.chalmers.se> wrote:
> By the way, I think there's a little bug in the random.cc code:
>
>   void seed(unsigned int val) {
>     if(val) x = val % m;
>     else    val = 1;  // shouldn't that be x=1 ?
>   }

Yes, that was a bug. Thanks for finding it.

Cheers,
Mikael

--
Mikael 'Zayenz' Lagerkvist, http://www.imit.kth.se/~zayenz/



From ottenl at student.chalmers.se  Thu Feb  9 19:49:59 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Thu, 09 Feb 2006 18:49:59 +0000
Subject: [gecode-users] Value selection when branching
In-Reply-To: <43E8D5D5.2000801@student.chalmers.se>
References: <002c01c62bfe$264b1460$acd4ed82@beule>
	<43E8D5D5.2000801@student.chalmers.se>
Message-ID: <43EB8ED7.9060506@student.chalmers.se>

Hi again,

On 02/07/06 17:16, Lars Otten wrote:
> I've just put up an order for Knuth's book at our library, I will look into
> this and let you know how it works out. Thanks for the hints so far. :)

As promised I want to give you a brief update:

Things worked out quite well. I created a new class ViewValRandBranching,
which inherits from ViewValBranching with two additional fields (for the
random seeds). Upon creation of the branching these fields are initialised
to random numbers from a random number generator similar to the one in
test/random.cc pointed out by Mikael; one field is used as random seed for
view selection, the other one for value selection.

Now the two important methods are basically just wrappers around the old ones:

ViewValRandBranching<View,Val,ViewSel,ValSel>::branch(void) {
  unsigned int tmpseed = ge_srand(); // get current random seed
  ge_srand(rseedView); // set 'private' random seed
  unsigned int s = ViewValBranching<View,Val,ViewSel,ValSel>::branch();
  ge_srand(tmpseed); // restore original random seed
  return s;
}

ViewValRandBranching<View,Val,ViewSel,ValSel>::commit
(Space* home, unsigned int a, BranchingDesc* d) {
  unsigned int tmpseed = ge_srand(); // get current random seed
  ge_srand(rseedVal); // set 'private' random seed
  ExecStatus s =
    ViewValBranching<View,Val,ViewSel,ValSel>::commit(home, a, d);
  ge_srand(tmpseed); // restore original random seed
  return s;
}

And, lo and behold, now it seems to work! The same tests I did earlier (e.g.
with all-intervall) now nicely return the same number of solutions for all
different random seeds I tried (also the same number as the nonrandom
version). :-)

Thanks for the help with this,

/Lars



From ottenl at student.chalmers.se  Fri Feb 10 16:22:30 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Fri, 10 Feb 2006 15:22:30 +0000
Subject: [gecode-users] Value selection when branching
In-Reply-To: <43EB8ED7.9060506@student.chalmers.se>
References: <002c01c62bfe$264b1460$acd4ed82@beule>	<43E8D5D5.2000801@student.chalmers.se>
	<43EB8ED7.9060506@student.chalmers.se>
Message-ID: <43ECAFB6.4000008@student.chalmers.se>

On 02/09/06 18:49, Lars Otten wrote:
> Things worked out quite well. [...]
> And, lo and behold, now it seems to work!

Turns out it wasn't easy as it seemed:

For a start I forgot to adapt the description() method for my
ViewValRandBranching class, as it involves value selection as well.

But, more importantly, I just realized that the constructor for the
Branching class is usually only called once, upon invoking the
Gecode::branch(...) method in the example -- thus the seeds for the random
number generator are only fixed once and the same sequence of random numbers
is used over and over again -- which in effect seriously limits the randomness.

So I guess I'll have to revise it yet again... :-/

Have a nice weekend,
/Lars



From ottenl at student.chalmers.se  Mon Feb 13 18:02:38 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Mon, 13 Feb 2006 17:02:38 +0000
Subject: [gecode-users] Value selection when branching
In-Reply-To: <43ECAFB6.4000008@student.chalmers.se>
References: <002c01c62bfe$264b1460$acd4ed82@beule>	<43E8D5D5.2000801@student.chalmers.se>	<43EB8ED7.9060506@student.chalmers.se>
	<43ECAFB6.4000008@student.chalmers.se>
Message-ID: <43F0BBAE.7020101@student.chalmers.se>

On 02/10/06 15:22, Lars Otten wrote:
> Turns out it wasn't easy as it seemed:
> [...]
> So I guess I'll have to revise it yet again... :-/

Finally it seems to work, after digging deeper into the DFS engine I came up
with the following:

The Branching object instances still keep a record of their resp. random
seeds and reinitialise the random number generator everytime a random choice
is to be made. This way, as long as a given space does not change its
'state', the random choices will be deterministic.

At the end of the Branching's commit function, though, we can be sure that
something in the space's state has changed, i.e. that at least one
variable's domain has changed. Thus at this time we can change the
Branching's random seeds, so that in the new state the random choices will
be different (but still consistent).

One question is then of course how to reinitialise the random seeds after
commiting, I'm currently looking into several ideas for this...

Thanks to Mikael for tipping me off towards this approach. :)

/Lars



From ottenl at student.chalmers.se  Tue Feb 14 00:44:43 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Mon, 13 Feb 2006 23:44:43 +0000
Subject: [gecode-users] View selection approach in Gecode
Message-ID: <43F119EB.5070700@student.chalmers.se>

Hi everyone,

I've started looking into random view selection for branching and hence
examined the way the next view to be branched on is selected in Gecode.
After comprehending the source code (kernel/branching.icc and int/branch*) I
can't help wondering why it's done the way it currently is.

To be specific: Why did you choose this 'incremental' approach, handing one
view after another to the view selection class instance, instead of just
passing the ViewArray right from the start? The latter would be comparable
to the value selection process, where the whole view is passed and not one
value after another...

As I see it, I can just modify this scheme (or rather add my own next to it)
since this 'incremental' approach won't work for my purposes; nevertheless I
think I'm missing something here and I'd like to understand your design
before I start implementing my random view selection so I can avoid
potential pitfalls...

Thanks in advance (once more),
/Lars




From schulte at imit.kth.se  Tue Feb 14 09:47:18 2006
From: schulte at imit.kth.se (Christian Schulte)
Date: Tue, 14 Feb 2006 09:47:18 +0100
Subject: [gecode-users] View selection approach in Gecode
In-Reply-To: <43F119EB.5070700@student.chalmers.se>
Message-ID: <008401c63143$43153130$acd4ed82@beule>

Very simple, indeed: Remember, this is an abstraction. The abstraction works
very well for the 20+ branchings in Gecode. However, if you want a different
abstraction, do that: just inherit from branching.

The reason why the loop (which is quite smart as it remembers already
assigned views as well as handles tie breaking) is not exposed is because it
is not needed: all the branchings we ship can be express4ed just by view
comparison.

Christian

--
Christian Schulte, http://www.imit.kth.se/~schulte/ 

-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Lars Otten
Sent: Tuesday, February 14, 2006 12:45 AM
To: users at gecode.org
Subject: [gecode-users] View selection approach in Gecode


Hi everyone,

I've started looking into random view selection for branching and hence
examined the way the next view to be branched on is selected in Gecode.
After comprehending the source code (kernel/branching.icc and int/branch*) I
can't help wondering why it's done the way it currently is.

To be specific: Why did you choose this 'incremental' approach, handing one
view after another to the view selection class instance, instead of just
passing the ViewArray right from the start? The latter would be comparable
to the value selection process, where the whole view is passed and not one
value after another...

As I see it, I can just modify this scheme (or rather add my own next to it)
since this 'incremental' approach won't work for my purposes; nevertheless I
think I'm missing something here and I'd like to understand your design
before I start implementing my random view selection so I can avoid
potential pitfalls...

Thanks in advance (once more),
/Lars


_______________________________________________
Gecode users mailing list
users at gecode.org https://www.gecode.org/mailman/listinfo/gecode-users




From rafaparafernalia at gmail.com  Fri Feb 24 00:54:22 2006
From: rafaparafernalia at gmail.com (Rafael Meneses)
Date: Thu, 23 Feb 2006 20:54:22 -0300
Subject: [gecode-users] How control the engine??
Message-ID: <d701e0390602231554i2ddc3aa6y297d2eab685080@mail.gmail.com>

Hi, I am working in a problem and I need a more fine control of the search.

I use the BAB engine and I need that the search have a timeout. There
is  a way to control the end condition of the search or I have
implement one by myself ???


Thanks....

Gecode Rock's ;)
--
Rafael Meneses
http://www.labsd.inf.utfsm.cl/~rmeneses



From schulte at imit.kth.se  Fri Feb 24 10:01:37 2006
From: schulte at imit.kth.se (Christian Schulte)
Date: Fri, 24 Feb 2006 10:01:37 +0100
Subject: [gecode-users] How control the engine??
In-Reply-To: <d701e0390602231554i2ddc3aa6y297d2eab685080@mail.gmail.com>
Message-ID: <003201c63920$eb169420$acd4ed82@beule>

No, the only way you currently can interrupt is in between requesting better
solutions from the BAB engine. However this sounds like a useful (and
reasonably simple) addition, even though it should be a user supplied stop
criterion being more general than just time... But it should be very simple
for you to hack something up by yourself and tell us...

Christian

--
Christian Schulte, http://www.imit.kth.se/~schulte/ 

-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Rafael Meneses
Sent: Friday, February 24, 2006 12:54 AM
To: users at gecode.org
Subject: [gecode-users] How control the engine??


Hi, I am working in a problem and I need a more fine control of the search.

I use the BAB engine and I need that the search have a timeout. There is  a
way to control the end condition of the search or I have implement one by
myself ???


Thanks....

Gecode Rock's ;)
--
Rafael Meneses
http://www.labsd.inf.utfsm.cl/~rmeneses

_______________________________________________
Gecode users mailing list
users at gecode.org https://www.gecode.org/mailman/listinfo/gecode-users




From tack at ps.uni-sb.de  Fri Feb 24 10:12:51 2006
From: tack at ps.uni-sb.de (Guido Tack)
Date: Fri, 24 Feb 2006 10:12:51 +0100
Subject: [gecode-users] How control the engine??
In-Reply-To: <003201c63920$eb169420$acd4ed82@beule>
References: <003201c63920$eb169420$acd4ed82@beule>
Message-ID: <200602241012.51794.tack@ps.uni-sb.de>

> No, the only way you currently can interrupt is in between requesting
> better solutions from the BAB engine. However this sounds like a useful
> (and reasonably simple) addition, even though it should be a user supplied
> stop criterion being more general than just time... But it should be very
> simple for you to hack something up by yourself and tell us...

Maybe a hint to get you started:
Have a look at search/bab-copy.cc or search/bab-reco.cc. Both contain a 
similar while(true) loop that does the main exploration. The easiest way to 
implement something like a timeout would be to use the failure count - just 
stop the search when it exceeds a certain limit. You must then return true 
and set s1 to NULL.

Cheers,
	Guido

-- 
Guido Tack
Programming Systems Lab, Saarland University, Germany
http://www.ps.uni-sb.de/~tack



From rafaparafernalia at gmail.com  Fri Feb 24 19:02:31 2006
From: rafaparafernalia at gmail.com (Rafael Meneses)
Date: Fri, 24 Feb 2006 15:02:31 -0300
Subject: [gecode-users] How control the engine??
In-Reply-To: <200602241012.51794.tack@ps.uni-sb.de>
References: <003201c63920$eb169420$acd4ed82@beule>
	<200602241012.51794.tack@ps.uni-sb.de>
Message-ID: <d701e0390602241002i3dddb59u9c451142bea14f49@mail.gmail.com>

On 2/24/06, Guido Tack <tack at ps.uni-sb.de> wrote:
> > No, the only way you currently can interrupt is in between requesting
> > better solutions from the BAB engine. However this sounds like a useful
> > (and reasonably simple) addition, even though it should be a user supplied
> > stop criterion being more general than just time... But it should be very
> > simple for you to hack something up by yourself and tell us...
>
> Maybe a hint to get you started:
> Have a look at search/bab-copy.cc or search/bab-reco.cc. Both contain a
> similar while(true) loop that does the main exploration. The easiest way to
> implement something like a timeout would be to use the failure count - just
> stop the search when it exceeds a certain limit. You must then return true
> and set s1 to NULL.
>

Thanks...

I finished the patch....

The patch includes an example, in the directory examples the file
golombTimeout.cc


Bye....


--
Rafael Meneses
http://www.labsd.inf.utfsm.cl/~rmeneses
-------------- next part --------------
A non-text attachment was scrubbed...
Name: gecode_1.0.0_parcheTimeout.patch
Type: text/x-patch
Size: 16771 bytes
Desc: not available
URL: <http://www.ps.uni-sb.de/pipermail/users/attachments/20060224/3d872f37/attachment.bin>

From schulte at imit.kth.se  Mon Feb 27 16:00:29 2006
From: schulte at imit.kth.se (Christian Schulte)
Date: Mon, 27 Feb 2006 16:00:29 +0100
Subject: [gecode-users] How control the engine??
In-Reply-To: <d701e0390602241002i3dddb59u9c451142bea14f49@mail.gmail.com>
Message-ID: <006201c63bae$8cb44310$acd4ed82@beule>

Hi, that's great. Some things can be done in a more elegant way maybe (maybe
using a virtual function and always pass an EndCondition object. this would
be less efficient but nicer).

We are currently preparing 1.0.1 where your patch will not go in. Then let's
see for 1.0.2.

Christian

--
Christian Schulte, http://www.imit.kth.se/~schulte/ 

-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Rafael Meneses
Sent: Friday, February 24, 2006 7:03 PM
To: users at gecode.org
Subject: Re: [gecode-users] How control the engine??


On 2/24/06, Guido Tack <tack at ps.uni-sb.de> wrote:
> > No, the only way you currently can interrupt is in between 
> > requesting better solutions from the BAB engine. However this sounds 
> > like a useful (and reasonably simple) addition, even though it 
> > should be a user supplied stop criterion being more general than 
> > just time... But it should be very simple for you to hack something 
> > up by yourself and tell us...
>
> Maybe a hint to get you started:
> Have a look at search/bab-copy.cc or search/bab-reco.cc. Both contain 
> a similar while(true) loop that does the main exploration. The easiest 
> way to implement something like a timeout would be to use the failure 
> count - just stop the search when it exceeds a certain limit. You must 
> then return true and set s1 to NULL.
>

Thanks...

I finished the patch....

The patch includes an example, in the directory examples the file
golombTimeout.cc


Bye....


--
Rafael Meneses
http://www.labsd.inf.utfsm.cl/~rmeneses




From ottenl at student.chalmers.se  Tue Feb 28 00:29:23 2006
From: ottenl at student.chalmers.se (Lars Otten)
Date: Mon, 27 Feb 2006 23:29:23 +0000
Subject: [gecode-users] Analysing search performance
Message-ID: <44038B53.90407@student.chalmers.se>

Hello everyone,

I've modeled the basic parts of the Tail Assignment Problem [1] in Gecode,
specifically by implementing two custom constraints inverse(x,y) and
tunneling(x,y,z) -- x,y,z being variable arrays of the same length.

I also have access to some of the example instances the author of [1] used
and have tried them on my self-extended Gecode. Unfortunately the running
times for finding a single solution is orders of magnitude worse than what
was accomplished in [1]. The original system is admittedly hand-tailored to
the problem, but then again I've only implemented the basic model, which
lacks some of the more complicated custom constraints the solution in [1]
takes into account.

Hence I'd like to make some kind of analysis of where the depth first search
in Gecode spends it time, to find potential bottlenecks. For a start it
would e.g. be nice to see how much time is spent propagating my custom
constraints (or all constraints in general).

Is there any way to do this in Gecode? I realize this might also be a more
general C++ question, in this case I'd appreciate any pointers on where to
look for more info...

Thanks in advance,
/Lars


[1] http://publications.lib.chalmers.se/records/full_record/6207.html



From tack at ps.uni-sb.de  Tue Feb 28 09:06:54 2006
From: tack at ps.uni-sb.de (Guido Tack)
Date: Tue, 28 Feb 2006 09:06:54 +0100
Subject: [gecode-users] Analysing search performance
In-Reply-To: <44038B53.90407@student.chalmers.se>
References: <44038B53.90407@student.chalmers.se>
Message-ID: <200602280906.54486.tack@ps.uni-sb.de>

Hi Lars.

> Hence I'd like to make some kind of analysis of where the depth first
> search in Gecode spends it time, to find potential bottlenecks. For a start
> it would e.g. be nice to see how much time is spent propagating my custom
> constraints (or all constraints in general).
>
> Is there any way to do this in Gecode? I realize this might also be a more
> general C++ question, in this case I'd appreciate any pointers on where to
> look for more info...

The first thing you could try is profiling using gprof. Simply compile Gecode 
using the --enable-profile configure switch (I hope it still works, I haven't 
tested it in a while). Then you simply run your sample program, which will 
result in a file gmon.out. For analysis, you may want to try graphical 
frontends to gprof such as kprof (http://kprof.sourceforge.net/).

If this doesn't help you find the bottleneck, you will have to write some 
profiling code by hand; we haven't built anything into the system yet. I'd 
probably start by instrumenting the propagation loop (e.g. in Space::status 
in file core.cc), and then move to individual propagators.

Cheers,
	Guido

-- 
Guido Tack
Programming Systems Lab, Saarland University, Germany
http://www.ps.uni-sb.de/~tack



From schulte at imit.kth.se  Tue Feb 28 10:01:02 2006
From: schulte at imit.kth.se (Christian Schulte)
Date: Tue, 28 Feb 2006 10:01:02 +0100
Subject: [gecode-users] Analysing search performance
In-Reply-To: <44038B53.90407@student.chalmers.se>
Message-ID: <006d01c63c45$803f9b60$acd4ed82@beule>

For the time being, the only support you can get is by using a standard C++
profiler. If you are using gcc for compiling just use gprof the see what is
happening. In order to compiler for gprog you have to give -pg as option for
gcc (just check the gcc doc).

Did you at least check the search space? That is, how big is the search tree
with what you have and how big is that in [1]. If you are talking vastly
different trees there is no point in alayzing performance but your model.

Cheers
Christian

--
Christian Schulte, http://www.imit.kth.se/~schulte/ 

-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Lars Otten
Sent: Tuesday, February 28, 2006 12:29 AM
To: users at gecode.org
Subject: [gecode-users] Analysing search performance


Hello everyone,

I've modeled the basic parts of the Tail Assignment Problem [1] in Gecode,
specifically by implementing two custom constraints inverse(x,y) and
tunneling(x,y,z) -- x,y,z being variable arrays of the same length.

I also have access to some of the example instances the author of [1] used
and have tried them on my self-extended Gecode. Unfortunately the running
times for finding a single solution is orders of magnitude worse than what
was accomplished in [1]. The original system is admittedly hand-tailored to
the problem, but then again I've only implemented the basic model, which
lacks some of the more complicated custom constraints the solution in [1]
takes into account.

Hence I'd like to make some kind of analysis of where the depth first search
in Gecode spends it time, to find potential bottlenecks. For a start it
would e.g. be nice to see how much time is spent propagating my custom
constraints (or all constraints in general).

Is there any way to do this in Gecode? I realize this might also be a more
general C++ question, in this case I'd appreciate any pointers on where to
look for more info...

Thanks in advance,
/Lars


[1] http://publications.lib.chalmers.se/records/full_record/6207.html

_______________________________________________
Gecode users mailing list
users at gecode.org https://www.gecode.org/mailman/listinfo/gecode-users




From osivertsson at gmail.com  Tue Feb 28 16:15:42 2006
From: osivertsson at gmail.com (Olof Sivertsson)
Date: Tue, 28 Feb 2006 16:15:42 +0100
Subject: [gecode-users] Slight modification of examples/money.cc that
	reveals a bug
Message-ID: <1c8b4aa60602280715v101df406ybe3985c801e3b86a@mail.gmail.com>

Hello,

I think I've stumbled across a bug that is quite easy to reproduce by doing
a slight modification of examples/money.cc.

Without modification running examples/money will print:
 9 5 6 7 1 0 8 2
which is the values of the letters in the array [s,e,n,d,m,o,r,y].

Now let's force s = 9 by adding the following to Money(const Options& opt)
 post(this, s == 9);

Recompile & rerun:
> make compileexamples
> examples/money
...
 9 5 6 7 1 0 8 2

No change - it works like it should. But now let's do a small change, and
instead post the following constraint:
 post(this, 9 == s);

If we recompile and rerun it now we get no solution, so somethings broken. I
bet it's a sign error since if we change it to:
 post(this, -9 == s);
it works!

Hopefully this will lead you straight to the bug and a trivial fix.

Cheers,
Olof
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.ps.uni-sb.de/pipermail/users/attachments/20060228/59250226/attachment.htm>

From tack at ps.uni-sb.de  Tue Feb 28 17:47:59 2006
From: tack at ps.uni-sb.de (Guido Tack)
Date: Tue, 28 Feb 2006 17:47:59 +0100
Subject: [gecode-users] Slight modification of examples/money.cc that
	reveals a bug
In-Reply-To: <1c8b4aa60602280715v101df406ybe3985c801e3b86a@mail.gmail.com>
References: <1c8b4aa60602280715v101df406ybe3985c801e3b86a@mail.gmail.com>
Message-ID: <200602281747.59627.tack@ps.uni-sb.de>

Hi.

> I think I've stumbled across a bug that is quite easy to reproduce by doing
> a slight modification of examples/money.cc.
> [...]
> No change - it works like it should. But now let's do a small change, and
> instead post the following constraint:
>  post(this, 9 == s);
>
> If we recompile and rerun it now we get no solution, so somethings broken.
> I bet it's a sign error since if we change it to:
>  post(this, -9 == s);
> it works!

Thanks a lot! The bug was really easy to find and fix thanks to your excellent 
bug report. It seems we have never tested writing ints on the left-hand side 
of an equation. Yet another fix for the 1.0.1 release!

Cheers,
	Guido

-- 
Guido Tack
Programming Systems Lab, Saarland University, Germany
http://www.ps.uni-sb.de/~tack



