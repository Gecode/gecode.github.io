<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [gecode-users] Starting with C++
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:users%40gecode.org?Subject=Re%3A%20%5Bgecode-users%5D%20Starting%20with%20C%2B%2B&In-Reply-To=%3C400BE4F8-E440-427B-B61E-5464638318A9%40cse.unsw.edu.au%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002001.html">
   <LINK REL="Next"  HREF="002005.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[gecode-users] Starting with C++</H1>
    <B>Malcolm Ryan</B> 
    <A HREF="mailto:users%40gecode.org?Subject=Re%3A%20%5Bgecode-users%5D%20Starting%20with%20C%2B%2B&In-Reply-To=%3C400BE4F8-E440-427B-B61E-5464638318A9%40cse.unsw.edu.au%3E"
       TITLE="[gecode-users] Starting with C++">malcolmr at cse.unsw.edu.au
       </A><BR>
    <I>Wed Nov 19 05:06:27 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="002001.html">[gecode-users] Parallel search in Gecode
</A></li>
        <LI>Next message: <A HREF="002005.html">[gecode-users] Starting with C++
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2002">[ date ]</a>
              <a href="thread.html#2002">[ thread ]</a>
              <a href="subject.html#2002">[ subject ]</a>
              <a href="author.html#2002">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Given that GecodeJ is no longer supported, I'm in the process of  
migrating my code to C++ (and learning C++ in the process).

It seems from my perusal of the examples that the C++ library works  
slightly differently. Whereas in java the copy constructors for spaces  
look like:

   public Queens(Boolean share, Queens queens) {
     super(share, queens);
     n = queens.n;
     q = new VarArray&lt;IntVar&gt;(this, share, queens.q);
   }

in C++ they look like:

   /// Constructor for cloning \a s
   Queens(bool share, Queens&amp; s) : Example(share,s) {
     q.update(this, share, s.q);
   }

The Java code explicitly contructs a new var array from the old. The C+ 
+ code seems to implicitly construct an empty var array and then call  
'update' to copy the old into the new. Is that correct? Does every  
kind of variable have an no-arg constructor? What is the rationale for  
this choice? It seems that it allows you to construct variables in an  
incompletely initialised state. Is that deliberate?

Malcolm


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002001.html">[gecode-users] Parallel search in Gecode
</A></li>
	<LI>Next message: <A HREF="002005.html">[gecode-users] Starting with C++
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2002">[ date ]</a>
              <a href="thread.html#2002">[ thread ]</a>
              <a href="subject.html#2002">[ subject ]</a>
              <a href="author.html#2002">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://www.ps.uni-sb.de/mailman/listinfo/users">More information about the gecode-users
mailing list</a><br>
</body></html>
