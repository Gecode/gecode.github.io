From Vincent.Barichard at univ-angers.fr  Tue Dec  1 16:14:57 2009
From: Vincent.Barichard at univ-angers.fr (Vincent Barichard)
Date: Tue, 1 Dec 2009 16:14:57 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <007c01ca71d2$b7adec20$2709c460$@se>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
Message-ID: <EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>

Dear Christian,

Thank you very much for your mail. I'm sorry, I don't understand your  
answer. Why having other BoolView classes will
help me ? I added member functions in the BoolViews classes. I didn't  
change the existing ones,
I only added member functions which notify the ME_BOOL_SAME event.

In my own propagator (let's call it M) I call the recently added  
functions in the BoolViews. So the ME_BOOL_SAME
event is sent.

I also modified one propagator of Gecode (let's call it P') and make  
it subscribe to the PC_BOOL_SAME propagation condition (I only added  
"x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
In the "propagate" function of P' I added instructions which are only  
relevant if a ME_BOOL_SAME event has been sent before.

So when M is woke up (because it subscribe to PC_BOOL_VAL propagation  
condition) it may call the new member functions in the BoolViews  
classes which sent the ME_BOOL_SAME event. I would like that  
propagators which subscribe to the PC_BOOL_SAME propagation condition  
and only these ones, be scheduled to wake up (for example P' will be  
scheduled if it shares a variable with M). As no assignment has been  
made by the M propagator, I don't want that other propagators wake up  
except if a ME_BOOL_VAL event has been sent from elsewhere.

Unfortunately, as all propagation condition subscribings for Boleans  
variables are remapped to PC_BOOL_VAL, P' will not awake if a  
ME_BOOL_SAME event is sent.

May have I another choice but to use the ME_BOOL_VAL event instead of  
ME_BOOL_SAME in my new member functions of the BoolView classes ? As a  
result, all propagators will be awaken even if they can't propagate  
removal, indeed no assignment has been made.

Don't hesitate to ask me if I'm not clear enough.

Cheers,
Vincent

Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :

> Actually what you have to do is the following: you define two  
> classes for
> Boolean views, one that rewrites its propagation conditions and the  
> other
> one that does not. Then your propagators can use the views without  
> rewriting
> while the other propagators can use the variables with rewriting.
>
> Christian
>
> --
> Christian Schulte, www.ict.kth.se/~cschulte/
>
>
> -----Original Message-----
> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On  
> Behalf
> Of Vincent Barichard
> Sent: Monday, November 30, 2009 9:33 AM
> To: Christian Schulte
> Cc: 'Guido Tack'; 'gecode list'
> Subject: Re: [gecode-users] Remapping of BoolVar propagation  
> conditions
>
> Hi,
>
> Thank you both for your answers. As I don't want to break all  
> propagators
> that are used for integer as well as boolean variables, I see no  
> choice but
> to use PC_BOOL_VAL.
>
> Maybe one of you may see another way ? I make new functions on Boolean
> variables (and associated views) which don't set domain to 1 or 0 (I  
> copied
> "ModEvent  BoolVarImp::one_none(Space& home)" and removed the unwanted
> instructions). These functions notify new events (called  
> ME_BOOL_SAME in
> bool.vis file (see attached file)). I mapped this new event to the
> PC_BOOL_SAME propagation condition.
>
> Now I change an existing propagator (like the "Or" propagator), and  
> I want
> it to be awaken when ME_BOOL_SAME is emitted. As the variable is not  
> yet
> assigned, I didn't want to emit the ME_BOOL_VAL event because I  
> didn't want
> to wake up propagators which only subscribed to the PC_BOOL_VAL  
> condition.
>
> So during propagation, I call my new functions on Boolean variables,  
> the
> ME_BOOL_SAME event is sent and propagators which subscribe to the
> PC_BOOL_SAME condition are wake up. Other propagators are not awaken  
> (except
> if a ME_BOOL_VAL event has also been sent). Is it possible ?
> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators  
> will be
> awaken for nothing.
>
> Thanks for your help.
>
> Cheers,
> Vincent

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203



From tack at ps.uni-sb.de  Tue Dec  1 16:33:54 2009
From: tack at ps.uni-sb.de (Guido Tack)
Date: Tue, 1 Dec 2009 16:33:54 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>
	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>
	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
	<EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
Message-ID: <1f82f3260912010733q77a5c743vfd6cc23a5b6cd314@mail.gmail.com>

Hi Vincent,

the rewriting is currently done in int/var-imp/bool.hpp.  Just remove
the rewriting there and pass the pc unchanged, add rewriting to all
the normal Gecode BoolView classes, and then add your own BoolView
class that doesn't rewrite.

Cheers,
	Guido

On Tue, Dec 1, 2009 at 4:14 PM, Vincent Barichard
<Vincent.Barichard at univ-angers.fr> wrote:
> Dear Christian,
>
> Thank you very much for your mail. I'm sorry, I don't understand your
> answer. Why having other BoolView classes will
> help me ? I added member functions in the BoolViews classes. I didn't change
> the existing ones,
> I only added member functions which notify the ME_BOOL_SAME event.
>
> In my own propagator (let's call it M) I call the recently added functions
> in the BoolViews. So the ME_BOOL_SAME
> event is sent.
>
> I also modified one propagator of Gecode (let's call it P') and make it
> subscribe to the PC_BOOL_SAME propagation condition (I only added
> "x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
> In the "propagate" function of P' I added instructions which are only
> relevant if a ME_BOOL_SAME event has been sent before.
>
> So when M is woke up (because it subscribe to PC_BOOL_VAL propagation
> condition) it may call the new member functions in the BoolViews classes
> which sent the ME_BOOL_SAME event. I would like that propagators which
> subscribe to the PC_BOOL_SAME propagation condition and only these ones, be
> scheduled to wake up (for example P' will be scheduled if it shares a
> variable with M). As no assignment has been made by the M propagator, I
> don't want that other propagators wake up except if a ME_BOOL_VAL event has
> been sent from elsewhere.
>
> Unfortunately, as all propagation condition subscribings for Boleans
> variables are remapped to PC_BOOL_VAL, P' will not awake if a ME_BOOL_SAME
> event is sent.
>
> May have I another choice but to use the ME_BOOL_VAL event instead of
> ME_BOOL_SAME in my new member functions of the BoolView classes ? As a
> result, all propagators will be awaken even if they can't propagate removal,
> indeed no assignment has been made.
>
> Don't hesitate to ask me if I'm not clear enough.
>
> Cheers,
> Vincent
>
> Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :
>
>> Actually what you have to do is the following: you define two classes for
>> Boolean views, one that rewrites its propagation conditions and the other
>> one that does not. Then your propagators can use the views without
>> rewriting
>> while the other propagators can use the variables with rewriting.
>>
>> Christian
>>
>> --
>> Christian Schulte, www.ict.kth.se/~cschulte/
>>
>>
>> -----Original Message-----
>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
>> Of Vincent Barichard
>> Sent: Monday, November 30, 2009 9:33 AM
>> To: Christian Schulte
>> Cc: 'Guido Tack'; 'gecode list'
>> Subject: Re: [gecode-users] Remapping of BoolVar propagation conditions
>>
>> Hi,
>>
>> Thank you both for your answers. As I don't want to break all propagators
>> that are used for integer as well as boolean variables, I see no choice
>> but
>> to use PC_BOOL_VAL.
>>
>> Maybe one of you may see another way ? I make new functions on Boolean
>> variables (and associated views) which don't set domain to 1 or 0 (I
>> copied
>> "ModEvent ?BoolVarImp::one_none(Space& home)" and removed the unwanted
>> instructions). These functions notify new events (called ME_BOOL_SAME in
>> bool.vis file (see attached file)). I mapped this new event to the
>> PC_BOOL_SAME propagation condition.
>>
>> Now I change an existing propagator (like the "Or" propagator), and I want
>> it to be awaken when ME_BOOL_SAME is emitted. As the variable is not yet
>> assigned, I didn't want to emit the ME_BOOL_VAL event because I didn't
>> want
>> to wake up propagators which only subscribed to the PC_BOOL_VAL condition.
>>
>> So during propagation, I call my new functions on Boolean variables, the
>> ME_BOOL_SAME event is sent and propagators which subscribe to the
>> PC_BOOL_SAME condition are wake up. Other propagators are not awaken
>> (except
>> if a ME_BOOL_VAL event has also been sent). Is it possible ?
>> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators will be
>> awaken for nothing.
>>
>> Thanks for your help.
>>
>> Cheers,
>> Vincent
>
> Vincent Barichard ? ? ? ? Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06 ? ? ?D?partement Informatique
> Fax: 02 41 73 50 73 ? ? H203
>
>


From cschulte at kth.se  Tue Dec  1 16:36:54 2009
From: cschulte at kth.se (Christian Schulte)
Date: Tue, 1 Dec 2009 16:36:54 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>
	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>
	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
	<EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
	<FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
Message-ID: <000001ca729c$1c530d30$54f92790$@se>

Yep, that's right. Sorry, I forgot that the rewriting is done in the
implementation and not in the views!

Christian

-----Original Message-----
From: Guido Tack [mailto:tack at ps.uni-sb.de] 
Sent: Tuesday, December 01, 2009 4:31 PM
To: Vincent Barichard
Cc: Christian Schulte; 'gecode list'
Subject: Re: [gecode-users] Remapping of BoolVar propagation conditions

Hi Vincent,

the rewriting is currently done in int/var-imp/bool.hpp.  Just remove the
rewriting there and pass the pc unchanged, add rewriting to all the normal
Gecode BoolView classes, and then add your own BoolView class that doesn't
rewrite.

Cheers,
	Guido

Vincent Barichard wrote:

> Dear Christian,
> 
> Thank you very much for your mail. I'm sorry, I don't understand your
answer. Why having other BoolView classes will
> help me ? I added member functions in the BoolViews classes. I didn't
change the existing ones,
> I only added member functions which notify the ME_BOOL_SAME event.
> 
> In my own propagator (let's call it M) I call the recently added functions
in the BoolViews. So the ME_BOOL_SAME
> event is sent.
> 
> I also modified one propagator of Gecode (let's call it P') and make it
subscribe to the PC_BOOL_SAME propagation condition (I only added
"x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
> In the "propagate" function of P' I added instructions which are only
relevant if a ME_BOOL_SAME event has been sent before.
> 
> So when M is woke up (because it subscribe to PC_BOOL_VAL propagation
condition) it may call the new member functions in the BoolViews classes
which sent the ME_BOOL_SAME event. I would like that propagators which
subscribe to the PC_BOOL_SAME propagation condition and only these ones, be
scheduled to wake up (for example P' will be scheduled if it shares a
variable with M). As no assignment has been made by the M propagator, I
don't want that other propagators wake up except if a ME_BOOL_VAL event has
been sent from elsewhere.
> 
> Unfortunately, as all propagation condition subscribings for Boleans
variables are remapped to PC_BOOL_VAL, P' will not awake if a ME_BOOL_SAME
event is sent.
> 
> May have I another choice but to use the ME_BOOL_VAL event instead of
ME_BOOL_SAME in my new member functions of the BoolView classes ? As a
result, all propagators will be awaken even if they can't propagate removal,
indeed no assignment has been made.

> 
> Don't hesitate to ask me if I'm not clear enough.
> 
> Cheers,
> Vincent
> 
> Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :
> 
>> Actually what you have to do is the following: you define two classes for
>> Boolean views, one that rewrites its propagation conditions and the other
>> one that does not. Then your propagators can use the views without
rewriting
>> while the other propagators can use the variables with rewriting.
>> 
>> Christian
>> 
>> --
>> Christian Schulte, www.ict.kth.se/~cschulte/
>> 
>> 
>> -----Original Message-----
>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On
Behalf
>> Of Vincent Barichard
>> Sent: Monday, November 30, 2009 9:33 AM
>> To: Christian Schulte
>> Cc: 'Guido Tack'; 'gecode list'
>> Subject: Re: [gecode-users] Remapping of BoolVar propagation conditions
>> 
>> Hi,
>> 
>> Thank you both for your answers. As I don't want to break all propagators
>> that are used for integer as well as boolean variables, I see no choice
but
>> to use PC_BOOL_VAL.
>> 
>> Maybe one of you may see another way ? I make new functions on Boolean
>> variables (and associated views) which don't set domain to 1 or 0 (I
copied
>> "ModEvent  BoolVarImp::one_none(Space& home)" and removed the unwanted
>> instructions). These functions notify new events (called ME_BOOL_SAME in
>> bool.vis file (see attached file)). I mapped this new event to the
>> PC_BOOL_SAME propagation condition.
>> 
>> Now I change an existing propagator (like the "Or" propagator), and I
want
>> it to be awaken when ME_BOOL_SAME is emitted. As the variable is not yet
>> assigned, I didn't want to emit the ME_BOOL_VAL event because I didn't
want
>> to wake up propagators which only subscribed to the PC_BOOL_VAL
condition.
>> 
>> So during propagation, I call my new functions on Boolean variables, the
>> ME_BOOL_SAME event is sent and propagators which subscribe to the
>> PC_BOOL_SAME condition are wake up. Other propagators are not awaken
(except
>> if a ME_BOOL_VAL event has also been sent). Is it possible ?
>> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators will be
>> awaken for nothing.
>> 
>> Thanks for your help.
>> 
>> Cheers,
>> Vincent
> 
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
> 




From Vincent.Barichard at univ-angers.fr  Tue Dec  1 18:21:37 2009
From: Vincent.Barichard at univ-angers.fr (Vincent Barichard)
Date: Tue, 1 Dec 2009 18:21:37 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>
	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>
	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
	<EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
	<FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
Message-ID: <FCD7C211-D379-4B87-9B3D-6065D935129F@univ-angers.fr>

Hi Guido,

That was my first thought. But I didn't understand why this remapping  
was there. Christian said in a previous mail that removing the mapping  
will break all propagators that are used for integer as well as for  
boolean variables! If I pass the pc unchanged, will it break something  
in Gecode ? I don't want to break something, I would like to add  
safely my piece of code.

If removing it doesn't break anything, will this mapping be still  
there in the future versions ?

Thank you again, I really appreciate the time you spent to answer my  
questions :)

Cheers,
Vincent

Le 1 d?c. 09 ? 16:30, Guido Tack a ?crit :

> Hi Vincent,
>
> the rewriting is currently done in int/var-imp/bool.hpp.  Just  
> remove the rewriting there and pass the pc unchanged, add rewriting  
> to all the normal Gecode BoolView classes, and then add your own  
> BoolView class that doesn't rewrite.
>
> Cheers,
> 	Guido
>
> Vincent Barichard wrote:
>
>> Dear Christian,
>>
>> Thank you very much for your mail. I'm sorry, I don't understand  
>> your answer. Why having other BoolView classes will
>> help me ? I added member functions in the BoolViews classes. I  
>> didn't change the existing ones,
>> I only added member functions which notify the ME_BOOL_SAME event.
>>
>> In my own propagator (let's call it M) I call the recently added  
>> functions in the BoolViews. So the ME_BOOL_SAME
>> event is sent.
>>
>> I also modified one propagator of Gecode (let's call it P') and  
>> make it subscribe to the PC_BOOL_SAME propagation condition (I only  
>> added "x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
>> In the "propagate" function of P' I added instructions which are  
>> only relevant if a ME_BOOL_SAME event has been sent before.
>>
>> So when M is woke up (because it subscribe to PC_BOOL_VAL  
>> propagation condition) it may call the new member functions in the  
>> BoolViews classes which sent the ME_BOOL_SAME event. I would like  
>> that propagators which subscribe to the PC_BOOL_SAME propagation  
>> condition and only these ones, be scheduled to wake up (for example  
>> P' will be scheduled if it shares a variable with M). As no  
>> assignment has been made by the M propagator, I don't want that  
>> other propagators wake up except if a ME_BOOL_VAL event has been  
>> sent from elsewhere.
>>
>> Unfortunately, as all propagation condition subscribings for  
>> Boleans variables are remapped to PC_BOOL_VAL, P' will not awake if  
>> a ME_BOOL_SAME event is sent.
>>
>> May have I another choice but to use the ME_BOOL_VAL event instead  
>> of ME_BOOL_SAME in my new member functions of the BoolView  
>> classes ? As a result, all propagators will be awaken even if they  
>> can't propagate removal, indeed no assignment has been made.
>>
>> Don't hesitate to ask me if I'm not clear enough.
>>
>> Cheers,
>> Vincent
>>
>> Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :
>>
>>> Actually what you have to do is the following: you define two  
>>> classes for
>>> Boolean views, one that rewrites its propagation conditions and  
>>> the other
>>> one that does not. Then your propagators can use the views without  
>>> rewriting
>>> while the other propagators can use the variables with rewriting.
>>>
>>> Christian
>>>
>>> --
>>> Christian Schulte, www.ict.kth.se/~cschulte/
>>>
>>>
>>> -----Original Message-----
>>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org]  
>>> On Behalf
>>> Of Vincent Barichard
>>> Sent: Monday, November 30, 2009 9:33 AM
>>> To: Christian Schulte
>>> Cc: 'Guido Tack'; 'gecode list'
>>> Subject: Re: [gecode-users] Remapping of BoolVar propagation  
>>> conditions
>>>
>>> Hi,
>>>
>>> Thank you both for your answers. As I don't want to break all  
>>> propagators
>>> that are used for integer as well as boolean variables, I see no  
>>> choice but
>>> to use PC_BOOL_VAL.
>>>
>>> Maybe one of you may see another way ? I make new functions on  
>>> Boolean
>>> variables (and associated views) which don't set domain to 1 or 0  
>>> (I copied
>>> "ModEvent  BoolVarImp::one_none(Space& home)" and removed the  
>>> unwanted
>>> instructions). These functions notify new events (called  
>>> ME_BOOL_SAME in
>>> bool.vis file (see attached file)). I mapped this new event to the
>>> PC_BOOL_SAME propagation condition.
>>>
>>> Now I change an existing propagator (like the "Or" propagator),  
>>> and I want
>>> it to be awaken when ME_BOOL_SAME is emitted. As the variable is  
>>> not yet
>>> assigned, I didn't want to emit the ME_BOOL_VAL event because I  
>>> didn't want
>>> to wake up propagators which only subscribed to the PC_BOOL_VAL  
>>> condition.
>>>
>>> So during propagation, I call my new functions on Boolean  
>>> variables, the
>>> ME_BOOL_SAME event is sent and propagators which subscribe to the
>>> PC_BOOL_SAME condition are wake up. Other propagators are not  
>>> awaken (except
>>> if a ME_BOOL_VAL event has also been sent). Is it possible ?
>>> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators  
>>> will be
>>> awaken for nothing.
>>>
>>> Thanks for your help.
>>>
>>> Cheers,
>>> Vincent
>>
>> Vincent Barichard         Universit? d'Angers (LERIA)
>> Tel: 02 41 73 52 06      D?partement Informatique
>> Fax: 02 41 73 50 73     H203
>>

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203



From cschulte at kth.se  Tue Dec  1 19:26:16 2009
From: cschulte at kth.se (Christian Schulte)
Date: Tue, 1 Dec 2009 19:26:16 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <FCD7C211-D379-4B87-9B3D-6065D935129F@univ-angers.fr>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>
	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>
	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
	<EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
	<FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
	<FCD7C211-D379-4B87-9B3D-6065D935129F@univ-angers.fr>
Message-ID: <002a01ca72b3$c59c0790$50d416b0$@se>

Actually, what Guido and me tried to say is the following: conceptually,
Gecode should have two Boolean views, say BoolView and BoolAsAnIntView. The
former does not need rewriting and most propagators using Boolean views
should use this one. The latter must use rewriting to map integer
propagation conditions to the single supported Boolean propagation
condition.

Then there are integer propagators which we also want to use on Boolean
views (these are few: the extensional ones, including element and sequence).
These propagators should use BoolAsAnIntView including rewriting. All other
- true Boolean propagators should use the real BoolView.

So what you might want to do is to have these two different views, one with
and one without rewriting! Everything will work just fine.

Christian

-----Original Message-----
From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr] 
Sent: Tuesday, December 01, 2009 6:22 PM
To: Guido Tack
Cc: Christian Schulte; 'gecode list'
Subject: Re: [gecode-users] Remapping of BoolVar propagation conditions

Hi Guido,

That was my first thought. But I didn't understand why this remapping  
was there. Christian said in a previous mail that removing the mapping  
will break all propagators that are used for integer as well as for  
boolean variables! If I pass the pc unchanged, will it break something  
in Gecode ? I don't want to break something, I would like to add  
safely my piece of code.

If removing it doesn't break anything, will this mapping be still  
there in the future versions ?

Thank you again, I really appreciate the time you spent to answer my  
questions :)

Cheers,
Vincent

Le 1 d?c. 09 ? 16:30, Guido Tack a ?crit :

> Hi Vincent,
>
> the rewriting is currently done in int/var-imp/bool.hpp.  Just  
> remove the rewriting there and pass the pc unchanged, add rewriting  
> to all the normal Gecode BoolView classes, and then add your own  
> BoolView class that doesn't rewrite.
>
> Cheers,
> 	Guido
>
> Vincent Barichard wrote:
>
>> Dear Christian,
>>
>> Thank you very much for your mail. I'm sorry, I don't understand  
>> your answer. Why having other BoolView classes will
>> help me ? I added member functions in the BoolViews classes. I  
>> didn't change the existing ones,
>> I only added member functions which notify the ME_BOOL_SAME event.
>>
>> In my own propagator (let's call it M) I call the recently added  
>> functions in the BoolViews. So the ME_BOOL_SAME
>> event is sent.
>>
>> I also modified one propagator of Gecode (let's call it P') and  
>> make it subscribe to the PC_BOOL_SAME propagation condition (I only  
>> added "x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
>> In the "propagate" function of P' I added instructions which are  
>> only relevant if a ME_BOOL_SAME event has been sent before.
>>
>> So when M is woke up (because it subscribe to PC_BOOL_VAL  
>> propagation condition) it may call the new member functions in the  
>> BoolViews classes which sent the ME_BOOL_SAME event. I would like  
>> that propagators which subscribe to the PC_BOOL_SAME propagation  
>> condition and only these ones, be scheduled to wake up (for example  
>> P' will be scheduled if it shares a variable with M). As no  
>> assignment has been made by the M propagator, I don't want that  
>> other propagators wake up except if a ME_BOOL_VAL event has been  
>> sent from elsewhere.
>>
>> Unfortunately, as all propagation condition subscribings for  
>> Boleans variables are remapped to PC_BOOL_VAL, P' will not awake if  
>> a ME_BOOL_SAME event is sent.
>>
>> May have I another choice but to use the ME_BOOL_VAL event instead  
>> of ME_BOOL_SAME in my new member functions of the BoolView  
>> classes ? As a result, all propagators will be awaken even if they  
>> can't propagate removal, indeed no assignment has been made.
>>
>> Don't hesitate to ask me if I'm not clear enough.
>>
>> Cheers,
>> Vincent
>>
>> Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :
>>
>>> Actually what you have to do is the following: you define two  
>>> classes for
>>> Boolean views, one that rewrites its propagation conditions and  
>>> the other
>>> one that does not. Then your propagators can use the views without  
>>> rewriting
>>> while the other propagators can use the variables with rewriting.
>>>
>>> Christian
>>>
>>> --
>>> Christian Schulte, www.ict.kth.se/~cschulte/
>>>
>>>
>>> -----Original Message-----
>>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org]  
>>> On Behalf
>>> Of Vincent Barichard
>>> Sent: Monday, November 30, 2009 9:33 AM
>>> To: Christian Schulte
>>> Cc: 'Guido Tack'; 'gecode list'
>>> Subject: Re: [gecode-users] Remapping of BoolVar propagation  
>>> conditions
>>>
>>> Hi,
>>>
>>> Thank you both for your answers. As I don't want to break all  
>>> propagators
>>> that are used for integer as well as boolean variables, I see no  
>>> choice but
>>> to use PC_BOOL_VAL.
>>>
>>> Maybe one of you may see another way ? I make new functions on  
>>> Boolean
>>> variables (and associated views) which don't set domain to 1 or 0  
>>> (I copied
>>> "ModEvent  BoolVarImp::one_none(Space& home)" and removed the  
>>> unwanted
>>> instructions). These functions notify new events (called  
>>> ME_BOOL_SAME in
>>> bool.vis file (see attached file)). I mapped this new event to the
>>> PC_BOOL_SAME propagation condition.
>>>
>>> Now I change an existing propagator (like the "Or" propagator),  
>>> and I want
>>> it to be awaken when ME_BOOL_SAME is emitted. As the variable is  
>>> not yet
>>> assigned, I didn't want to emit the ME_BOOL_VAL event because I  
>>> didn't want
>>> to wake up propagators which only subscribed to the PC_BOOL_VAL  
>>> condition.
>>>
>>> So during propagation, I call my new functions on Boolean  
>>> variables, the
>>> ME_BOOL_SAME event is sent and propagators which subscribe to the
>>> PC_BOOL_SAME condition are wake up. Other propagators are not  
>>> awaken (except
>>> if a ME_BOOL_VAL event has also been sent). Is it possible ?
>>> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators  
>>> will be
>>> awaken for nothing.
>>>
>>> Thanks for your help.
>>>
>>> Cheers,
>>> Vincent
>>
>> Vincent Barichard         Universit? d'Angers (LERIA)
>> Tel: 02 41 73 52 06      D?partement Informatique
>> Fax: 02 41 73 50 73     H203
>>

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203




From Vincent.Barichard at univ-angers.fr  Wed Dec  2 14:45:08 2009
From: Vincent.Barichard at univ-angers.fr (Vincent Barichard)
Date: Wed, 2 Dec 2009 14:45:08 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <002a01ca72b3$c59c0790$50d416b0$@se>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>
	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>
	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
	<EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
	<FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
	<FCD7C211-D379-4B87-9B3D-6065D935129F@univ-angers.fr>
	<002a01ca72b3$c59c0790$50d416b0$@se>
Message-ID: <B8B85CA0-D2B4-45A2-A34D-A9E81BB37D24@univ-angers.fr>

Hi,

Ok, if I understood all answers, the remapping is only meaningful for  
propagators which use boolean variables and integer variables. As they  
can't distinguish boolean variables from integer ones, the propagation  
conditions are remapped in the first case.

If the propagators might distinguish boolean variables from integer  
variables, and use the correct propagation condition in each case, the  
remapped will be useless.

If I modify the ViewVarImpTraits and the constructors of propagators  
in the following way, will all existing propagators of Gecode work as  
usual ? In that case I will be able to add a new PC_BOOL_SAME  
condition without breaking anything.

In gecode/int/view.hpp, I change all ViewVarImpTraits classes:

Those which are over booleans,

   template<>
   class ViewVarImpTraits<Int::IntView> {
   public:
     /// The variable type of an IntView
     typedef Int::IntVarImp VarImp;
     static const bool isBool = false;
   };

Those which deal with booleans,

   template<>
   class ViewVarImpTraits<Int::BoolView> {
   public:
     /// The variable type of a BoolView
     typedef Int::BoolVarImp VarImp;
     static const bool isBool = true;
   };


and in propagator constructors (for example in gecode/int/element/ 
int.hpp) replace calls to :

x0.subscribe(home,*this,PC_INT_DOM);

by

x0.subscribe(home,*this,(Gecode::ViewVarImpTraits<V0>::isBool)? 
PC_BOOL_VAL:PC_INT_DOM);

After, in the file gecode/int/var-imp/bool.hpp :

   forceinline void
   BoolVarImp::subscribe(Space& home, Propagator& p, PropCond,
                         bool process) {
     // Subscription can be used with integer propagation conditions,
     // which must be remapped to the single Boolean propagation  
condition.
     BoolVarImpBase::subscribe(home,p,PC_BOOL_VAL,assigned(),process);
   }

can be replaced by

   forceinline void
   BoolVarImp::subscribe(Space& home, Propagator& p, PropCond pc,
                         bool process) {
     BoolVarImpBase::subscribe(home,p,pc,assigned(),process);
   }

(the same for the cancel member function)

and everything should work as usual.
Am I right ?

Cheers,
Vincent


Le 1 d?c. 09 ? 19:26, Christian Schulte a ?crit :

> Actually, what Guido and me tried to say is the following:  
> conceptually,
> Gecode should have two Boolean views, say BoolView and  
> BoolAsAnIntView. The
> former does not need rewriting and most propagators using Boolean  
> views
> should use this one. The latter must use rewriting to map integer
> propagation conditions to the single supported Boolean propagation
> condition.
>
> Then there are integer propagators which we also want to use on  
> Boolean
> views (these are few: the extensional ones, including element and  
> sequence).
> These propagators should use BoolAsAnIntView including rewriting.  
> All other
> - true Boolean propagators should use the real BoolView.
>
> So what you might want to do is to have these two different views,  
> one with
> and one without rewriting! Everything will work just fine.
>
> Christian
>
> -----Original Message-----
> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr]
> Sent: Tuesday, December 01, 2009 6:22 PM
> To: Guido Tack
> Cc: Christian Schulte; 'gecode list'
> Subject: Re: [gecode-users] Remapping of BoolVar propagation  
> conditions
>
> Hi Guido,
>
> That was my first thought. But I didn't understand why this remapping
> was there. Christian said in a previous mail that removing the mapping
> will break all propagators that are used for integer as well as for
> boolean variables! If I pass the pc unchanged, will it break something
> in Gecode ? I don't want to break something, I would like to add
> safely my piece of code.
>
> If removing it doesn't break anything, will this mapping be still
> there in the future versions ?
>
> Thank you again, I really appreciate the time you spent to answer my
> questions :)
>
> Cheers,
> Vincent
>
> Le 1 d?c. 09 ? 16:30, Guido Tack a ?crit :
>
>> Hi Vincent,
>>
>> the rewriting is currently done in int/var-imp/bool.hpp.  Just
>> remove the rewriting there and pass the pc unchanged, add rewriting
>> to all the normal Gecode BoolView classes, and then add your own
>> BoolView class that doesn't rewrite.
>>
>> Cheers,
>> 	Guido
>>
>> Vincent Barichard wrote:
>>
>>> Dear Christian,
>>>
>>> Thank you very much for your mail. I'm sorry, I don't understand
>>> your answer. Why having other BoolView classes will
>>> help me ? I added member functions in the BoolViews classes. I
>>> didn't change the existing ones,
>>> I only added member functions which notify the ME_BOOL_SAME event.
>>>
>>> In my own propagator (let's call it M) I call the recently added
>>> functions in the BoolViews. So the ME_BOOL_SAME
>>> event is sent.
>>>
>>> I also modified one propagator of Gecode (let's call it P') and
>>> make it subscribe to the PC_BOOL_SAME propagation condition (I only
>>> added "x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
>>> In the "propagate" function of P' I added instructions which are
>>> only relevant if a ME_BOOL_SAME event has been sent before.
>>>
>>> So when M is woke up (because it subscribe to PC_BOOL_VAL
>>> propagation condition) it may call the new member functions in the
>>> BoolViews classes which sent the ME_BOOL_SAME event. I would like
>>> that propagators which subscribe to the PC_BOOL_SAME propagation
>>> condition and only these ones, be scheduled to wake up (for example
>>> P' will be scheduled if it shares a variable with M). As no
>>> assignment has been made by the M propagator, I don't want that
>>> other propagators wake up except if a ME_BOOL_VAL event has been
>>> sent from elsewhere.
>>>
>>> Unfortunately, as all propagation condition subscribings for
>>> Boleans variables are remapped to PC_BOOL_VAL, P' will not awake if
>>> a ME_BOOL_SAME event is sent.
>>>
>>> May have I another choice but to use the ME_BOOL_VAL event instead
>>> of ME_BOOL_SAME in my new member functions of the BoolView
>>> classes ? As a result, all propagators will be awaken even if they
>>> can't propagate removal, indeed no assignment has been made.
>>>
>>> Don't hesitate to ask me if I'm not clear enough.
>>>
>>> Cheers,
>>> Vincent
>>>
>>> Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :
>>>
>>>> Actually what you have to do is the following: you define two
>>>> classes for
>>>> Boolean views, one that rewrites its propagation conditions and
>>>> the other
>>>> one that does not. Then your propagators can use the views without
>>>> rewriting
>>>> while the other propagators can use the variables with rewriting.
>>>>
>>>> Christian
>>>>
>>>> --
>>>> Christian Schulte, www.ict.kth.se/~cschulte/
>>>>
>>>>
>>>> -----Original Message-----
>>>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org]
>>>> On Behalf
>>>> Of Vincent Barichard
>>>> Sent: Monday, November 30, 2009 9:33 AM
>>>> To: Christian Schulte
>>>> Cc: 'Guido Tack'; 'gecode list'
>>>> Subject: Re: [gecode-users] Remapping of BoolVar propagation
>>>> conditions
>>>>
>>>> Hi,
>>>>
>>>> Thank you both for your answers. As I don't want to break all
>>>> propagators
>>>> that are used for integer as well as boolean variables, I see no
>>>> choice but
>>>> to use PC_BOOL_VAL.
>>>>
>>>> Maybe one of you may see another way ? I make new functions on
>>>> Boolean
>>>> variables (and associated views) which don't set domain to 1 or 0
>>>> (I copied
>>>> "ModEvent  BoolVarImp::one_none(Space& home)" and removed the
>>>> unwanted
>>>> instructions). These functions notify new events (called
>>>> ME_BOOL_SAME in
>>>> bool.vis file (see attached file)). I mapped this new event to the
>>>> PC_BOOL_SAME propagation condition.
>>>>
>>>> Now I change an existing propagator (like the "Or" propagator),
>>>> and I want
>>>> it to be awaken when ME_BOOL_SAME is emitted. As the variable is
>>>> not yet
>>>> assigned, I didn't want to emit the ME_BOOL_VAL event because I
>>>> didn't want
>>>> to wake up propagators which only subscribed to the PC_BOOL_VAL
>>>> condition.
>>>>
>>>> So during propagation, I call my new functions on Boolean
>>>> variables, the
>>>> ME_BOOL_SAME event is sent and propagators which subscribe to the
>>>> PC_BOOL_SAME condition are wake up. Other propagators are not
>>>> awaken (except
>>>> if a ME_BOOL_VAL event has also been sent). Is it possible ?
>>>> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators
>>>> will be
>>>> awaken for nothing.
>>>>
>>>> Thanks for your help.
>>>>
>>>> Cheers,
>>>> Vincent
>>>
>>> Vincent Barichard         Universit? d'Angers (LERIA)
>>> Tel: 02 41 73 52 06      D?partement Informatique
>>> Fax: 02 41 73 50 73     H203
>>>
>
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
>

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203



From cschulte at kth.se  Wed Dec  2 19:06:25 2009
From: cschulte at kth.se (Christian Schulte)
Date: Wed, 2 Dec 2009 19:06:25 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <B8B85CA0-D2B4-45A2-A34D-A9E81BB37D24@univ-angers.fr>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>
	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>
	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
	<EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
	<FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
	<FCD7C211-D379-4B87-9B3D-6065D935129F@univ-angers.fr>
	<002a01ca72b3$c59c0790$50d416b0$@se>
	<B8B85CA0-D2B4-45A2-A34D-A9E81BB37D24@univ-angers.fr>
Message-ID: <001301ca737a$2b4b9b20$81e2d160$@se>

No, that wouldn't really work as I think it is best to not change the code
of the propagators: that's the entire idea behind views!

I would be happier if your first sentence would read as follows: ... the
remapping is only meaningful for propagators which use boolean variables as
(instead of and) integer variables.

So, what's so bad about defining two views and instantiate the propagators
accordingly? I even thought that this should have been done in Gecode right
from the start.

Christian

-----Original Message-----
From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr] 
Sent: Wednesday, December 02, 2009 2:45 PM
To: Christian Schulte
Cc: 'Guido Tack'; 'gecode list'
Subject: Re: [gecode-users] Remapping of BoolVar propagation conditions

Hi,

Ok, if I understood all answers, the remapping is only meaningful for  
propagators which use boolean variables and integer variables. As they  
can't distinguish boolean variables from integer ones, the propagation  
conditions are remapped in the first case.

If the propagators might distinguish boolean variables from integer  
variables, and use the correct propagation condition in each case, the  
remapped will be useless.

If I modify the ViewVarImpTraits and the constructors of propagators  
in the following way, will all existing propagators of Gecode work as  
usual ? In that case I will be able to add a new PC_BOOL_SAME  
condition without breaking anything.

In gecode/int/view.hpp, I change all ViewVarImpTraits classes:

Those which are over booleans,

   template<>
   class ViewVarImpTraits<Int::IntView> {
   public:
     /// The variable type of an IntView
     typedef Int::IntVarImp VarImp;
     static const bool isBool = false;
   };

Those which deal with booleans,

   template<>
   class ViewVarImpTraits<Int::BoolView> {
   public:
     /// The variable type of a BoolView
     typedef Int::BoolVarImp VarImp;
     static const bool isBool = true;
   };


and in propagator constructors (for example in gecode/int/element/ 
int.hpp) replace calls to :

x0.subscribe(home,*this,PC_INT_DOM);

by

x0.subscribe(home,*this,(Gecode::ViewVarImpTraits<V0>::isBool)? 
PC_BOOL_VAL:PC_INT_DOM);

After, in the file gecode/int/var-imp/bool.hpp :

   forceinline void
   BoolVarImp::subscribe(Space& home, Propagator& p, PropCond,
                         bool process) {
     // Subscription can be used with integer propagation conditions,
     // which must be remapped to the single Boolean propagation  
condition.
     BoolVarImpBase::subscribe(home,p,PC_BOOL_VAL,assigned(),process);
   }

can be replaced by

   forceinline void
   BoolVarImp::subscribe(Space& home, Propagator& p, PropCond pc,
                         bool process) {
     BoolVarImpBase::subscribe(home,p,pc,assigned(),process);
   }

(the same for the cancel member function)

and everything should work as usual.
Am I right ?

Cheers,
Vincent


Le 1 d?c. 09 ? 19:26, Christian Schulte a ?crit :

> Actually, what Guido and me tried to say is the following:  
> conceptually,
> Gecode should have two Boolean views, say BoolView and  
> BoolAsAnIntView. The
> former does not need rewriting and most propagators using Boolean  
> views
> should use this one. The latter must use rewriting to map integer
> propagation conditions to the single supported Boolean propagation
> condition.
>
> Then there are integer propagators which we also want to use on  
> Boolean
> views (these are few: the extensional ones, including element and  
> sequence).
> These propagators should use BoolAsAnIntView including rewriting.  
> All other
> - true Boolean propagators should use the real BoolView.
>
> So what you might want to do is to have these two different views,  
> one with
> and one without rewriting! Everything will work just fine.
>
> Christian
>
> -----Original Message-----
> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr]
> Sent: Tuesday, December 01, 2009 6:22 PM
> To: Guido Tack
> Cc: Christian Schulte; 'gecode list'
> Subject: Re: [gecode-users] Remapping of BoolVar propagation  
> conditions
>
> Hi Guido,
>
> That was my first thought. But I didn't understand why this remapping
> was there. Christian said in a previous mail that removing the mapping
> will break all propagators that are used for integer as well as for
> boolean variables! If I pass the pc unchanged, will it break something
> in Gecode ? I don't want to break something, I would like to add
> safely my piece of code.
>
> If removing it doesn't break anything, will this mapping be still
> there in the future versions ?
>
> Thank you again, I really appreciate the time you spent to answer my
> questions :)
>
> Cheers,
> Vincent
>
> Le 1 d?c. 09 ? 16:30, Guido Tack a ?crit :
>
>> Hi Vincent,
>>
>> the rewriting is currently done in int/var-imp/bool.hpp.  Just
>> remove the rewriting there and pass the pc unchanged, add rewriting
>> to all the normal Gecode BoolView classes, and then add your own
>> BoolView class that doesn't rewrite.
>>
>> Cheers,
>> 	Guido
>>
>> Vincent Barichard wrote:
>>
>>> Dear Christian,
>>>
>>> Thank you very much for your mail. I'm sorry, I don't understand
>>> your answer. Why having other BoolView classes will
>>> help me ? I added member functions in the BoolViews classes. I
>>> didn't change the existing ones,
>>> I only added member functions which notify the ME_BOOL_SAME event.
>>>
>>> In my own propagator (let's call it M) I call the recently added
>>> functions in the BoolViews. So the ME_BOOL_SAME
>>> event is sent.
>>>
>>> I also modified one propagator of Gecode (let's call it P') and
>>> make it subscribe to the PC_BOOL_SAME propagation condition (I only
>>> added "x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
>>> In the "propagate" function of P' I added instructions which are
>>> only relevant if a ME_BOOL_SAME event has been sent before.
>>>
>>> So when M is woke up (because it subscribe to PC_BOOL_VAL
>>> propagation condition) it may call the new member functions in the
>>> BoolViews classes which sent the ME_BOOL_SAME event. I would like
>>> that propagators which subscribe to the PC_BOOL_SAME propagation
>>> condition and only these ones, be scheduled to wake up (for example
>>> P' will be scheduled if it shares a variable with M). As no
>>> assignment has been made by the M propagator, I don't want that
>>> other propagators wake up except if a ME_BOOL_VAL event has been
>>> sent from elsewhere.
>>>
>>> Unfortunately, as all propagation condition subscribings for
>>> Boleans variables are remapped to PC_BOOL_VAL, P' will not awake if
>>> a ME_BOOL_SAME event is sent.
>>>
>>> May have I another choice but to use the ME_BOOL_VAL event instead
>>> of ME_BOOL_SAME in my new member functions of the BoolView
>>> classes ? As a result, all propagators will be awaken even if they
>>> can't propagate removal, indeed no assignment has been made.
>>>
>>> Don't hesitate to ask me if I'm not clear enough.
>>>
>>> Cheers,
>>> Vincent
>>>
>>> Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :
>>>
>>>> Actually what you have to do is the following: you define two
>>>> classes for
>>>> Boolean views, one that rewrites its propagation conditions and
>>>> the other
>>>> one that does not. Then your propagators can use the views without
>>>> rewriting
>>>> while the other propagators can use the variables with rewriting.
>>>>
>>>> Christian
>>>>
>>>> --
>>>> Christian Schulte, www.ict.kth.se/~cschulte/
>>>>
>>>>
>>>> -----Original Message-----
>>>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org]
>>>> On Behalf
>>>> Of Vincent Barichard
>>>> Sent: Monday, November 30, 2009 9:33 AM
>>>> To: Christian Schulte
>>>> Cc: 'Guido Tack'; 'gecode list'
>>>> Subject: Re: [gecode-users] Remapping of BoolVar propagation
>>>> conditions
>>>>
>>>> Hi,
>>>>
>>>> Thank you both for your answers. As I don't want to break all
>>>> propagators
>>>> that are used for integer as well as boolean variables, I see no
>>>> choice but
>>>> to use PC_BOOL_VAL.
>>>>
>>>> Maybe one of you may see another way ? I make new functions on
>>>> Boolean
>>>> variables (and associated views) which don't set domain to 1 or 0
>>>> (I copied
>>>> "ModEvent  BoolVarImp::one_none(Space& home)" and removed the
>>>> unwanted
>>>> instructions). These functions notify new events (called
>>>> ME_BOOL_SAME in
>>>> bool.vis file (see attached file)). I mapped this new event to the
>>>> PC_BOOL_SAME propagation condition.
>>>>
>>>> Now I change an existing propagator (like the "Or" propagator),
>>>> and I want
>>>> it to be awaken when ME_BOOL_SAME is emitted. As the variable is
>>>> not yet
>>>> assigned, I didn't want to emit the ME_BOOL_VAL event because I
>>>> didn't want
>>>> to wake up propagators which only subscribed to the PC_BOOL_VAL
>>>> condition.
>>>>
>>>> So during propagation, I call my new functions on Boolean
>>>> variables, the
>>>> ME_BOOL_SAME event is sent and propagators which subscribe to the
>>>> PC_BOOL_SAME condition are wake up. Other propagators are not
>>>> awaken (except
>>>> if a ME_BOOL_VAL event has also been sent). Is it possible ?
>>>> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators
>>>> will be
>>>> awaken for nothing.
>>>>
>>>> Thanks for your help.
>>>>
>>>> Cheers,
>>>> Vincent
>>>
>>> Vincent Barichard         Universit? d'Angers (LERIA)
>>> Tel: 02 41 73 52 06      D?partement Informatique
>>> Fax: 02 41 73 50 73     H203
>>>
>
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
>

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203




From Vincent.Barichard at univ-angers.fr  Wed Dec  2 22:38:10 2009
From: Vincent.Barichard at univ-angers.fr (Vincent Barichard)
Date: Wed, 2 Dec 2009 22:38:10 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <001301ca737a$2b4b9b20$81e2d160$@se>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>
	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>
	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
	<EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
	<FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
	<FCD7C211-D379-4B87-9B3D-6065D935129F@univ-angers.fr>
	<002a01ca72b3$c59c0790$50d416b0$@se>
	<B8B85CA0-D2B4-45A2-A34D-A9E81BB37D24@univ-angers.fr>
	<001301ca737a$2b4b9b20$81e2d160$@se>
Message-ID: <A8A6EBBB-121F-426C-8DA4-FAA08989C8ED@univ-angers.fr>

Hi Christian,

As the remapping is done in VarImp and not in View, I don't see how to  
solve my problem by defining another View.
For example, if I want to make element constraint over booleans  
variables subscribe to PC_BOOL_SAME, I update the constructor of  
"Int<V0,V1,Idx,Val>" to make views x0 and x1 subscribe to PC_INT_DOM  
and PC_BOOL_SAME. If I use the new view, boolean variable will  
subscribe to PC_INT_DOM instead to PC_BOOL_VAL and integer variables  
will subscribe to PC_BOOL_SAME that is not meaningful for them.

Maybe if subscribe functions could be called like that :  
x0.subscribe(home, *this, PC_INT_DOM | PC_BOOL_VAL);
with PC_X_X propagation conditions seen as flag, the subscribe  
function of a view may be able to deal only with
conditions meaningful for the view and ignore others. For example, in  
x0.subscribe(home, *this, PC_INT_DOM | PC_BOOL_VAL | PC_BOOL_SAME),  
PC_INT_DOM is only meaningful for IntView and PC_BOOL_VAL and  
PC_BOOL_SAME are only meaningful for BoolView. Other problems will  
occur like the maximum number of PC_X_X conditions managed in Gecode.  
Sorry my guess is probably irrelevant, but I don't see how to do  
without changing even a
little the propagators.

Furthermore, all current "rel()" functions which post propagators use  
usual BoolView.So I have to change all functions which post  
propagators to make them post propagators with the new view. I think  
that It is more painful than just updating the constructor of some  
propagators.

Sorry to bother you with my questions. I think Gecode is a great  
solver and I like to add inside it
my ideas in order to validate them..

Cheers,
Vincent

Le 2 d?c. 09 ? 19:06, Christian Schulte a ?crit :

> No, that wouldn't really work as I think it is best to not change  
> the code
> of the propagators: that's the entire idea behind views!
>
> I would be happier if your first sentence would read as follows: ...  
> the
> remapping is only meaningful for propagators which use boolean  
> variables as
> (instead of and) integer variables.
>
> So, what's so bad about defining two views and instantiate the  
> propagators
> accordingly? I even thought that this should have been done in  
> Gecode right
> from the start.
>
> Christian
>
> -----Original Message-----
> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr]
> Sent: Wednesday, December 02, 2009 2:45 PM
> To: Christian Schulte
> Cc: 'Guido Tack'; 'gecode list'
> Subject: Re: [gecode-users] Remapping of BoolVar propagation  
> conditions
>
> Hi,
>
> Ok, if I understood all answers, the remapping is only meaningful for
> propagators which use boolean variables and integer variables. As they
> can't distinguish boolean variables from integer ones, the propagation
> conditions are remapped in the first case.
>
> If the propagators might distinguish boolean variables from integer
> variables, and use the correct propagation condition in each case, the
> remapped will be useless.
>
> If I modify the ViewVarImpTraits and the constructors of propagators
> in the following way, will all existing propagators of Gecode work as
> usual ? In that case I will be able to add a new PC_BOOL_SAME
> condition without breaking anything.
>
> In gecode/int/view.hpp, I change all ViewVarImpTraits classes:
>
> Those which are over booleans,
>
>   template<>
>   class ViewVarImpTraits<Int::IntView> {
>   public:
>     /// The variable type of an IntView
>     typedef Int::IntVarImp VarImp;
>     static const bool isBool = false;
>   };
>
> Those which deal with booleans,
>
>   template<>
>   class ViewVarImpTraits<Int::BoolView> {
>   public:
>     /// The variable type of a BoolView
>     typedef Int::BoolVarImp VarImp;
>     static const bool isBool = true;
>   };
>
>
> and in propagator constructors (for example in gecode/int/element/
> int.hpp) replace calls to :
>
> x0.subscribe(home,*this,PC_INT_DOM);
>
> by
>
> x0.subscribe(home,*this,(Gecode::ViewVarImpTraits<V0>::isBool)?
> PC_BOOL_VAL:PC_INT_DOM);
>
> After, in the file gecode/int/var-imp/bool.hpp :
>
>   forceinline void
>   BoolVarImp::subscribe(Space& home, Propagator& p, PropCond,
>                         bool process) {
>     // Subscription can be used with integer propagation conditions,
>     // which must be remapped to the single Boolean propagation
> condition.
>     BoolVarImpBase::subscribe(home,p,PC_BOOL_VAL,assigned(),process);
>   }
>
> can be replaced by
>
>   forceinline void
>   BoolVarImp::subscribe(Space& home, Propagator& p, PropCond pc,
>                         bool process) {
>     BoolVarImpBase::subscribe(home,p,pc,assigned(),process);
>   }
>
> (the same for the cancel member function)
>
> and everything should work as usual.
> Am I right ?
>
> Cheers,
> Vincent
>
>
> Le 1 d?c. 09 ? 19:26, Christian Schulte a ?crit :
>
>> Actually, what Guido and me tried to say is the following:
>> conceptually,
>> Gecode should have two Boolean views, say BoolView and
>> BoolAsAnIntView. The
>> former does not need rewriting and most propagators using Boolean
>> views
>> should use this one. The latter must use rewriting to map integer
>> propagation conditions to the single supported Boolean propagation
>> condition.
>>
>> Then there are integer propagators which we also want to use on
>> Boolean
>> views (these are few: the extensional ones, including element and
>> sequence).
>> These propagators should use BoolAsAnIntView including rewriting.
>> All other
>> - true Boolean propagators should use the real BoolView.
>>
>> So what you might want to do is to have these two different views,
>> one with
>> and one without rewriting! Everything will work just fine.
>>
>> Christian
>>
>> -----Original Message-----
>> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr]
>> Sent: Tuesday, December 01, 2009 6:22 PM
>> To: Guido Tack
>> Cc: Christian Schulte; 'gecode list'
>> Subject: Re: [gecode-users] Remapping of BoolVar propagation
>> conditions
>>
>> Hi Guido,
>>
>> That was my first thought. But I didn't understand why this remapping
>> was there. Christian said in a previous mail that removing the  
>> mapping
>> will break all propagators that are used for integer as well as for
>> boolean variables! If I pass the pc unchanged, will it break  
>> something
>> in Gecode ? I don't want to break something, I would like to add
>> safely my piece of code.
>>
>> If removing it doesn't break anything, will this mapping be still
>> there in the future versions ?
>>
>> Thank you again, I really appreciate the time you spent to answer my
>> questions :)
>>
>> Cheers,
>> Vincent
>>
>> Le 1 d?c. 09 ? 16:30, Guido Tack a ?crit :
>>
>>> Hi Vincent,
>>>
>>> the rewriting is currently done in int/var-imp/bool.hpp.  Just
>>> remove the rewriting there and pass the pc unchanged, add rewriting
>>> to all the normal Gecode BoolView classes, and then add your own
>>> BoolView class that doesn't rewrite.
>>>
>>> Cheers,
>>> 	Guido
>>>
>>> Vincent Barichard wrote:
>>>
>>>> Dear Christian,
>>>>
>>>> Thank you very much for your mail. I'm sorry, I don't understand
>>>> your answer. Why having other BoolView classes will
>>>> help me ? I added member functions in the BoolViews classes. I
>>>> didn't change the existing ones,
>>>> I only added member functions which notify the ME_BOOL_SAME event.
>>>>
>>>> In my own propagator (let's call it M) I call the recently added
>>>> functions in the BoolViews. So the ME_BOOL_SAME
>>>> event is sent.
>>>>
>>>> I also modified one propagator of Gecode (let's call it P') and
>>>> make it subscribe to the PC_BOOL_SAME propagation condition (I only
>>>> added "x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
>>>> In the "propagate" function of P' I added instructions which are
>>>> only relevant if a ME_BOOL_SAME event has been sent before.
>>>>
>>>> So when M is woke up (because it subscribe to PC_BOOL_VAL
>>>> propagation condition) it may call the new member functions in the
>>>> BoolViews classes which sent the ME_BOOL_SAME event. I would like
>>>> that propagators which subscribe to the PC_BOOL_SAME propagation
>>>> condition and only these ones, be scheduled to wake up (for example
>>>> P' will be scheduled if it shares a variable with M). As no
>>>> assignment has been made by the M propagator, I don't want that
>>>> other propagators wake up except if a ME_BOOL_VAL event has been
>>>> sent from elsewhere.
>>>>
>>>> Unfortunately, as all propagation condition subscribings for
>>>> Boleans variables are remapped to PC_BOOL_VAL, P' will not awake if
>>>> a ME_BOOL_SAME event is sent.
>>>>
>>>> May have I another choice but to use the ME_BOOL_VAL event instead
>>>> of ME_BOOL_SAME in my new member functions of the BoolView
>>>> classes ? As a result, all propagators will be awaken even if they
>>>> can't propagate removal, indeed no assignment has been made.
>>>>
>>>> Don't hesitate to ask me if I'm not clear enough.
>>>>
>>>> Cheers,
>>>> Vincent
>>>>
>>>> Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :
>>>>
>>>>> Actually what you have to do is the following: you define two
>>>>> classes for
>>>>> Boolean views, one that rewrites its propagation conditions and
>>>>> the other
>>>>> one that does not. Then your propagators can use the views without
>>>>> rewriting
>>>>> while the other propagators can use the variables with rewriting.
>>>>>
>>>>> Christian
>>>>>
>>>>> --
>>>>> Christian Schulte, www.ict.kth.se/~cschulte/
>>>>>
>>>>>
>>>>> -----Original Message-----
>>>>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org]
>>>>> On Behalf
>>>>> Of Vincent Barichard
>>>>> Sent: Monday, November 30, 2009 9:33 AM
>>>>> To: Christian Schulte
>>>>> Cc: 'Guido Tack'; 'gecode list'
>>>>> Subject: Re: [gecode-users] Remapping of BoolVar propagation
>>>>> conditions
>>>>>
>>>>> Hi,
>>>>>
>>>>> Thank you both for your answers. As I don't want to break all
>>>>> propagators
>>>>> that are used for integer as well as boolean variables, I see no
>>>>> choice but
>>>>> to use PC_BOOL_VAL.
>>>>>
>>>>> Maybe one of you may see another way ? I make new functions on
>>>>> Boolean
>>>>> variables (and associated views) which don't set domain to 1 or 0
>>>>> (I copied
>>>>> "ModEvent  BoolVarImp::one_none(Space& home)" and removed the
>>>>> unwanted
>>>>> instructions). These functions notify new events (called
>>>>> ME_BOOL_SAME in
>>>>> bool.vis file (see attached file)). I mapped this new event to the
>>>>> PC_BOOL_SAME propagation condition.
>>>>>
>>>>> Now I change an existing propagator (like the "Or" propagator),
>>>>> and I want
>>>>> it to be awaken when ME_BOOL_SAME is emitted. As the variable is
>>>>> not yet
>>>>> assigned, I didn't want to emit the ME_BOOL_VAL event because I
>>>>> didn't want
>>>>> to wake up propagators which only subscribed to the PC_BOOL_VAL
>>>>> condition.
>>>>>
>>>>> So during propagation, I call my new functions on Boolean
>>>>> variables, the
>>>>> ME_BOOL_SAME event is sent and propagators which subscribe to the
>>>>> PC_BOOL_SAME condition are wake up. Other propagators are not
>>>>> awaken (except
>>>>> if a ME_BOOL_VAL event has also been sent). Is it possible ?
>>>>> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators
>>>>> will be
>>>>> awaken for nothing.
>>>>>
>>>>> Thanks for your help.
>>>>>
>>>>> Cheers,
>>>>> Vincent
>>>>
>>>> Vincent Barichard         Universit? d'Angers (LERIA)
>>>> Tel: 02 41 73 52 06      D?partement Informatique
>>>> Fax: 02 41 73 50 73     H203
>>>>
>>
>> Vincent Barichard         Universit? d'Angers (LERIA)
>> Tel: 02 41 73 52 06      D?partement Informatique
>> Fax: 02 41 73 50 73     H203
>>
>
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
>

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203



From cschulte at kth.se  Fri Dec  4 16:02:15 2009
From: cschulte at kth.se (Christian Schulte)
Date: Fri, 4 Dec 2009 16:02:15 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <A8A6EBBB-121F-426C-8DA4-FAA08989C8ED@univ-angers.fr>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>
	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>
	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
	<EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
	<FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
	<FCD7C211-D379-4B87-9B3D-6065D935129F@univ-angers.fr>
	<002a01ca72b3$c59c0790$50d416b0$@se>
	<B8B85CA0-D2B4-45A2-A34D-A9E81BB37D24@univ-angers.fr>
	<001301ca737a$2b4b9b20$81e2d160$@se>
	<A8A6EBBB-121F-426C-8DA4-FAA08989C8ED@univ-angers.fr>
Message-ID: <001d01ca74f2$c5bf80d0$513e8270$@se>

Hi,

Sorry, but the flag thing will not work. You would have to rewrite the
entire kernel and how the variable stubs are automatically generated to pull
that off.

I think we discussed already that you have to move out the rewriting from
the varimp to the views.

As it comes to what is most effort I can't really say as I don't know what
you want to do. If I just wanted to clarify whether a propagator uses a
Boolean variable as a Boolean variable or an integer variable I'd do what I
said.

Cheers
Christian

--
Christian Schulte, www.ict.kth.se/~cschulte/

-----Original Message-----
From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr] 
Sent: Wednesday, December 02, 2009 10:38 PM
To: Christian Schulte
Cc: 'Guido Tack'; 'gecode list'
Subject: Re: [gecode-users] Remapping of BoolVar propagation conditions

Hi Christian,

As the remapping is done in VarImp and not in View, I don't see how to
solve my problem by defining another View.
For example, if I want to make element constraint over booleans
variables subscribe to PC_BOOL_SAME, I update the constructor of
"Int<V0,V1,Idx,Val>" to make views x0 and x1 subscribe to PC_INT_DOM
and PC_BOOL_SAME. If I use the new view, boolean variable will
subscribe to PC_INT_DOM instead to PC_BOOL_VAL and integer variables
will subscribe to PC_BOOL_SAME that is not meaningful for them.

Maybe if subscribe functions could be called like that :
x0.subscribe(home, *this, PC_INT_DOM | PC_BOOL_VAL);
with PC_X_X propagation conditions seen as flag, the subscribe
function of a view may be able to deal only with
conditions meaningful for the view and ignore others. For example, in
x0.subscribe(home, *this, PC_INT_DOM | PC_BOOL_VAL | PC_BOOL_SAME),
PC_INT_DOM is only meaningful for IntView and PC_BOOL_VAL and
PC_BOOL_SAME are only meaningful for BoolView. Other problems will
occur like the maximum number of PC_X_X conditions managed in Gecode.
Sorry my guess is probably irrelevant, but I don't see how to do
without changing even a
little the propagators.

Furthermore, all current "rel()" functions which post propagators use
usual BoolView.So I have to change all functions which post
propagators to make them post propagators with the new view. I think
that It is more painful than just updating the constructor of some
propagators.

Sorry to bother you with my questions. I think Gecode is a great
solver and I like to add inside it
my ideas in order to validate them..

Cheers,
Vincent

Le 2 d?c. 09 ? 19:06, Christian Schulte a ?crit :

> No, that wouldn't really work as I think it is best to not change
> the code
> of the propagators: that's the entire idea behind views!
>
> I would be happier if your first sentence would read as follows: ...
> the
> remapping is only meaningful for propagators which use boolean
> variables as
> (instead of and) integer variables.
>
> So, what's so bad about defining two views and instantiate the
> propagators
> accordingly? I even thought that this should have been done in
> Gecode right
> from the start.
>
> Christian
>
> -----Original Message-----
> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr]
> Sent: Wednesday, December 02, 2009 2:45 PM
> To: Christian Schulte
> Cc: 'Guido Tack'; 'gecode list'
> Subject: Re: [gecode-users] Remapping of BoolVar propagation
> conditions
>
> Hi,
>
> Ok, if I understood all answers, the remapping is only meaningful for
> propagators which use boolean variables and integer variables. As they
> can't distinguish boolean variables from integer ones, the propagation
> conditions are remapped in the first case.
>
> If the propagators might distinguish boolean variables from integer
> variables, and use the correct propagation condition in each case, the
> remapped will be useless.
>
> If I modify the ViewVarImpTraits and the constructors of propagators
> in the following way, will all existing propagators of Gecode work as
> usual ? In that case I will be able to add a new PC_BOOL_SAME
> condition without breaking anything.
>
> In gecode/int/view.hpp, I change all ViewVarImpTraits classes:
>
> Those which are over booleans,
>
>   template<>
>   class ViewVarImpTraits<Int::IntView> {
>   public:
>     /// The variable type of an IntView
>     typedef Int::IntVarImp VarImp;
>     static const bool isBool = false;
>   };
>
> Those which deal with booleans,
>
>   template<>
>   class ViewVarImpTraits<Int::BoolView> {
>   public:
>     /// The variable type of a BoolView
>     typedef Int::BoolVarImp VarImp;
>     static const bool isBool = true;
>   };
>
>
> and in propagator constructors (for example in gecode/int/element/
> int.hpp) replace calls to :
>
> x0.subscribe(home,*this,PC_INT_DOM);
>
> by
>
> x0.subscribe(home,*this,(Gecode::ViewVarImpTraits<V0>::isBool)?
> PC_BOOL_VAL:PC_INT_DOM);
>
> After, in the file gecode/int/var-imp/bool.hpp :
>
>   forceinline void
>   BoolVarImp::subscribe(Space& home, Propagator& p, PropCond,
>                         bool process) {
>     // Subscription can be used with integer propagation conditions,
>     // which must be remapped to the single Boolean propagation
> condition.
>     BoolVarImpBase::subscribe(home,p,PC_BOOL_VAL,assigned(),process);
>   }
>
> can be replaced by
>
>   forceinline void
>   BoolVarImp::subscribe(Space& home, Propagator& p, PropCond pc,
>                         bool process) {
>     BoolVarImpBase::subscribe(home,p,pc,assigned(),process);
>   }
>
> (the same for the cancel member function)
>
> and everything should work as usual.
> Am I right ?
>
> Cheers,
> Vincent
>
>
> Le 1 d?c. 09 ? 19:26, Christian Schulte a ?crit :
>
>> Actually, what Guido and me tried to say is the following:
>> conceptually,
>> Gecode should have two Boolean views, say BoolView and
>> BoolAsAnIntView. The
>> former does not need rewriting and most propagators using Boolean
>> views
>> should use this one. The latter must use rewriting to map integer
>> propagation conditions to the single supported Boolean propagation
>> condition.
>>
>> Then there are integer propagators which we also want to use on
>> Boolean
>> views (these are few: the extensional ones, including element and
>> sequence).
>> These propagators should use BoolAsAnIntView including rewriting.
>> All other
>> - true Boolean propagators should use the real BoolView.
>>
>> So what you might want to do is to have these two different views,
>> one with
>> and one without rewriting! Everything will work just fine.
>>
>> Christian
>>
>> -----Original Message-----
>> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr]
>> Sent: Tuesday, December 01, 2009 6:22 PM
>> To: Guido Tack
>> Cc: Christian Schulte; 'gecode list'
>> Subject: Re: [gecode-users] Remapping of BoolVar propagation
>> conditions
>>
>> Hi Guido,
>>
>> That was my first thought. But I didn't understand why this remapping
>> was there. Christian said in a previous mail that removing the
>> mapping
>> will break all propagators that are used for integer as well as for
>> boolean variables! If I pass the pc unchanged, will it break
>> something
>> in Gecode ? I don't want to break something, I would like to add
>> safely my piece of code.
>>
>> If removing it doesn't break anything, will this mapping be still
>> there in the future versions ?
>>
>> Thank you again, I really appreciate the time you spent to answer my
>> questions :)
>>
>> Cheers,
>> Vincent
>>
>> Le 1 d?c. 09 ? 16:30, Guido Tack a ?crit :
>>
>>> Hi Vincent,
>>>
>>> the rewriting is currently done in int/var-imp/bool.hpp.  Just
>>> remove the rewriting there and pass the pc unchanged, add rewriting
>>> to all the normal Gecode BoolView classes, and then add your own
>>> BoolView class that doesn't rewrite.
>>>
>>> Cheers,
>>>     Guido
>>>
>>> Vincent Barichard wrote:
>>>
>>>> Dear Christian,
>>>>
>>>> Thank you very much for your mail. I'm sorry, I don't understand
>>>> your answer. Why having other BoolView classes will
>>>> help me ? I added member functions in the BoolViews classes. I
>>>> didn't change the existing ones,
>>>> I only added member functions which notify the ME_BOOL_SAME event.
>>>>
>>>> In my own propagator (let's call it M) I call the recently added
>>>> functions in the BoolViews. So the ME_BOOL_SAME
>>>> event is sent.
>>>>
>>>> I also modified one propagator of Gecode (let's call it P') and
>>>> make it subscribe to the PC_BOOL_SAME propagation condition (I only
>>>> added "x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
>>>> In the "propagate" function of P' I added instructions which are
>>>> only relevant if a ME_BOOL_SAME event has been sent before.
>>>>
>>>> So when M is woke up (because it subscribe to PC_BOOL_VAL
>>>> propagation condition) it may call the new member functions in the
>>>> BoolViews classes which sent the ME_BOOL_SAME event. I would like
>>>> that propagators which subscribe to the PC_BOOL_SAME propagation
>>>> condition and only these ones, be scheduled to wake up (for example
>>>> P' will be scheduled if it shares a variable with M). As no
>>>> assignment has been made by the M propagator, I don't want that
>>>> other propagators wake up except if a ME_BOOL_VAL event has been
>>>> sent from elsewhere.
>>>>
>>>> Unfortunately, as all propagation condition subscribings for
>>>> Boleans variables are remapped to PC_BOOL_VAL, P' will not awake if
>>>> a ME_BOOL_SAME event is sent.
>>>>
>>>> May have I another choice but to use the ME_BOOL_VAL event instead
>>>> of ME_BOOL_SAME in my new member functions of the BoolView
>>>> classes ? As a result, all propagators will be awaken even if they
>>>> can't propagate removal, indeed no assignment has been made.
>>>>
>>>> Don't hesitate to ask me if I'm not clear enough.
>>>>
>>>> Cheers,
>>>> Vincent
>>>>
>>>> Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :
>>>>
>>>>> Actually what you have to do is the following: you define two
>>>>> classes for
>>>>> Boolean views, one that rewrites its propagation conditions and
>>>>> the other
>>>>> one that does not. Then your propagators can use the views without
>>>>> rewriting
>>>>> while the other propagators can use the variables with rewriting.
>>>>>
>>>>> Christian
>>>>>
>>>>> --
>>>>> Christian Schulte, www.ict.kth.se/~cschulte/
>>>>>
>>>>>
>>>>> -----Original Message-----
>>>>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org]
>>>>> On Behalf
>>>>> Of Vincent Barichard
>>>>> Sent: Monday, November 30, 2009 9:33 AM
>>>>> To: Christian Schulte
>>>>> Cc: 'Guido Tack'; 'gecode list'
>>>>> Subject: Re: [gecode-users] Remapping of BoolVar propagation
>>>>> conditions
>>>>>
>>>>> Hi,
>>>>>
>>>>> Thank you both for your answers. As I don't want to break all
>>>>> propagators
>>>>> that are used for integer as well as boolean variables, I see no
>>>>> choice but
>>>>> to use PC_BOOL_VAL.
>>>>>
>>>>> Maybe one of you may see another way ? I make new functions on
>>>>> Boolean
>>>>> variables (and associated views) which don't set domain to 1 or 0
>>>>> (I copied
>>>>> "ModEvent  BoolVarImp::one_none(Space& home)" and removed the
>>>>> unwanted
>>>>> instructions). These functions notify new events (called
>>>>> ME_BOOL_SAME in
>>>>> bool.vis file (see attached file)). I mapped this new event to the
>>>>> PC_BOOL_SAME propagation condition.
>>>>>
>>>>> Now I change an existing propagator (like the "Or" propagator),
>>>>> and I want
>>>>> it to be awaken when ME_BOOL_SAME is emitted. As the variable is
>>>>> not yet
>>>>> assigned, I didn't want to emit the ME_BOOL_VAL event because I
>>>>> didn't want
>>>>> to wake up propagators which only subscribed to the PC_BOOL_VAL
>>>>> condition.
>>>>>
>>>>> So during propagation, I call my new functions on Boolean
>>>>> variables, the
>>>>> ME_BOOL_SAME event is sent and propagators which subscribe to the
>>>>> PC_BOOL_SAME condition are wake up. Other propagators are not
>>>>> awaken (except
>>>>> if a ME_BOOL_VAL event has also been sent). Is it possible ?
>>>>> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators
>>>>> will be
>>>>> awaken for nothing.
>>>>>
>>>>> Thanks for your help.
>>>>>
>>>>> Cheers,
>>>>> Vincent
>>>>
>>>> Vincent Barichard         Universit? d'Angers (LERIA)
>>>> Tel: 02 41 73 52 06      D?partement Informatique
>>>> Fax: 02 41 73 50 73     H203
>>>>
>>
>> Vincent Barichard         Universit? d'Angers (LERIA)
>> Tel: 02 41 73 52 06      D?partement Informatique
>> Fax: 02 41 73 50 73     H203
>>
>
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
>

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203




From Vincent.Barichard at univ-angers.fr  Fri Dec  4 18:09:31 2009
From: Vincent.Barichard at univ-angers.fr (Vincent Barichard)
Date: Fri, 4 Dec 2009 18:09:31 +0100
Subject: [gecode-users] Remapping of BoolVar propagation conditions
In-Reply-To: <001d01ca74f2$c5bf80d0$513e8270$@se>
References: <F60FAE32-BB49-4F79-BBB2-053A63262B99@univ-angers.fr>
	<85B1484E-6406-4F38-8FBF-9986D6C6A6F2@ps.uni-sb.de>
	<000001ca7111$d61084f0$82318ed0$@se>
	<52DF1180-C350-49B9-9E7E-29B7A63DBCE8@univ-angers.fr>
	<007c01ca71d2$b7adec20$2709c460$@se>
	<EC611801-F253-421E-9897-18CF3AF864F4@univ-angers.fr>
	<FCE0FD61-CB3F-4A04-88A4-C840CE24A758@ps.uni-sb.de>
	<FCD7C211-D379-4B87-9B3D-6065D935129F@univ-angers.fr>
	<002a01ca72b3$c59c0790$50d416b0$@se>
	<B8B85CA0-D2B4-45A2-A34D-A9E81BB37D24@univ-angers.fr>
	<001301ca737a$2b4b9b20$81e2d160$@se>
	<A8A6EBBB-121F-426C-8DA4-FAA08989C8ED@univ-angers.fr>
	<001d01ca74f2$c5bf80d0$513e8270$@se>
Message-ID: <9EF54BE9-703E-4DEE-9BEB-D64C42ABB2D5@univ-angers.fr>

Hi,

I knew that the flag thing would not be possible. I will follow your  
advice and
investigate further the BoolView changes.

I know that it must be very difficult for you to help me without  
really know what I am trying to do.
For now I launch benchmarks and try to write something about it. If  
you are interested in and have
free time, I will send you the paper.

Thank you very much to you and Guido for all your answer. They are all  
very useful to me.

Cheers,
Vincent

Le 4 d?c. 09 ? 16:02, Christian Schulte a ?crit :

> Hi,
>
> Sorry, but the flag thing will not work. You would have to rewrite the
> entire kernel and how the variable stubs are automatically generated  
> to pull
> that off.
>
> I think we discussed already that you have to move out the rewriting  
> from
> the varimp to the views.
>
> As it comes to what is most effort I can't really say as I don't  
> know what
> you want to do. If I just wanted to clarify whether a propagator  
> uses a
> Boolean variable as a Boolean variable or an integer variable I'd do  
> what I
> said.
>
> Cheers
> Christian
>
> --
> Christian Schulte, www.ict.kth.se/~cschulte/
>
> -----Original Message-----
> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr]
> Sent: Wednesday, December 02, 2009 10:38 PM
> To: Christian Schulte
> Cc: 'Guido Tack'; 'gecode list'
> Subject: Re: [gecode-users] Remapping of BoolVar propagation  
> conditions
>
> Hi Christian,
>
> As the remapping is done in VarImp and not in View, I don't see how to
> solve my problem by defining another View.
> For example, if I want to make element constraint over booleans
> variables subscribe to PC_BOOL_SAME, I update the constructor of
> "Int<V0,V1,Idx,Val>" to make views x0 and x1 subscribe to PC_INT_DOM
> and PC_BOOL_SAME. If I use the new view, boolean variable will
> subscribe to PC_INT_DOM instead to PC_BOOL_VAL and integer variables
> will subscribe to PC_BOOL_SAME that is not meaningful for them.
>
> Maybe if subscribe functions could be called like that :
> x0.subscribe(home, *this, PC_INT_DOM | PC_BOOL_VAL);
> with PC_X_X propagation conditions seen as flag, the subscribe
> function of a view may be able to deal only with
> conditions meaningful for the view and ignore others. For example, in
> x0.subscribe(home, *this, PC_INT_DOM | PC_BOOL_VAL | PC_BOOL_SAME),
> PC_INT_DOM is only meaningful for IntView and PC_BOOL_VAL and
> PC_BOOL_SAME are only meaningful for BoolView. Other problems will
> occur like the maximum number of PC_X_X conditions managed in Gecode.
> Sorry my guess is probably irrelevant, but I don't see how to do
> without changing even a
> little the propagators.
>
> Furthermore, all current "rel()" functions which post propagators use
> usual BoolView.So I have to change all functions which post
> propagators to make them post propagators with the new view. I think
> that It is more painful than just updating the constructor of some
> propagators.
>
> Sorry to bother you with my questions. I think Gecode is a great
> solver and I like to add inside it
> my ideas in order to validate them..
>
> Cheers,
> Vincent
>
> Le 2 d?c. 09 ? 19:06, Christian Schulte a ?crit :
>
>> No, that wouldn't really work as I think it is best to not change
>> the code
>> of the propagators: that's the entire idea behind views!
>>
>> I would be happier if your first sentence would read as follows: ...
>> the
>> remapping is only meaningful for propagators which use boolean
>> variables as
>> (instead of and) integer variables.
>>
>> So, what's so bad about defining two views and instantiate the
>> propagators
>> accordingly? I even thought that this should have been done in
>> Gecode right
>> from the start.
>>
>> Christian
>>
>> -----Original Message-----
>> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr]
>> Sent: Wednesday, December 02, 2009 2:45 PM
>> To: Christian Schulte
>> Cc: 'Guido Tack'; 'gecode list'
>> Subject: Re: [gecode-users] Remapping of BoolVar propagation
>> conditions
>>
>> Hi,
>>
>> Ok, if I understood all answers, the remapping is only meaningful for
>> propagators which use boolean variables and integer variables. As  
>> they
>> can't distinguish boolean variables from integer ones, the  
>> propagation
>> conditions are remapped in the first case.
>>
>> If the propagators might distinguish boolean variables from integer
>> variables, and use the correct propagation condition in each case,  
>> the
>> remapped will be useless.
>>
>> If I modify the ViewVarImpTraits and the constructors of propagators
>> in the following way, will all existing propagators of Gecode work as
>> usual ? In that case I will be able to add a new PC_BOOL_SAME
>> condition without breaking anything.
>>
>> In gecode/int/view.hpp, I change all ViewVarImpTraits classes:
>>
>> Those which are over booleans,
>>
>>  template<>
>>  class ViewVarImpTraits<Int::IntView> {
>>  public:
>>    /// The variable type of an IntView
>>    typedef Int::IntVarImp VarImp;
>>    static const bool isBool = false;
>>  };
>>
>> Those which deal with booleans,
>>
>>  template<>
>>  class ViewVarImpTraits<Int::BoolView> {
>>  public:
>>    /// The variable type of a BoolView
>>    typedef Int::BoolVarImp VarImp;
>>    static const bool isBool = true;
>>  };
>>
>>
>> and in propagator constructors (for example in gecode/int/element/
>> int.hpp) replace calls to :
>>
>> x0.subscribe(home,*this,PC_INT_DOM);
>>
>> by
>>
>> x0.subscribe(home,*this,(Gecode::ViewVarImpTraits<V0>::isBool)?
>> PC_BOOL_VAL:PC_INT_DOM);
>>
>> After, in the file gecode/int/var-imp/bool.hpp :
>>
>>  forceinline void
>>  BoolVarImp::subscribe(Space& home, Propagator& p, PropCond,
>>                        bool process) {
>>    // Subscription can be used with integer propagation conditions,
>>    // which must be remapped to the single Boolean propagation
>> condition.
>>    BoolVarImpBase::subscribe(home,p,PC_BOOL_VAL,assigned(),process);
>>  }
>>
>> can be replaced by
>>
>>  forceinline void
>>  BoolVarImp::subscribe(Space& home, Propagator& p, PropCond pc,
>>                        bool process) {
>>    BoolVarImpBase::subscribe(home,p,pc,assigned(),process);
>>  }
>>
>> (the same for the cancel member function)
>>
>> and everything should work as usual.
>> Am I right ?
>>
>> Cheers,
>> Vincent
>>
>>
>> Le 1 d?c. 09 ? 19:26, Christian Schulte a ?crit :
>>
>>> Actually, what Guido and me tried to say is the following:
>>> conceptually,
>>> Gecode should have two Boolean views, say BoolView and
>>> BoolAsAnIntView. The
>>> former does not need rewriting and most propagators using Boolean
>>> views
>>> should use this one. The latter must use rewriting to map integer
>>> propagation conditions to the single supported Boolean propagation
>>> condition.
>>>
>>> Then there are integer propagators which we also want to use on
>>> Boolean
>>> views (these are few: the extensional ones, including element and
>>> sequence).
>>> These propagators should use BoolAsAnIntView including rewriting.
>>> All other
>>> - true Boolean propagators should use the real BoolView.
>>>
>>> So what you might want to do is to have these two different views,
>>> one with
>>> and one without rewriting! Everything will work just fine.
>>>
>>> Christian
>>>
>>> -----Original Message-----
>>> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr]
>>> Sent: Tuesday, December 01, 2009 6:22 PM
>>> To: Guido Tack
>>> Cc: Christian Schulte; 'gecode list'
>>> Subject: Re: [gecode-users] Remapping of BoolVar propagation
>>> conditions
>>>
>>> Hi Guido,
>>>
>>> That was my first thought. But I didn't understand why this  
>>> remapping
>>> was there. Christian said in a previous mail that removing the
>>> mapping
>>> will break all propagators that are used for integer as well as for
>>> boolean variables! If I pass the pc unchanged, will it break
>>> something
>>> in Gecode ? I don't want to break something, I would like to add
>>> safely my piece of code.
>>>
>>> If removing it doesn't break anything, will this mapping be still
>>> there in the future versions ?
>>>
>>> Thank you again, I really appreciate the time you spent to answer my
>>> questions :)
>>>
>>> Cheers,
>>> Vincent
>>>
>>> Le 1 d?c. 09 ? 16:30, Guido Tack a ?crit :
>>>
>>>> Hi Vincent,
>>>>
>>>> the rewriting is currently done in int/var-imp/bool.hpp.  Just
>>>> remove the rewriting there and pass the pc unchanged, add rewriting
>>>> to all the normal Gecode BoolView classes, and then add your own
>>>> BoolView class that doesn't rewrite.
>>>>
>>>> Cheers,
>>>>    Guido
>>>>
>>>> Vincent Barichard wrote:
>>>>
>>>>> Dear Christian,
>>>>>
>>>>> Thank you very much for your mail. I'm sorry, I don't understand
>>>>> your answer. Why having other BoolView classes will
>>>>> help me ? I added member functions in the BoolViews classes. I
>>>>> didn't change the existing ones,
>>>>> I only added member functions which notify the ME_BOOL_SAME event.
>>>>>
>>>>> In my own propagator (let's call it M) I call the recently added
>>>>> functions in the BoolViews. So the ME_BOOL_SAME
>>>>> event is sent.
>>>>>
>>>>> I also modified one propagator of Gecode (let's call it P') and
>>>>> make it subscribe to the PC_BOOL_SAME propagation condition (I  
>>>>> only
>>>>> added "x1.subscribe(home, *this, PC_BOOL_SAME)" in constructor).
>>>>> In the "propagate" function of P' I added instructions which are
>>>>> only relevant if a ME_BOOL_SAME event has been sent before.
>>>>>
>>>>> So when M is woke up (because it subscribe to PC_BOOL_VAL
>>>>> propagation condition) it may call the new member functions in the
>>>>> BoolViews classes which sent the ME_BOOL_SAME event. I would like
>>>>> that propagators which subscribe to the PC_BOOL_SAME propagation
>>>>> condition and only these ones, be scheduled to wake up (for  
>>>>> example
>>>>> P' will be scheduled if it shares a variable with M). As no
>>>>> assignment has been made by the M propagator, I don't want that
>>>>> other propagators wake up except if a ME_BOOL_VAL event has been
>>>>> sent from elsewhere.
>>>>>
>>>>> Unfortunately, as all propagation condition subscribings for
>>>>> Boleans variables are remapped to PC_BOOL_VAL, P' will not awake  
>>>>> if
>>>>> a ME_BOOL_SAME event is sent.
>>>>>
>>>>> May have I another choice but to use the ME_BOOL_VAL event instead
>>>>> of ME_BOOL_SAME in my new member functions of the BoolView
>>>>> classes ? As a result, all propagators will be awaken even if they
>>>>> can't propagate removal, indeed no assignment has been made.
>>>>>
>>>>> Don't hesitate to ask me if I'm not clear enough.
>>>>>
>>>>> Cheers,
>>>>> Vincent
>>>>>
>>>>> Le 30 nov. 09 ? 16:35, Christian Schulte a ?crit :
>>>>>
>>>>>> Actually what you have to do is the following: you define two
>>>>>> classes for
>>>>>> Boolean views, one that rewrites its propagation conditions and
>>>>>> the other
>>>>>> one that does not. Then your propagators can use the views  
>>>>>> without
>>>>>> rewriting
>>>>>> while the other propagators can use the variables with rewriting.
>>>>>>
>>>>>> Christian
>>>>>>
>>>>>> --
>>>>>> Christian Schulte, www.ict.kth.se/~cschulte/
>>>>>>
>>>>>>
>>>>>> -----Original Message-----
>>>>>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org]
>>>>>> On Behalf
>>>>>> Of Vincent Barichard
>>>>>> Sent: Monday, November 30, 2009 9:33 AM
>>>>>> To: Christian Schulte
>>>>>> Cc: 'Guido Tack'; 'gecode list'
>>>>>> Subject: Re: [gecode-users] Remapping of BoolVar propagation
>>>>>> conditions
>>>>>>
>>>>>> Hi,
>>>>>>
>>>>>> Thank you both for your answers. As I don't want to break all
>>>>>> propagators
>>>>>> that are used for integer as well as boolean variables, I see no
>>>>>> choice but
>>>>>> to use PC_BOOL_VAL.
>>>>>>
>>>>>> Maybe one of you may see another way ? I make new functions on
>>>>>> Boolean
>>>>>> variables (and associated views) which don't set domain to 1 or 0
>>>>>> (I copied
>>>>>> "ModEvent  BoolVarImp::one_none(Space& home)" and removed the
>>>>>> unwanted
>>>>>> instructions). These functions notify new events (called
>>>>>> ME_BOOL_SAME in
>>>>>> bool.vis file (see attached file)). I mapped this new event to  
>>>>>> the
>>>>>> PC_BOOL_SAME propagation condition.
>>>>>>
>>>>>> Now I change an existing propagator (like the "Or" propagator),
>>>>>> and I want
>>>>>> it to be awaken when ME_BOOL_SAME is emitted. As the variable is
>>>>>> not yet
>>>>>> assigned, I didn't want to emit the ME_BOOL_VAL event because I
>>>>>> didn't want
>>>>>> to wake up propagators which only subscribed to the PC_BOOL_VAL
>>>>>> condition.
>>>>>>
>>>>>> So during propagation, I call my new functions on Boolean
>>>>>> variables, the
>>>>>> ME_BOOL_SAME event is sent and propagators which subscribe to the
>>>>>> PC_BOOL_SAME condition are wake up. Other propagators are not
>>>>>> awaken (except
>>>>>> if a ME_BOOL_VAL event has also been sent). Is it possible ?
>>>>>> Should I use ME_BOOL_VAL ? If I use ME_BOOL_VAL other propagators
>>>>>> will be
>>>>>> awaken for nothing.
>>>>>>
>>>>>> Thanks for your help.
>>>>>>
>>>>>> Cheers,
>>>>>> Vincent
>>>>>
>>>>> Vincent Barichard         Universit? d'Angers (LERIA)
>>>>> Tel: 02 41 73 52 06      D?partement Informatique
>>>>> Fax: 02 41 73 50 73     H203
>>>>>
>>>
>>> Vincent Barichard         Universit? d'Angers (LERIA)
>>> Tel: 02 41 73 52 06      D?partement Informatique
>>> Fax: 02 41 73 50 73     H203
>>>
>>
>> Vincent Barichard         Universit? d'Angers (LERIA)
>> Tel: 02 41 73 52 06      D?partement Informatique
>> Fax: 02 41 73 50 73     H203
>>
>
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
>

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203



From ggutierrez at atlas.puj.edu.co  Fri Dec  4 20:00:05 2009
From: ggutierrez at atlas.puj.edu.co (Gustavo Gutierrez)
Date: Fri, 4 Dec 2009 20:00:05 +0100
Subject: [gecode-users] Gecode memory question
Message-ID: <e7b0e5a40912041100q39c8865gb5e44ef20e222cb5@mail.gmail.com>

Dear all,

I am trying to implement something which at a first sight could look weird
and have a memory problem, I will try to be as concise as possible while
giving enough details to have some help from you; if you need to know more,
I don't have any problem to explain my situation in a deeper way.

I have some data structures which are external to propagators but that I
need to share among computation spaces. Still, I would like to have this
data structures allocated in some way by gecode itself and not from using
new (malloc). Let's have a look at the following example of a main program
creating some instances of Space:


 opt.parse(argc,argv);
 Space *sp = new Simple(opt);
 sp->status();
 Space *csp = sp->clone(true);
 csp->status();
 //delete sp;
 Space *csp2 = csp->clone(true);


Just assume that there are no propagators posted during the construction of
Simple, just a branching. Now, If I am right, by sending true to clone will
cause the data structures (variables, etc) to be shared. Then csp will share
data structures with sp. Now, I am considering to clone (and share again the
data structures) csp into csp2. If at some point, I decided to delete sp I
will get a memory problem, this is, there are data structures inside csp2
that are supposed to *point* to something that where in sp but now is
deallocated.

I am using the space allocator to allocate the data structures, so I think
that a space is deallocated by removing its complete heap from memory. If I
understand correctly, there is a one to one relation between a space and a
space heap. In my case, I would like to allocate the data structures
somewhere else in such a way that those are no removed when spaces are
deallocated. Is it possible to do that in gecode?, is there some "general
heap" from which I can allocate memory from?, if yes, is there an allocator
to allocate memory from this part?.

I would like the memory to be allocated by gecode because in that way (I
think) it will be reported as part of the statistics when running a search
engine. Also, the data structures I am using use reference counting for the
memory management but are not thread safe so I would like to know how this
would interact with parallel search engines. I don't want to cause any heap
segmentation (I am not sure how much sensible is gecode to memory alignment
in its heap and things like that) that severely affects gecode performance.


Any comment is more than welcome and thanks in advance.

Gustavo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091204/9a750ff8/attachment.htm>

From tack at ps.uni-sb.de  Sat Dec  5 16:07:15 2009
From: tack at ps.uni-sb.de (Guido Tack)
Date: Sat, 5 Dec 2009 16:07:15 +0100
Subject: [gecode-users] Gecode memory question
In-Reply-To: <e7b0e5a40912041100q39c8865gb5e44ef20e222cb5@mail.gmail.com>
References: <e7b0e5a40912041100q39c8865gb5e44ef20e222cb5@mail.gmail.com>
Message-ID: <14113398-B17B-4CA2-8E62-0E1E0094EE30@ps.uni-sb.de>

Hi Gustavo,

you can allocate from the general heap, which is available in Gecode through the Heap class and the global object called heap.  Furthermore, to get sharing right, you should derive from the SharedHandle/SharedObject infrastructure we provide.  Just have a look at how SharedArrays are implemented, for example.  They have exactly the behavior you describe.

Cheers,
	Guido

Gustavo Gutierrez wrote:

> Dear all,
> 
> I am trying to implement something which at a first sight could look weird and have a memory problem, I will try to be as concise as possible while giving enough details to have some help from you; if you need to know more, I don't have any problem to explain my situation in a deeper way.
> 
> I have some data structures which are external to propagators but that I need to share among computation spaces. Still, I would like to have this data structures allocated in some way by gecode itself and not from using new (malloc). Let's have a look at the following example of a main program creating some instances of Space:
> 
> 
>  opt.parse(argc,argv);
>  Space *sp = new Simple(opt);
>  sp->status();
>  Space *csp = sp->clone(true);
>  csp->status();
>  //delete sp;
>  Space *csp2 = csp->clone(true);
>  
> 
> Just assume that there are no propagators posted during the construction of Simple, just a branching. Now, If I am right, by sending true to clone will cause the data structures (variables, etc) to be shared. Then csp will share data structures with sp. Now, I am considering to clone (and share again the data structures) csp into csp2. If at some point, I decided to delete sp I will get a memory problem, this is, there are data structures inside csp2 that are supposed to *point* to something that where in sp but now is deallocated.
> 
> I am using the space allocator to allocate the data structures, so I think that a space is deallocated by removing its complete heap from memory. If I understand correctly, there is a one to one relation between a space and a space heap. In my case, I would like to allocate the data structures somewhere else in such a way that those are no removed when spaces are deallocated. Is it possible to do that in gecode?, is there some "general heap" from which I can allocate memory from?, if yes, is there an allocator to allocate memory from this part?.
> 
> I would like the memory to be allocated by gecode because in that way (I think) it will be reported as part of the statistics when running a search engine. Also, the data structures I am using use reference counting for the memory management but are not thread safe so I would like to know how this would interact with parallel search engines. I don't want to cause any heap segmentation (I am not sure how much sensible is gecode to memory alignment  in its heap and things like that) that severely affects gecode performance.
> 
> 
> Any comment is more than welcome and thanks in advance.
> 
> Gustavo  
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users



From jkrause at gmx.net  Fri Dec 11 21:12:00 2009
From: jkrause at gmx.net (jkrause at gmx.net)
Date: Fri, 11 Dec 2009 21:12:00 +0100
Subject: [gecode-users] channeling of FloatVar and IntVar,
	FloatVar for Gecode 3?
Message-ID: <4B22A790.5050902@gmx.net>

Dear all,

thanks for your wonderful framework. It solves a lot of my problems. But 
I have a problem, that I can't solve until now.

Assuming that we have a variable 'x' of type 'float' and a constraint:

x<=10, x>=2.5

For "x>=12,5" we can use:

FloatVar x_float(this, double_interval(this, double_interval::whole()), 
twelf_five(this, double_interval(12.5,12.5));
Float::Relational_post(this, x_float, Gecode::Float::FLOAT_REL_GQ,  
twelf_five);

and for "x<=10" we can use:

IntVar x_int(this,IntMin,IntMax), ten(this,10,10);
rel(this, x_int, Gecode::IRT_LQ, ten);

I know I can handle "10" also as a FloatVar. But in general, neglecting 
the conversation problems, I need a channel between "x_int" and 
"x_float", doesn't it? Is there another possibility to handle this 
problem? By the way, is there an update of the FloatVar-library for 
Gecode 3 out there or in planning?

Thanx again and cheers
Jan



From gualandi at elet.polimi.it  Sat Dec 12 09:13:38 2009
From: gualandi at elet.polimi.it (Stefano Gualandi)
Date: Sat, 12 Dec 2009 09:13:38 +0100
Subject: [gecode-users] Server migration...
In-Reply-To: <003801ca6f61$c239d000$46ad7000$@se>
References: <009001ca6eb4$874adf00$95e09d00$@se>
	<003801ca6f61$c239d000$46ad7000$@se>
Message-ID: <BC6ACDE4-AC18-4BB9-AE56-3D44FB8B766E@elet.polimi.it>

Hi Christian,
this morning I tried to update my trunk version, for the first time after the server migration, and something went wrong (see below).
I guess a new check-out would solve the problem, but maybe your are interested anyway.

cheers,
Stefano



~/Programming/C++/Gecode/trunk $ svn update

Error validating server certificate for 'https://svn.gecode.org:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
 - The certificate hostname does not match.
Certificate information:
 - Hostname: localhost.localdomain
 - Valid: from Mon, 05 Oct 2009 09:40:21 GMT until Thu, 03 Oct 2019 09:40:21 GMT
 - Issuer: localhost.localdomain
 - Fingerprint: 80:34:c4:c2:3a:d9:ac:fd:0c:00:f5:7f:b3:b8:29:f5:bb:53:0a:5f
(R)eject, accept (t)emporarily or accept (p)ermanently? p
A    test/int/sequence.cpp
U    test/int/arithmetic.cpp
svn: Server sent unexpected return value (403 Forbidden) in response to OPTIONS request for 'https://svn.gecode.org/svn'

~/Programming/C++/Gecode/trunk $




On Nov 27, 2009, at 14:01 PM, Christian Schulte wrote:

> Dear all,
>  
> the server migration is done. So everything should work as before. Please let us know if anything does not work as expected.
>  
> All the best
> Christian
>  
> --
> Christian Schulte, www.ict.kth.se/~cschulte/
>  
> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf Of Christian Schulte
> Sent: Thursday, November 26, 2009 5:22 PM
> To: 'gecode gecode'
> Subject: [gecode-users] Server migration...
>  
> Dear all,
>  
> We are in the process of migrating gecode.org to a new server. Please expect some hick-ups in the near future. Right now, we are migrating the svn, so svn access will not be possible for some time. We will let you know when svn migration is done and also about other quirks to come.
>  
> Sorry for any inconvenience.
>  
> Christian
>  
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users



From Vincent.Barichard at univ-angers.fr  Mon Dec 14 00:33:05 2009
From: Vincent.Barichard at univ-angers.fr (Vincent Barichard)
Date: Mon, 14 Dec 2009 00:33:05 +0100
Subject: [gecode-users] Propagation condition and cloning
Message-ID: <7BEAD7EE-9B1D-4CCE-91AB-CDC65919629E@univ-angers.fr>

Hi Everyone,

I would like to put another Propagation Condition in BoolVarImp. You gave me good advice on how to process. For a first step, I just wanted to make some test. So I first modified bool.vis and add this new Propagation Condition. Then I tried to make existing propagators subscribe to this new propagation condition (without scheduling propagators and sending the corresponding events). Unfortunately, I failed to achieved this first step. Indeed, some problems occur during cloning.

I first thought that It was a problem with the rewriting of propagator during cloning. Indeed, I didn't update all propagators, so it can't be possible to change a propagator by another one which doesn't subscribe to the same propagation conditions than the original one. 
I disabled the rewrite of a propagator by another propagator from a different class during cloning. But I still have problems. I tried many things, without success and now I have no more ideas.

For now, I just want to understand why I can't make it work. For this purpose, I designed an example to make gecode crash. I used the "sat" example given with Gecode, and only deal with this example (no matter if the other examples don't work anymore).
My problem is reproducible by applying the patch attached in this mail to Gecode 3.2.2. Then, I configured and compiled Gecode with the following commands:

./configure --enable-debug --enable-audit
make

The test problem can be launched by copying the test2.cnf file (attached in the mail) in the gecode directory and executing the command:
./examples/sat test2.cnf

If I use a debugger I get:

Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0x000000020000001b
0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at core.hpp:2328
2328        return _prev;
(gdb) bt
#0  0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at core.hpp:2328
#1  0x000000010146e0be in Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (this=0x101896350, x=0x101877698, sub=@0x7fff5fbfece0) at core.hpp:3295
#2  0x000000010146e1d9 in Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (home=@0x101503f80, sub=@0x7fff5fbfece0) at core.hpp:3314
#3  0x000000010146e4b4 in Gecode::Space::update (this=0x101503f80, sub=0x101888798) at var-imp.hpp:343
#4  0x000000010146bae7 in Gecode::Space::_clone (this=0x101503e20, share=true) at gecode/kernel/core.cpp:481
#5  0x000000010011b58b in Gecode::Space::clone (this=0x101503e20, share=true) at core.hpp:2465
#6  0x000000010011c2c0 in Gecode::Search::Sequential::Path::recompute (this=0x101503798, d=@0x1015037b8, a_d=2, stat=@0x101503718) at path.hh:305
#7  0x000000010011c5be in Gecode::Search::Sequential::DFS::next (this=0x101503718) at dfs.hh:146
#8  0x000000010011c615 in Gecode::Search::WorkerToEngine<Gecode::Search::Sequential::DFS>::next (this=0x101503710) at support.hh:74
#9  0x0000000100007ed2 in Gecode::DFS<Sat>::next (this=0x7fff5fbff070) at dfs.hpp:53
#10 0x000000010000811b in Gecode::Driver::ScriptBase<Gecode::Space>::run<Sat, Gecode::DFS, SatOptions> (o=@0x7fff5fbff1a0) at script.hpp:198
#11 0x0000000100001a34 in main (argc=1, argv=0x7fff5fbff4f0) at examples/sat.cpp:256

I probably made an obvious mistake, but I can not see.
Thanks for your help,

Cheers,
Vincent

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: patch.txt
URL: <http://www.gecode.org/pipermail/users/attachments/20091214/0c0c5909/attachment.txt>
-------------- next part --------------


-------------- next part --------------
A non-text attachment was scrubbed...
Name: test2.cnf
Type: application/octet-stream
Size: 5842 bytes
Desc: not available
URL: <http://www.gecode.org/pipermail/users/attachments/20091214/0c0c5909/attachment.obj>

From cschulte at kth.se  Mon Dec 14 10:26:56 2009
From: cschulte at kth.se (Christian Schulte)
Date: Mon, 14 Dec 2009 10:26:56 +0100
Subject: [gecode-users] Server migration...
In-Reply-To: <BC6ACDE4-AC18-4BB9-AE56-3D44FB8B766E@elet.polimi.it>
References: <009001ca6eb4$874adf00$95e09d00$@se>	<003801ca6f61$c239d000$46ad7000$@se>
	<BC6ACDE4-AC18-4BB9-AE56-3D44FB8B766E@elet.polimi.it>
Message-ID: <003201ca7c9f$9468c960$bd3a5c20$@se>

Hi Stefano,

thanks for letting us know: that's for Guido to look at (but he is awayish).

Cheers
Christian

--
Christian Schulte, www.ict.kth.se/~cschulte/


-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Stefano Gualandi
Sent: Saturday, December 12, 2009 9:14 AM
To: gecode gecode
Subject: Re: [gecode-users] Server migration...

Hi Christian,
this morning I tried to update my trunk version, for the first time after
the server migration, and something went wrong (see below).
I guess a new check-out would solve the problem, but maybe your are
interested anyway.

cheers,
Stefano



~/Programming/C++/Gecode/trunk $ svn update

Error validating server certificate for 'https://svn.gecode.org:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
 - The certificate hostname does not match.
Certificate information:
 - Hostname: localhost.localdomain
 - Valid: from Mon, 05 Oct 2009 09:40:21 GMT until Thu, 03 Oct 2019 09:40:21
GMT
 - Issuer: localhost.localdomain
 - Fingerprint: 80:34:c4:c2:3a:d9:ac:fd:0c:00:f5:7f:b3:b8:29:f5:bb:53:0a:5f
(R)eject, accept (t)emporarily or accept (p)ermanently? p
A    test/int/sequence.cpp
U    test/int/arithmetic.cpp
svn: Server sent unexpected return value (403 Forbidden) in response to
OPTIONS request for 'https://svn.gecode.org/svn'

~/Programming/C++/Gecode/trunk $




On Nov 27, 2009, at 14:01 PM, Christian Schulte wrote:

> Dear all,
>  
> the server migration is done. So everything should work as before. Please
let us know if anything does not work as expected.
>  
> All the best
> Christian
>  
> --
> Christian Schulte, www.ict.kth.se/~cschulte/
>  
> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Christian Schulte
> Sent: Thursday, November 26, 2009 5:22 PM
> To: 'gecode gecode'
> Subject: [gecode-users] Server migration...
>  
> Dear all,
>  
> We are in the process of migrating gecode.org to a new server. Please
expect some hick-ups in the near future. Right now, we are migrating the
svn, so svn access will not be possible for some time. We will let you know
when svn migration is done and also about other quirks to come.
>  
> Sorry for any inconvenience.
>  
> Christian
>  
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users


_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users



From cschulte at kth.se  Mon Dec 14 10:28:06 2009
From: cschulte at kth.se (Christian Schulte)
Date: Mon, 14 Dec 2009 10:28:06 +0100
Subject: [gecode-users] channeling of FloatVar and IntVar,
	FloatVar for Gecode 3?
In-Reply-To: <4B22A790.5050902@gmx.net>
References: <4B22A790.5050902@gmx.net>
Message-ID: <003501ca7c9f$be3fd8a0$3abf89e0$@se>

Hi Jan,

yes you are right. But, after all, the float vars have not made it into
Gecode officcially, so that will have to wait until then. But anyway, I'll
keep that in mind.

Best
Christian

--
Christian Schulte, www.ict.kth.se/~cschulte/


-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of jkrause at gmx.net
Sent: Friday, December 11, 2009 9:12 PM
To: gecode list
Subject: [gecode-users] channeling of FloatVar and IntVar, FloatVar for
Gecode 3?

Dear all,

thanks for your wonderful framework. It solves a lot of my problems. But 
I have a problem, that I can't solve until now.

Assuming that we have a variable 'x' of type 'float' and a constraint:

x<=10, x>=2.5

For "x>=12,5" we can use:

FloatVar x_float(this, double_interval(this, double_interval::whole()), 
twelf_five(this, double_interval(12.5,12.5));
Float::Relational_post(this, x_float, Gecode::Float::FLOAT_REL_GQ,  
twelf_five);

and for "x<=10" we can use:

IntVar x_int(this,IntMin,IntMax), ten(this,10,10);
rel(this, x_int, Gecode::IRT_LQ, ten);

I know I can handle "10" also as a FloatVar. But in general, neglecting 
the conversation problems, I need a channel between "x_int" and 
"x_float", doesn't it? Is there another possibility to handle this 
problem? By the way, is there an update of the FloatVar-library for 
Gecode 3 out there or in planning?

Thanx again and cheers
Jan


_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users



From cschulte at kth.se  Mon Dec 14 11:35:45 2009
From: cschulte at kth.se (Christian Schulte)
Date: Mon, 14 Dec 2009 11:35:45 +0100
Subject: [gecode-users] Propagation condition and cloning
In-Reply-To: <7BEAD7EE-9B1D-4CCE-91AB-CDC65919629E@univ-angers.fr>
References: <7BEAD7EE-9B1D-4CCE-91AB-CDC65919629E@univ-angers.fr>
Message-ID: <001701ca7ca9$32f20700$98d61500$@se>

Hmmm,

the first five lines in the patch look already fishy:

--- gecode/int/bool/clause.hpp	2009-10-14 12:19:49.000000000 +0200
+++ gecode/int/bool/clause.hpp	2009-12-13 23:46:53.000000000 +0100
@@ -50,6 +50,8 @@
   (home,x0[x0.size()-1],y0[y0.size()-1]), x(x0), y(y0) {
     assert((x.size() > 0) && (y.size() > 0));
     x.size(x.size()-1); y.size(y.size()-1);
+    x0.subscribe(home,*this,PC_BOOL_SAME,false);
+    x1.subscribe(home,*this,PC_BOOL_SAME,false);
   }

Here x0 in x0.subscribe refers to the argument passed to the constructor.
You assume it refers to the member, right?

Yep ;-)
Christian

--
Christian Schulte, www.ict.kth.se/~cschulte/


-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Vincent Barichard
Sent: Monday, December 14, 2009 12:33 AM
To: gecode list
Subject: [gecode-users] Propagation condition and cloning

Hi Everyone,

I would like to put another Propagation Condition in BoolVarImp. You gave me
good advice on how to process. For a first step, I just wanted to make some
test. So I first modified bool.vis and add this new Propagation Condition.
Then I tried to make existing propagators subscribe to this new propagation
condition (without scheduling propagators and sending the corresponding
events). Unfortunately, I failed to achieved this first step. Indeed, some
problems occur during cloning.

I first thought that It was a problem with the rewriting of propagator
during cloning. Indeed, I didn't update all propagators, so it can't be
possible to change a propagator by another one which doesn't subscribe to
the same propagation conditions than the original one. 
I disabled the rewrite of a propagator by another propagator from a
different class during cloning. But I still have problems. I tried many
things, without success and now I have no more ideas.

For now, I just want to understand why I can't make it work. For this
purpose, I designed an example to make gecode crash. I used the "sat"
example given with Gecode, and only deal with this example (no matter if the
other examples don't work anymore).
My problem is reproducible by applying the patch attached in this mail to
Gecode 3.2.2. Then, I configured and compiled Gecode with the following
commands:

./configure --enable-debug --enable-audit make

The test problem can be launched by copying the test2.cnf file (attached in
the mail) in the gecode directory and executing the command:
./examples/sat test2.cnf

If I use a debugger I get:

Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0x000000020000001b
0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
core.hpp:2328
2328        return _prev;
(gdb) bt
#0  0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
core.hpp:2328
#1  0x000000010146e0be in
Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (this=0x101896350,
x=0x101877698, sub=@0x7fff5fbfece0) at core.hpp:3295
#2  0x000000010146e1d9 in
Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (home=@0x101503f80,
sub=@0x7fff5fbfece0) at core.hpp:3314
#3  0x000000010146e4b4 in Gecode::Space::update (this=0x101503f80,
sub=0x101888798) at var-imp.hpp:343
#4  0x000000010146bae7 in Gecode::Space::_clone (this=0x101503e20,
share=true) at gecode/kernel/core.cpp:481
#5  0x000000010011b58b in Gecode::Space::clone (this=0x101503e20,
share=true) at core.hpp:2465
#6  0x000000010011c2c0 in Gecode::Search::Sequential::Path::recompute
(this=0x101503798, d=@0x1015037b8, a_d=2, stat=@0x101503718) at path.hh:305
#7  0x000000010011c5be in Gecode::Search::Sequential::DFS::next
(this=0x101503718) at dfs.hh:146
#8  0x000000010011c615 in
Gecode::Search::WorkerToEngine<Gecode::Search::Sequential::DFS>::next
(this=0x101503710) at support.hh:74
#9  0x0000000100007ed2 in Gecode::DFS<Sat>::next (this=0x7fff5fbff070) at
dfs.hpp:53 #10 0x000000010000811b in
Gecode::Driver::ScriptBase<Gecode::Space>::run<Sat, Gecode::DFS, SatOptions>
(o=@0x7fff5fbff1a0) at script.hpp:198
#11 0x0000000100001a34 in main (argc=1, argv=0x7fff5fbff4f0) at
examples/sat.cpp:256

I probably made an obvious mistake, but I can not see.
Thanks for your help,

Cheers,
Vincent

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203




From tack at ps.uni-sb.de  Mon Dec 14 13:21:19 2009
From: tack at ps.uni-sb.de (Guido Tack)
Date: Mon, 14 Dec 2009 13:21:19 +0100
Subject: [gecode-users] Server migration...
In-Reply-To: <003201ca7c9f$9468c960$bd3a5c20$@se>
References: <009001ca6eb4$874adf00$95e09d00$@se>
	<003801ca6f61$c239d000$46ad7000$@se>
	<BC6ACDE4-AC18-4BB9-AE56-3D44FB8B766E@elet.polimi.it>
	<003201ca7c9f$9468c960$bd3a5c20$@se>
Message-ID: <24278690-C5A3-4A82-ABC9-C211446B7AEF@ps.uni-sb.de>

Hi,

have you tried a fresh checkout yet?  I couldn't find any other problem, but it might have something to do with authentication.

Cheers,
	Guido

Christian Schulte wrote:

> Hi Stefano,
> 
> thanks for letting us know: that's for Guido to look at (but he is awayish).
> 
> Cheers
> Christian
> 
> --
> Christian Schulte, www.ict.kth.se/~cschulte/
> 
> 
> -----Original Message-----
> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
> Of Stefano Gualandi
> Sent: Saturday, December 12, 2009 9:14 AM
> To: gecode gecode
> Subject: Re: [gecode-users] Server migration...
> 
> Hi Christian,
> this morning I tried to update my trunk version, for the first time after
> the server migration, and something went wrong (see below).
> I guess a new check-out would solve the problem, but maybe your are
> interested anyway.
> 
> cheers,
> Stefano
> 
> 
> 
> ~/Programming/C++/Gecode/trunk $ svn update
> 
> Error validating server certificate for 'https://svn.gecode.org:443':
> - The certificate is not issued by a trusted authority. Use the
>   fingerprint to validate the certificate manually!
> - The certificate hostname does not match.
> Certificate information:
> - Hostname: localhost.localdomain
> - Valid: from Mon, 05 Oct 2009 09:40:21 GMT until Thu, 03 Oct 2019 09:40:21
> GMT
> - Issuer: localhost.localdomain
> - Fingerprint: 80:34:c4:c2:3a:d9:ac:fd:0c:00:f5:7f:b3:b8:29:f5:bb:53:0a:5f
> (R)eject, accept (t)emporarily or accept (p)ermanently? p
> A    test/int/sequence.cpp
> U    test/int/arithmetic.cpp
> svn: Server sent unexpected return value (403 Forbidden) in response to
> OPTIONS request for 'https://svn.gecode.org/svn'
> 
> ~/Programming/C++/Gecode/trunk $
> 
> 
> 
> 
> On Nov 27, 2009, at 14:01 PM, Christian Schulte wrote:
> 
>> Dear all,
>> 
>> the server migration is done. So everything should work as before. Please
> let us know if anything does not work as expected.
>> 
>> All the best
>> Christian
>> 
>> --
>> Christian Schulte, www.ict.kth.se/~cschulte/
>> 
>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
> Of Christian Schulte
>> Sent: Thursday, November 26, 2009 5:22 PM
>> To: 'gecode gecode'
>> Subject: [gecode-users] Server migration...
>> 
>> Dear all,
>> 
>> We are in the process of migrating gecode.org to a new server. Please
> expect some hick-ups in the near future. Right now, we are migrating the
> svn, so svn access will not be possible for some time. We will let you know
> when svn migration is done and also about other quirks to come.
>> 
>> Sorry for any inconvenience.
>> 
>> Christian
>> 
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org
>> https://www.gecode.org/mailman/listinfo/gecode-users
> 
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users
> 
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users



From gualandi at elet.polimi.it  Mon Dec 14 13:36:39 2009
From: gualandi at elet.polimi.it (Stefano Gualandi)
Date: Mon, 14 Dec 2009 13:36:39 +0100
Subject: [gecode-users] Server migration...
In-Reply-To: <24278690-C5A3-4A82-ABC9-C211446B7AEF@ps.uni-sb.de>
References: <009001ca6eb4$874adf00$95e09d00$@se>
	<003801ca6f61$c239d000$46ad7000$@se>
	<BC6ACDE4-AC18-4BB9-AE56-3D44FB8B766E@elet.polimi.it>
	<003201ca7c9f$9468c960$bd3a5c20$@se>
	<24278690-C5A3-4A82-ABC9-C211446B7AEF@ps.uni-sb.de>
Message-ID: <CB9CB536-F73B-41E9-89D7-6B5D5D3DFD6C@elet.polimi.it>

Hi Guido,
the fresh checkout works correctly, thanks.

The problem might be related with the SVN version. This what different machines give:

1. MacBook, OS X 10.6, SVN 1.6.5 (r38866) -> does not update
2. Ubuntu 8.04 LTS 64 bits, SVN 1.5.1 (r32289) -> does not update
3. Ubuntu 8.04 LTS, SVN 1.4.6 (r28521) -> update correctly

Maybe it is related with the version of SVN on your server.

cheers,
Stefano



On Dec 14, 2009, at 13:21 PM, Guido Tack wrote:

> Hi,
> 
> have you tried a fresh checkout yet?  I couldn't find any other problem, but it might have something to do with authentication.
> 
> Cheers,
> 	Guido
> 
> Christian Schulte wrote:
> 
>> Hi Stefano,
>> 
>> thanks for letting us know: that's for Guido to look at (but he is awayish).
>> 
>> Cheers
>> Christian
>> 
>> --
>> Christian Schulte, www.ict.kth.se/~cschulte/
>> 
>> 
>> -----Original Message-----
>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
>> Of Stefano Gualandi
>> Sent: Saturday, December 12, 2009 9:14 AM
>> To: gecode gecode
>> Subject: Re: [gecode-users] Server migration...
>> 
>> Hi Christian,
>> this morning I tried to update my trunk version, for the first time after
>> the server migration, and something went wrong (see below).
>> I guess a new check-out would solve the problem, but maybe your are
>> interested anyway.
>> 
>> cheers,
>> Stefano
>> 
>> 
>> 
>> ~/Programming/C++/Gecode/trunk $ svn update
>> 
>> Error validating server certificate for 'https://svn.gecode.org:443':
>> - The certificate is not issued by a trusted authority. Use the
>>  fingerprint to validate the certificate manually!
>> - The certificate hostname does not match.
>> Certificate information:
>> - Hostname: localhost.localdomain
>> - Valid: from Mon, 05 Oct 2009 09:40:21 GMT until Thu, 03 Oct 2019 09:40:21
>> GMT
>> - Issuer: localhost.localdomain
>> - Fingerprint: 80:34:c4:c2:3a:d9:ac:fd:0c:00:f5:7f:b3:b8:29:f5:bb:53:0a:5f
>> (R)eject, accept (t)emporarily or accept (p)ermanently? p
>> A    test/int/sequence.cpp
>> U    test/int/arithmetic.cpp
>> svn: Server sent unexpected return value (403 Forbidden) in response to
>> OPTIONS request for 'https://svn.gecode.org/svn'
>> 
>> ~/Programming/C++/Gecode/trunk $
>> 
>> 
>> 
>> 
>> On Nov 27, 2009, at 14:01 PM, Christian Schulte wrote:
>> 
>>> Dear all,
>>> 
>>> the server migration is done. So everything should work as before. Please
>> let us know if anything does not work as expected.
>>> 
>>> All the best
>>> Christian
>>> 
>>> --
>>> Christian Schulte, www.ict.kth.se/~cschulte/
>>> 
>>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
>> Of Christian Schulte
>>> Sent: Thursday, November 26, 2009 5:22 PM
>>> To: 'gecode gecode'
>>> Subject: [gecode-users] Server migration...
>>> 
>>> Dear all,
>>> 
>>> We are in the process of migrating gecode.org to a new server. Please
>> expect some hick-ups in the near future. Right now, we are migrating the
>> svn, so svn access will not be possible for some time. We will let you know
>> when svn migration is done and also about other quirks to come.
>>> 
>>> Sorry for any inconvenience.
>>> 
>>> Christian
>>> 
>>> _______________________________________________
>>> Gecode users mailing list
>>> users at gecode.org
>>> https://www.gecode.org/mailman/listinfo/gecode-users
>> 
>> 
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org
>> https://www.gecode.org/mailman/listinfo/gecode-users
>> 
>> 
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org
>> https://www.gecode.org/mailman/listinfo/gecode-users
> 



From Vincent.Barichard at univ-angers.fr  Mon Dec 14 20:09:46 2009
From: Vincent.Barichard at univ-angers.fr (Vincent Barichard)
Date: Mon, 14 Dec 2009 20:09:46 +0100
Subject: [gecode-users] Propagation condition and cloning
In-Reply-To: <001701ca7ca9$32f20700$98d61500$@se>
References: <7BEAD7EE-9B1D-4CCE-91AB-CDC65919629E@univ-angers.fr>
	<001701ca7ca9$32f20700$98d61500$@se>
Message-ID: <6677E6A9-B603-45E5-8D7C-B70EF37F12E8@univ-angers.fr>

Of course, you are right ! I confused with the b0 and b1 names used in the BinOrTrue (and others) propagator.
I spent the whole Week-end on it without noticing it. Thank you very much, it works now :D

I can now go forward and continue my work :)

Cheers,
Vincent


Le 14 d?c. 2009 ? 11:35, Christian Schulte a ?crit :

> Hmmm,
> 
> the first five lines in the patch look already fishy:
> 
> --- gecode/int/bool/clause.hpp	2009-10-14 12:19:49.000000000 +0200
> +++ gecode/int/bool/clause.hpp	2009-12-13 23:46:53.000000000 +0100
> @@ -50,6 +50,8 @@
>   (home,x0[x0.size()-1],y0[y0.size()-1]), x(x0), y(y0) {
>     assert((x.size() > 0) && (y.size() > 0));
>     x.size(x.size()-1); y.size(y.size()-1);
> +    x0.subscribe(home,*this,PC_BOOL_SAME,false);
> +    x1.subscribe(home,*this,PC_BOOL_SAME,false);
>   }
> 
> Here x0 in x0.subscribe refers to the argument passed to the constructor.
> You assume it refers to the member, right?
> 
> Yep ;-)
> Christian
> 
> --
> Christian Schulte, www.ict.kth.se/~cschulte/
> 
> 
> -----Original Message-----
> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
> Of Vincent Barichard
> Sent: Monday, December 14, 2009 12:33 AM
> To: gecode list
> Subject: [gecode-users] Propagation condition and cloning
> 
> Hi Everyone,
> 
> I would like to put another Propagation Condition in BoolVarImp. You gave me
> good advice on how to process. For a first step, I just wanted to make some
> test. So I first modified bool.vis and add this new Propagation Condition.
> Then I tried to make existing propagators subscribe to this new propagation
> condition (without scheduling propagators and sending the corresponding
> events). Unfortunately, I failed to achieved this first step. Indeed, some
> problems occur during cloning.
> 
> I first thought that It was a problem with the rewriting of propagator
> during cloning. Indeed, I didn't update all propagators, so it can't be
> possible to change a propagator by another one which doesn't subscribe to
> the same propagation conditions than the original one. 
> I disabled the rewrite of a propagator by another propagator from a
> different class during cloning. But I still have problems. I tried many
> things, without success and now I have no more ideas.
> 
> For now, I just want to understand why I can't make it work. For this
> purpose, I designed an example to make gecode crash. I used the "sat"
> example given with Gecode, and only deal with this example (no matter if the
> other examples don't work anymore).
> My problem is reproducible by applying the patch attached in this mail to
> Gecode 3.2.2. Then, I configured and compiled Gecode with the following
> commands:
> 
> ./configure --enable-debug --enable-audit make
> 
> The test problem can be launched by copying the test2.cnf file (attached in
> the mail) in the gecode directory and executing the command:
> ./examples/sat test2.cnf
> 
> If I use a debugger I get:
> 
> Program received signal EXC_BAD_ACCESS, Could not access memory.
> Reason: KERN_INVALID_ADDRESS at address: 0x000000020000001b
> 0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
> core.hpp:2328
> 2328        return _prev;
> (gdb) bt
> #0  0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
> core.hpp:2328
> #1  0x000000010146e0be in
> Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (this=0x101896350,
> x=0x101877698, sub=@0x7fff5fbfece0) at core.hpp:3295
> #2  0x000000010146e1d9 in
> Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (home=@0x101503f80,
> sub=@0x7fff5fbfece0) at core.hpp:3314
> #3  0x000000010146e4b4 in Gecode::Space::update (this=0x101503f80,
> sub=0x101888798) at var-imp.hpp:343
> #4  0x000000010146bae7 in Gecode::Space::_clone (this=0x101503e20,
> share=true) at gecode/kernel/core.cpp:481
> #5  0x000000010011b58b in Gecode::Space::clone (this=0x101503e20,
> share=true) at core.hpp:2465
> #6  0x000000010011c2c0 in Gecode::Search::Sequential::Path::recompute
> (this=0x101503798, d=@0x1015037b8, a_d=2, stat=@0x101503718) at path.hh:305
> #7  0x000000010011c5be in Gecode::Search::Sequential::DFS::next
> (this=0x101503718) at dfs.hh:146
> #8  0x000000010011c615 in
> Gecode::Search::WorkerToEngine<Gecode::Search::Sequential::DFS>::next
> (this=0x101503710) at support.hh:74
> #9  0x0000000100007ed2 in Gecode::DFS<Sat>::next (this=0x7fff5fbff070) at
> dfs.hpp:53 #10 0x000000010000811b in
> Gecode::Driver::ScriptBase<Gecode::Space>::run<Sat, Gecode::DFS, SatOptions>
> (o=@0x7fff5fbff1a0) at script.hpp:198
> #11 0x0000000100001a34 in main (argc=1, argv=0x7fff5fbff4f0) at
> examples/sat.cpp:256
> 
> I probably made an obvious mistake, but I can not see.
> Thanks for your help,
> 
> Cheers,
> Vincent
> 
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
> 

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203



From cschulte at kth.se  Mon Dec 14 20:16:47 2009
From: cschulte at kth.se (Christian Schulte)
Date: Mon, 14 Dec 2009 20:16:47 +0100
Subject: [gecode-users] Propagation condition and cloning
In-Reply-To: <6677E6A9-B603-45E5-8D7C-B70EF37F12E8@univ-angers.fr>
References: <7BEAD7EE-9B1D-4CCE-91AB-CDC65919629E@univ-angers.fr>
	<001701ca7ca9$32f20700$98d61500$@se>
	<6677E6A9-B603-45E5-8D7C-B70EF37F12E8@univ-angers.fr>
Message-ID: <001401ca7cf1$fb997060$f2cc5120$@se>

Yep, here comes my year-long training from marking exams... Unfortunately,
that's what I am doing right now again...

Christian

--
Christian Schulte, web.ict.kth.se/~cschulte/


-----Original Message-----
From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr] 
Sent: Monday, December 14, 2009 8:10 PM
To: Christian Schulte
Cc: 'gecode list'
Subject: Re: [gecode-users] Propagation condition and cloning

Of course, you are right ! I confused with the b0 and b1 names used in the
BinOrTrue (and others) propagator.
I spent the whole Week-end on it without noticing it. Thank you very much,
it works now :D

I can now go forward and continue my work :)

Cheers,
Vincent


Le 14 d?c. 2009 ? 11:35, Christian Schulte a ?crit :

> Hmmm,
> 
> the first five lines in the patch look already fishy:
> 
> --- gecode/int/bool/clause.hpp	2009-10-14 12:19:49.000000000 +0200
> +++ gecode/int/bool/clause.hpp	2009-12-13 23:46:53.000000000 +0100
> @@ -50,6 +50,8 @@
>   (home,x0[x0.size()-1],y0[y0.size()-1]), x(x0), y(y0) {
>     assert((x.size() > 0) && (y.size() > 0));
>     x.size(x.size()-1); y.size(y.size()-1);
> +    x0.subscribe(home,*this,PC_BOOL_SAME,false);
> +    x1.subscribe(home,*this,PC_BOOL_SAME,false);
>   }
> 
> Here x0 in x0.subscribe refers to the argument passed to the constructor.
> You assume it refers to the member, right?
> 
> Yep ;-)
> Christian
> 
> --
> Christian Schulte, www.ict.kth.se/~cschulte/
> 
> 
> -----Original Message-----
> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
> Of Vincent Barichard
> Sent: Monday, December 14, 2009 12:33 AM
> To: gecode list
> Subject: [gecode-users] Propagation condition and cloning
> 
> Hi Everyone,
> 
> I would like to put another Propagation Condition in BoolVarImp. You gave
me
> good advice on how to process. For a first step, I just wanted to make
some
> test. So I first modified bool.vis and add this new Propagation Condition.
> Then I tried to make existing propagators subscribe to this new
propagation
> condition (without scheduling propagators and sending the corresponding
> events). Unfortunately, I failed to achieved this first step. Indeed, some
> problems occur during cloning.
> 
> I first thought that It was a problem with the rewriting of propagator
> during cloning. Indeed, I didn't update all propagators, so it can't be
> possible to change a propagator by another one which doesn't subscribe to
> the same propagation conditions than the original one. 
> I disabled the rewrite of a propagator by another propagator from a
> different class during cloning. But I still have problems. I tried many
> things, without success and now I have no more ideas.
> 
> For now, I just want to understand why I can't make it work. For this
> purpose, I designed an example to make gecode crash. I used the "sat"
> example given with Gecode, and only deal with this example (no matter if
the
> other examples don't work anymore).
> My problem is reproducible by applying the patch attached in this mail to
> Gecode 3.2.2. Then, I configured and compiled Gecode with the following
> commands:
> 
> ./configure --enable-debug --enable-audit make
> 
> The test problem can be launched by copying the test2.cnf file (attached
in
> the mail) in the gecode directory and executing the command:
> ./examples/sat test2.cnf
> 
> If I use a debugger I get:
> 
> Program received signal EXC_BAD_ACCESS, Could not access memory.
> Reason: KERN_INVALID_ADDRESS at address: 0x000000020000001b
> 0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
> core.hpp:2328
> 2328        return _prev;
> (gdb) bt
> #0  0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
> core.hpp:2328
> #1  0x000000010146e0be in
> Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (this=0x101896350,
> x=0x101877698, sub=@0x7fff5fbfece0) at core.hpp:3295
> #2  0x000000010146e1d9 in
> Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (home=@0x101503f80,
> sub=@0x7fff5fbfece0) at core.hpp:3314
> #3  0x000000010146e4b4 in Gecode::Space::update (this=0x101503f80,
> sub=0x101888798) at var-imp.hpp:343
> #4  0x000000010146bae7 in Gecode::Space::_clone (this=0x101503e20,
> share=true) at gecode/kernel/core.cpp:481
> #5  0x000000010011b58b in Gecode::Space::clone (this=0x101503e20,
> share=true) at core.hpp:2465
> #6  0x000000010011c2c0 in Gecode::Search::Sequential::Path::recompute
> (this=0x101503798, d=@0x1015037b8, a_d=2, stat=@0x101503718) at
path.hh:305
> #7  0x000000010011c5be in Gecode::Search::Sequential::DFS::next
> (this=0x101503718) at dfs.hh:146
> #8  0x000000010011c615 in
> Gecode::Search::WorkerToEngine<Gecode::Search::Sequential::DFS>::next
> (this=0x101503710) at support.hh:74
> #9  0x0000000100007ed2 in Gecode::DFS<Sat>::next (this=0x7fff5fbff070) at
> dfs.hpp:53 #10 0x000000010000811b in
> Gecode::Driver::ScriptBase<Gecode::Space>::run<Sat, Gecode::DFS,
SatOptions>
> (o=@0x7fff5fbff1a0) at script.hpp:198
> #11 0x0000000100001a34 in main (argc=1, argv=0x7fff5fbff4f0) at
> examples/sat.cpp:256
> 
> I probably made an obvious mistake, but I can not see.
> Thanks for your help,
> 
> Cheers,
> Vincent
> 
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
> 

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203




From holger.winnemoeller at gmail.com  Tue Dec 15 02:01:19 2009
From: holger.winnemoeller at gmail.com (Holger Winnemoeller)
Date: Mon, 14 Dec 2009 17:01:19 -0800
Subject: [gecode-users] Help: Howto combine sets and value constraints?
Message-ID: <8eb8d34d0912141701i5813ae4tefa792f065bb863@mail.gmail.com>

I am trying to create a solver that (as a toy explanation) can create sets
with
certain properties, such as:

1) The resulting set size is specified
2) The resulting set contains a certain number of items that belong to a
  "special" group
3) The total "weight" of items is below a certain threshold

I can easily enough create constraints for 1) and 2), but I would love to
get
some help in how I integrate constraint 3) into the mix. Supposedly I would
create a set of variables for the weights and specify a constraint on the
sum of
these weights. But I have no idea about how to express in Gecode that I want
to
sum up the weights of exactly the ids that are in the currently selected
set.

My approach to doing 1)&2) is attached below. The question is: How do I
specify
that the total weight of selected items should be less than, say
"maxWeight".

(Note: This is not a homework problem :-) It's an abstraction of a set
selector
that I want to include in a user interface for suggesting available sets to
users)

Thanks for your time,
Holger.
========================< main.cpp >===========================
#include <gecode/set.hh>
#include <gecode/support.hh>
#include <gecode/kernel.hh>
#include <gecode/search.hh>

using namespace Gecode;

// Some data to play with
int numItems = 10;                    // total number of items in inventory
int numSpecialItems = 4;            // number of items in inventory with
"special" attribute
int numRequestedSize = 6;            // requested size of result set
int numRequestedSpecialSize = 2;    // requested size of "special" items in
result set
float maxWeight = 1.8f;                // requested maximum weight of all
items in result set (NOT IMPLEMENTED!)

int allItems[] = {0,1,2,3,4,5,6,7,8,9}; // 10 items (their id's)
float itemWeights[] = {0.1f, 0.5f, 0.2f, 0.2f, 0.6f, 0.8f, 1.0f, 0.3f, 0.7f,
0.6f}; // their associated weights
int specialItems[] = {2,5,8,9}; // a subset of items having the attribute
"special"

// Little helper function
bool isInSet(int id, int set[], int setSize)
{
    for(int i=0; i<setSize; ++i)
        if(id == set[i]) return true;
    return false;
}

// A "Minimal" space definition for the problem
class MiniSpace: public Space
{
        SetVarArray mSetStore;
public:
    MiniSpace(){
        // Create a SetVariable array (only need one element really, but
this allows me to define the domain in one step)
        mSetStore = SetVarArray(*this, 1, IntSet::empty, 0, numItems);
        SetVar resultSet = mSetStore[0]; // get the one variable that was
defined in the above line

        // impose the constraint that we only want "numRequestedSize" items
in the result set
        cardinality(*this, resultSet, numRequestedSize, numRequestedSize);

        // now impose the fact that we want exactly
"numRequestedSpecialSize" items coming from the special set
        // 1.) Create a new set domain that represents the "special" items
        IntSet specialSet(specialItems, numSpecialItems);
        // 2.) Create a set variable that we'll associate with that set
later on
        SetVar specialSelected(*this);
        // 3.) Set "specialSelected" to the intersection of whatever a
possible solution is, and
        //     the "specialSet". This ensures that we can talk about items
that are included
        //     in the solution, but also belong to the special set
        rel(*this, resultSet, SOT_INTER, specialSet, SRT_EQ,
specialSelected);
        // 4.) Now ensure that we only have "numRequestedSpecialSize" of
these overlapping items
        cardinality(*this, specialSelected, numRequestedSpecialSize,
numRequestedSpecialSize);

        // Given these constraints, branch
        branch(*this, mSetStore, SET_VAR_NONE, SET_VAL_MIN_INC);
    }
    MiniSpace(bool share, MiniSpace& s) : Space(share, s)
{mSetStore.update(*this, share, s.mSetStore);}
    virtual Space* copy(bool share) {return new MiniSpace(share, *this);}
    void print() const
    {
        int countAsSpecial = 0;
        for(SetVarGlbValues d(mSetStore[0]);d();++d)
        {
            int id = d.val();
            if(isInSet(id, specialItems, numSpecialItems)) countAsSpecial++;
            std::cout << id << " ";
        } // for
        std::cout << ". Nr. of specials: " << countAsSpecial;
    }
};

int main(int argc, char* argv[])
{
    // Run the problem
    MiniSpace problem; // space instance
    //Search::Options options
    DFS<MiniSpace> solver (&problem);
    int count=0;
    while(true){
        MiniSpace* solution = solver.next();
        if(!solution) break;
        std::cout << "Solution Nr." << count++ << std::endl;
        solution->print();
        std::cout << std::endl;
        delete solution;
    }
    std::cout << "Done..." << std::endl;
    return 0;
}
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091214/4c6293a9/attachment-0001.htm>

From tack at ps.uni-sb.de  Tue Dec 15 10:25:08 2009
From: tack at ps.uni-sb.de (Guido Tack)
Date: Tue, 15 Dec 2009 10:25:08 +0100
Subject: [gecode-users] Help: Howto combine sets and value constraints?
In-Reply-To: <8eb8d34d0912141701i5813ae4tefa792f065bb863@mail.gmail.com>
References: <8eb8d34d0912141701i5813ae4tefa792f065bb863@mail.gmail.com>
Message-ID: <E7531CAD-803A-4759-8EB5-0143B2163555@ps.uni-sb.de>

Hi,

Holger Winnemoeller wrote:

> I am trying to create a solver that (as a toy explanation) can create sets with
> certain properties, such as:
> 
> 1) The resulting set size is specified
> 2) The resulting set contains a certain number of items that belong to a
>   "special" group
> 3) The total "weight" of items is below a certain threshold
> 
> I can easily enough create constraints for 1) and 2), but I would love to get
> some help in how I integrate constraint 3) into the mix. Supposedly I would
> create a set of variables for the weights and specify a constraint on the sum of
> these weights. But I have no idea about how to express in Gecode that I want to
> sum up the weights of exactly the ids that are in the currently selected set. 


have a look at the weights constraint:
http://www.gecode.org/doc-latest/reference/group__TaskModelSetConnect.html#g7c739a2d3c830174ad5e58b77292f6d1

It should do exactly what you describe.

Cheers,
	Guido



From Vincent.Barichard at univ-angers.fr  Tue Dec 15 17:07:53 2009
From: Vincent.Barichard at univ-angers.fr (Vincent Barichard)
Date: Tue, 15 Dec 2009 17:07:53 +0100
Subject: [gecode-users] Propagation condition and cloning
In-Reply-To: <001401ca7cf1$fb997060$f2cc5120$@se>
References: <7BEAD7EE-9B1D-4CCE-91AB-CDC65919629E@univ-angers.fr>
	<001701ca7ca9$32f20700$98d61500$@se>
	<6677E6A9-B603-45E5-8D7C-B70EF37F12E8@univ-angers.fr>
	<001401ca7cf1$fb997060$f2cc5120$@se>
Message-ID: <16C7C612-B76A-4E96-BDA6-AD5CB39CF1A9@univ-angers.fr>

Hi,

I wonder if the same issue occurs here ? "x" should refer to the member ?

In gecode/int/bool/or.hpp (766)

  template<class VX, class VY>
  forceinline
  NaryOr<VX,VY>::NaryOr(Home home, ViewArray<VX>& x, VY y)
    : MixNaryOnePropagator<VX,PC_BOOL_NONE,VY,PC_BOOL_VAL>(home,x,y),
      n_zero(0), c(home) {
    x.subscribe(home,*new (home) Advisor(home,*this,c));
  }

Cheers,
Vincent

Le 14 d?c. 2009 ? 20:16, Christian Schulte a ?crit :

> Yep, here comes my year-long training from marking exams... Unfortunately,
> that's what I am doing right now again...
> 
> Christian
> 
> --
> Christian Schulte, web.ict.kth.se/~cschulte/
> 
> 
> -----Original Message-----
> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr] 
> Sent: Monday, December 14, 2009 8:10 PM
> To: Christian Schulte
> Cc: 'gecode list'
> Subject: Re: [gecode-users] Propagation condition and cloning
> 
> Of course, you are right ! I confused with the b0 and b1 names used in the
> BinOrTrue (and others) propagator.
> I spent the whole Week-end on it without noticing it. Thank you very much,
> it works now :D
> 
> I can now go forward and continue my work :)
> 
> Cheers,
> Vincent
> 
> 
> Le 14 d?c. 2009 ? 11:35, Christian Schulte a ?crit :
> 
>> Hmmm,
>> 
>> the first five lines in the patch look already fishy:
>> 
>> --- gecode/int/bool/clause.hpp	2009-10-14 12:19:49.000000000 +0200
>> +++ gecode/int/bool/clause.hpp	2009-12-13 23:46:53.000000000 +0100
>> @@ -50,6 +50,8 @@
>>  (home,x0[x0.size()-1],y0[y0.size()-1]), x(x0), y(y0) {
>>    assert((x.size() > 0) && (y.size() > 0));
>>    x.size(x.size()-1); y.size(y.size()-1);
>> +    x0.subscribe(home,*this,PC_BOOL_SAME,false);
>> +    x1.subscribe(home,*this,PC_BOOL_SAME,false);
>>  }
>> 
>> Here x0 in x0.subscribe refers to the argument passed to the constructor.
>> You assume it refers to the member, right?
>> 
>> Yep ;-)
>> Christian
>> 
>> --
>> Christian Schulte, www.ict.kth.se/~cschulte/
>> 
>> 
>> -----Original Message-----
>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
>> Of Vincent Barichard
>> Sent: Monday, December 14, 2009 12:33 AM
>> To: gecode list
>> Subject: [gecode-users] Propagation condition and cloning
>> 
>> Hi Everyone,
>> 
>> I would like to put another Propagation Condition in BoolVarImp. You gave
> me
>> good advice on how to process. For a first step, I just wanted to make
> some
>> test. So I first modified bool.vis and add this new Propagation Condition.
>> Then I tried to make existing propagators subscribe to this new
> propagation
>> condition (without scheduling propagators and sending the corresponding
>> events). Unfortunately, I failed to achieved this first step. Indeed, some
>> problems occur during cloning.
>> 
>> I first thought that It was a problem with the rewriting of propagator
>> during cloning. Indeed, I didn't update all propagators, so it can't be
>> possible to change a propagator by another one which doesn't subscribe to
>> the same propagation conditions than the original one. 
>> I disabled the rewrite of a propagator by another propagator from a
>> different class during cloning. But I still have problems. I tried many
>> things, without success and now I have no more ideas.
>> 
>> For now, I just want to understand why I can't make it work. For this
>> purpose, I designed an example to make gecode crash. I used the "sat"
>> example given with Gecode, and only deal with this example (no matter if
> the
>> other examples don't work anymore).
>> My problem is reproducible by applying the patch attached in this mail to
>> Gecode 3.2.2. Then, I configured and compiled Gecode with the following
>> commands:
>> 
>> ./configure --enable-debug --enable-audit make
>> 
>> The test problem can be launched by copying the test2.cnf file (attached
> in
>> the mail) in the gecode directory and executing the command:
>> ./examples/sat test2.cnf
>> 
>> If I use a debugger I get:
>> 
>> Program received signal EXC_BAD_ACCESS, Could not access memory.
>> Reason: KERN_INVALID_ADDRESS at address: 0x000000020000001b
>> 0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
>> core.hpp:2328
>> 2328        return _prev;
>> (gdb) bt
>> #0  0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
>> core.hpp:2328
>> #1  0x000000010146e0be in
>> Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (this=0x101896350,
>> x=0x101877698, sub=@0x7fff5fbfece0) at core.hpp:3295
>> #2  0x000000010146e1d9 in
>> Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (home=@0x101503f80,
>> sub=@0x7fff5fbfece0) at core.hpp:3314
>> #3  0x000000010146e4b4 in Gecode::Space::update (this=0x101503f80,
>> sub=0x101888798) at var-imp.hpp:343
>> #4  0x000000010146bae7 in Gecode::Space::_clone (this=0x101503e20,
>> share=true) at gecode/kernel/core.cpp:481
>> #5  0x000000010011b58b in Gecode::Space::clone (this=0x101503e20,
>> share=true) at core.hpp:2465
>> #6  0x000000010011c2c0 in Gecode::Search::Sequential::Path::recompute
>> (this=0x101503798, d=@0x1015037b8, a_d=2, stat=@0x101503718) at
> path.hh:305
>> #7  0x000000010011c5be in Gecode::Search::Sequential::DFS::next
>> (this=0x101503718) at dfs.hh:146
>> #8  0x000000010011c615 in
>> Gecode::Search::WorkerToEngine<Gecode::Search::Sequential::DFS>::next
>> (this=0x101503710) at support.hh:74
>> #9  0x0000000100007ed2 in Gecode::DFS<Sat>::next (this=0x7fff5fbff070) at
>> dfs.hpp:53 #10 0x000000010000811b in
>> Gecode::Driver::ScriptBase<Gecode::Space>::run<Sat, Gecode::DFS,
> SatOptions>
>> (o=@0x7fff5fbff1a0) at script.hpp:198
>> #11 0x0000000100001a34 in main (argc=1, argv=0x7fff5fbff4f0) at
>> examples/sat.cpp:256
>> 
>> I probably made an obvious mistake, but I can not see.
>> Thanks for your help,
>> 
>> Cheers,
>> Vincent
>> 
>> Vincent Barichard         Universit? d'Angers (LERIA)
>> Tel: 02 41 73 52 06      D?partement Informatique
>> Fax: 02 41 73 50 73     H203
>> 
> 
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
> 
> 
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203



From cschulte at kth.se  Tue Dec 15 17:18:47 2009
From: cschulte at kth.se (Christian Schulte)
Date: Tue, 15 Dec 2009 17:18:47 +0100
Subject: [gecode-users] Propagation condition and cloning
In-Reply-To: <16C7C612-B76A-4E96-BDA6-AD5CB39CF1A9@univ-angers.fr>
References: <7BEAD7EE-9B1D-4CCE-91AB-CDC65919629E@univ-angers.fr>
	<001701ca7ca9$32f20700$98d61500$@se>
	<6677E6A9-B603-45E5-8D7C-B70EF37F12E8@univ-angers.fr>
	<001401ca7cf1$fb997060$f2cc5120$@se>
	<16C7C612-B76A-4E96-BDA6-AD5CB39CF1A9@univ-angers.fr>
Message-ID: <00af01ca7da2$47a59b90$d6f0d2b0$@se>

Here the member and the argument coincides... But maybe I should change it.

Thanks
Christian

--
Christian Schulte, www.ict.kth.se/~cschulte/


-----Original Message-----
From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr] 
Sent: Tuesday, December 15, 2009 5:08 PM
To: Christian Schulte
Cc: 'gecode list'
Subject: Re: [gecode-users] Propagation condition and cloning

Hi,

I wonder if the same issue occurs here ? "x" should refer to the member ?

In gecode/int/bool/or.hpp (766)

  template<class VX, class VY>
  forceinline
  NaryOr<VX,VY>::NaryOr(Home home, ViewArray<VX>& x, VY y)
    : MixNaryOnePropagator<VX,PC_BOOL_NONE,VY,PC_BOOL_VAL>(home,x,y),
      n_zero(0), c(home) {
    x.subscribe(home,*new (home) Advisor(home,*this,c));
  }

Cheers,
Vincent

Le 14 d?c. 2009 ? 20:16, Christian Schulte a ?crit :

> Yep, here comes my year-long training from marking exams... Unfortunately,
> that's what I am doing right now again...
> 
> Christian
> 
> --
> Christian Schulte, web.ict.kth.se/~cschulte/
> 
> 
> -----Original Message-----
> From: Vincent Barichard [mailto:Vincent.Barichard at univ-angers.fr] 
> Sent: Monday, December 14, 2009 8:10 PM
> To: Christian Schulte
> Cc: 'gecode list'
> Subject: Re: [gecode-users] Propagation condition and cloning
> 
> Of course, you are right ! I confused with the b0 and b1 names used in the
> BinOrTrue (and others) propagator.
> I spent the whole Week-end on it without noticing it. Thank you very much,
> it works now :D
> 
> I can now go forward and continue my work :)
> 
> Cheers,
> Vincent
> 
> 
> Le 14 d?c. 2009 ? 11:35, Christian Schulte a ?crit :
> 
>> Hmmm,
>> 
>> the first five lines in the patch look already fishy:
>> 
>> --- gecode/int/bool/clause.hpp	2009-10-14 12:19:49.000000000 +0200
>> +++ gecode/int/bool/clause.hpp	2009-12-13 23:46:53.000000000 +0100
>> @@ -50,6 +50,8 @@
>>  (home,x0[x0.size()-1],y0[y0.size()-1]), x(x0), y(y0) {
>>    assert((x.size() > 0) && (y.size() > 0));
>>    x.size(x.size()-1); y.size(y.size()-1);
>> +    x0.subscribe(home,*this,PC_BOOL_SAME,false);
>> +    x1.subscribe(home,*this,PC_BOOL_SAME,false);
>>  }
>> 
>> Here x0 in x0.subscribe refers to the argument passed to the constructor.
>> You assume it refers to the member, right?
>> 
>> Yep ;-)
>> Christian
>> 
>> --
>> Christian Schulte, www.ict.kth.se/~cschulte/
>> 
>> 
>> -----Original Message-----
>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On
Behalf
>> Of Vincent Barichard
>> Sent: Monday, December 14, 2009 12:33 AM
>> To: gecode list
>> Subject: [gecode-users] Propagation condition and cloning
>> 
>> Hi Everyone,
>> 
>> I would like to put another Propagation Condition in BoolVarImp. You gave
> me
>> good advice on how to process. For a first step, I just wanted to make
> some
>> test. So I first modified bool.vis and add this new Propagation
Condition.
>> Then I tried to make existing propagators subscribe to this new
> propagation
>> condition (without scheduling propagators and sending the corresponding
>> events). Unfortunately, I failed to achieved this first step. Indeed,
some
>> problems occur during cloning.
>> 
>> I first thought that It was a problem with the rewriting of propagator
>> during cloning. Indeed, I didn't update all propagators, so it can't be
>> possible to change a propagator by another one which doesn't subscribe to
>> the same propagation conditions than the original one. 
>> I disabled the rewrite of a propagator by another propagator from a
>> different class during cloning. But I still have problems. I tried many
>> things, without success and now I have no more ideas.
>> 
>> For now, I just want to understand why I can't make it work. For this
>> purpose, I designed an example to make gecode crash. I used the "sat"
>> example given with Gecode, and only deal with this example (no matter if
> the
>> other examples don't work anymore).
>> My problem is reproducible by applying the patch attached in this mail to
>> Gecode 3.2.2. Then, I configured and compiled Gecode with the following
>> commands:
>> 
>> ./configure --enable-debug --enable-audit make
>> 
>> The test problem can be launched by copying the test2.cnf file (attached
> in
>> the mail) in the gecode directory and executing the command:
>> ./examples/sat test2.cnf
>> 
>> If I use a debugger I get:
>> 
>> Program received signal EXC_BAD_ACCESS, Could not access memory.
>> Reason: KERN_INVALID_ADDRESS at address: 0x000000020000001b
>> 0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
>> core.hpp:2328
>> 2328        return _prev;
>> (gdb) bt
>> #0  0x000000010146d908 in Gecode::ActorLink::prev (this=0x200000013) at
>> core.hpp:2328
>> #1  0x000000010146e0be in
>> Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (this=0x101896350,
>> x=0x101877698, sub=@0x7fff5fbfece0) at core.hpp:3295
>> #2  0x000000010146e1d9 in
>> Gecode::VarImp<Gecode::Int::BoolVarImpConf>::update (home=@0x101503f80,
>> sub=@0x7fff5fbfece0) at core.hpp:3314
>> #3  0x000000010146e4b4 in Gecode::Space::update (this=0x101503f80,
>> sub=0x101888798) at var-imp.hpp:343
>> #4  0x000000010146bae7 in Gecode::Space::_clone (this=0x101503e20,
>> share=true) at gecode/kernel/core.cpp:481
>> #5  0x000000010011b58b in Gecode::Space::clone (this=0x101503e20,
>> share=true) at core.hpp:2465
>> #6  0x000000010011c2c0 in Gecode::Search::Sequential::Path::recompute
>> (this=0x101503798, d=@0x1015037b8, a_d=2, stat=@0x101503718) at
> path.hh:305
>> #7  0x000000010011c5be in Gecode::Search::Sequential::DFS::next
>> (this=0x101503718) at dfs.hh:146
>> #8  0x000000010011c615 in
>> Gecode::Search::WorkerToEngine<Gecode::Search::Sequential::DFS>::next
>> (this=0x101503710) at support.hh:74
>> #9  0x0000000100007ed2 in Gecode::DFS<Sat>::next (this=0x7fff5fbff070) at
>> dfs.hpp:53 #10 0x000000010000811b in
>> Gecode::Driver::ScriptBase<Gecode::Space>::run<Sat, Gecode::DFS,
> SatOptions>
>> (o=@0x7fff5fbff1a0) at script.hpp:198
>> #11 0x0000000100001a34 in main (argc=1, argv=0x7fff5fbff4f0) at
>> examples/sat.cpp:256
>> 
>> I probably made an obvious mistake, but I can not see.
>> Thanks for your help,
>> 
>> Cheers,
>> Vincent
>> 
>> Vincent Barichard         Universit? d'Angers (LERIA)
>> Tel: 02 41 73 52 06      D?partement Informatique
>> Fax: 02 41 73 50 73     H203
>> 
> 
> Vincent Barichard         Universit? d'Angers (LERIA)
> Tel: 02 41 73 52 06      D?partement Informatique
> Fax: 02 41 73 50 73     H203
> 
> 
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users

Vincent Barichard         Universit? d'Angers (LERIA)
Tel: 02 41 73 52 06      D?partement Informatique
Fax: 02 41 73 50 73     H203




From holger.winnemoeller at gmail.com  Wed Dec 16 05:21:13 2009
From: holger.winnemoeller at gmail.com (Holger Winnemoeller)
Date: Tue, 15 Dec 2009 20:21:13 -0800
Subject: [gecode-users] Set constraints working for sequential data,
	but not non-sequential 	data. Ideas?
Message-ID: <8eb8d34d0912152021qa354e39ub7f8e728569ed0f9@mail.gmail.com>

*QUESTION: How can I solve the following problem for anything but toy
examples?*

Say, I have the following sets:

All : {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}
subA: {0,1,2,3,4}
subB: {5,6,7,8,9}

If I ask for a subset of "All" which contains 4 elements, of which 2
elements are from "subA" and 2 elements are from "subB", I get a variety of
results, such as
{0,1,5,6}
{0,1,5,7}
...
{3,4,8,9}
...

etc.

This works perfectly fine.

Now, for cases where subA, and  subB are not strictly sequential (i.e.
sorted but non-consecutive numbers)

subA: {4,8,14,16,17}
subB: {0,3,5,10,12}

The system quickly runs out of steam (maybe not for the toy example here,
but for |All| = 100, |subA| = |subB| = 20, asking for 10 items -- see
attached code). Gecode just keeps computing and never seems to find a
solution.

Given that the sub-sets are disjoint a solution should really be trivial in
any case (take 50% of one subset and 50% of the other). However, I don't
want to make the assumption that they are disjoint.

I have attached some demo code for what I am talking about, so you can
experiment with it.

Thanks for your help!

Holger.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091215/0f54715c/attachment.htm>
-------------- next part --------------
#include <gecode/set.hh>
#include <gecode/support.hh>
#include <gecode/kernel.hh>
#include <gecode/search.hh>
#include <vector>
#include <algorithm>

using namespace std;
using namespace Gecode;

#define BROKEN_PROBLEM 1 // will not finish
//#define BROKEN_PROBLEM 0 // works just fine

// A "Minimal" space definition for the problem
class MiniSpace: public Space
{
	SetVarArray mSetStore;
	void CreateAndRequestCategory(int numItemsInCategories, int requestFromEachCategory, vector<int>& allItems)
	{
		vector<int> data (numItemsInCategories); // space to hold items
		for(int i=0; i<numItemsInCategories; ++i) // fill data from allItems
		{
			data[i] = allItems.back();
			allItems.pop_back();
		}

		// sort the items before loading them into Gecode -- not sure if this is necessary
		sort(data.begin(), data.end());

		// 1.) Create a new set domain that holds the "special" items
		IntSet specialSet(&data[0], (int)data.size());
		// 2.) Create a set variable that we'll associate with that set later on
		SetVar specialSelected(*this);
		// 3.) Set "specialSelected" to the intersection of whatever a possible solution is, and
		//     the "specialSet". This ensures that we can talk about items that are included
		//     in the solution, but also belong to the special set
		rel(*this, mSetStore[0], SOT_INTER, specialSet, SRT_EQ, specialSelected);
		// 4.) Now ensure that we only have "requestFromEachCategory" of these overlapping items
		cardinality(*this, specialSelected, requestFromEachCategory, requestFromEachCategory);
	}

public:
	MiniSpace(int problemSize, int numItemsInCategories, int numRequestedSize)
	{
		puts("Setting up problem...");
		// Create a SetVariable array (only need one element really, but this allows me to define the domain in one step)
		mSetStore = SetVarArray(*this, 1, IntSet::empty, 0, problemSize);
		SetVar resultSet = mSetStore[0]; // get the one variable that was defined in the above line

		// impose the constraint that we only want "numRequestedSize" items in the result set
		cardinality(*this, resultSet, numRequestedSize, numRequestedSize);

		// Create two sets of random non-overlapping items from inventory
		vector<int> allItems (problemSize);
		for(int i=0; i<problemSize; ++i) allItems[i] = problemSize-1-i; // init items
#if BROKEN_PROBLEM
		random_shuffle(allItems.begin(), allItems.end()); // shuffle items
#endif
		int requestFromEachCategory = numRequestedSize * 4 / 10;
		CreateAndRequestCategory(numItemsInCategories, requestFromEachCategory, allItems); // one category

		// Create another set of items and request elements from it
		CreateAndRequestCategory(numItemsInCategories, requestFromEachCategory, allItems); // another category

		// Given these constraints, branch
		branch(*this, mSetStore, SET_VAR_NONE, SET_VAL_MIN_INC);
	}
	MiniSpace(bool share, MiniSpace& s) : Space(share, s) {mSetStore.update(*this, share, s.mSetStore);}
	virtual Space* copy(bool share) {return new MiniSpace(share, *this);}
	void print() const
	{
		for(SetVarGlbValues d(mSetStore[0]);d();++d)
			std::cout << d.val() << " ";
	}
};

int main(int argc, char* argv[])
{
	// Run the problem
	//MiniSpace problem (
	//	3000,	// total number of items in inventory
	//	200,	// several sub-inventories (non-overlapping) with X elements each
	//	20		// requesting X items
	//); // space instance

	MiniSpace problem (
		100,	// total number of items in inventory
		20,		// several sub-inventories (non-overlapping) with X elements each
		10		// requesting X items
	); // space instance

	DFS<MiniSpace> solver (&problem);
	int count=0;
	puts("Looking for solutions...");
	while(true){
		MiniSpace* solution = solver.next();
		if(!solution) break;
		std::cout << "Solution Nr." << count++ << std::endl;
		solution->print();
		std::cout << std::endl;
		delete solution;
	}
	std::cout << "Done..." << std::endl;
	system("pause");
	return 0;
}


From zayenz at gmail.com  Wed Dec 16 08:51:25 2009
From: zayenz at gmail.com (Mikael Zayenz Lagerkvist)
Date: Wed, 16 Dec 2009 08:51:25 +0100
Subject: [gecode-users] Set constraints working for sequential data,
	but 	not non-sequential data. Ideas?
In-Reply-To: <8eb8d34d0912152021qa354e39ub7f8e728569ed0f9@mail.gmail.com>
References: <8eb8d34d0912152021qa354e39ub7f8e728569ed0f9@mail.gmail.com>
Message-ID: <63b5c8b00912152351n7d3ea5bcyae3fb7b12afdaded@mail.gmail.com>

Hi,

I just tried your problem, and on my computer (Athlon 64 3500+, Ubuntu
Linux, gcc 4.2, debug-build of Gecode 3.2.2) both versions of your program
produce a lot of solutions in a short time. What kind of system do you use?

The one with shuffled values is not as fast in the beginning, but that is
probably due to weak propagation in combination with a branching heuristic
that tries values not in either set.

Cheers,
Mikael

PS. I would recommend that you use the Driver infrastructure for your
experiments so that you can easily add various limits (max number of
solutions/failures/time) and run the program in Gist. Using Gist is very
good for understanding the behaviour of a Gecode model. Printing the search
statistics for a completed search is also good when comparing model
varieties.

2009/12/16 Holger Winnemoeller <holger.winnemoeller at gmail.com>

> *QUESTION: How can I solve the following problem for anything but toy
> examples?*
>
> Say, I have the following sets:
>
> All : {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}
> subA: {0,1,2,3,4}
> subB: {5,6,7,8,9}
>
> If I ask for a subset of "All" which contains 4 elements, of which 2
> elements are from "subA" and 2 elements are from "subB", I get a variety of
> results, such as
> {0,1,5,6}
> {0,1,5,7}
> ...
> {3,4,8,9}
> ...
>
> etc.
>
> This works perfectly fine.
>
> Now, for cases where subA, and  subB are not strictly sequential (i.e.
> sorted but non-consecutive numbers)
>
> subA: {4,8,14,16,17}
> subB: {0,3,5,10,12}
>
> The system quickly runs out of steam (maybe not for the toy example here,
> but for |All| = 100, |subA| = |subB| = 20, asking for 10 items -- see
> attached code). Gecode just keeps computing and never seems to find a
> solution.
>
> Given that the sub-sets are disjoint a solution should really be trivial in
> any case (take 50% of one subset and 50% of the other). However, I don't
> want to make the assumption that they are disjoint.
>
> I have attached some demo code for what I am talking about, so you can
> experiment with it.
>
> Thanks for your help!
>
> Holger.
>
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users
>
>


-- 
Mikael Zayenz Lagerkvist, http://www.ict.kth.se/~zayenz/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091216/48ffd7f6/attachment-0001.htm>

From zayenz at gmail.com  Wed Dec 16 10:39:32 2009
From: zayenz at gmail.com (Mikael Zayenz Lagerkvist)
Date: Wed, 16 Dec 2009 10:39:32 +0100
Subject: [gecode-users] Set constraints working for sequential data,
	but 	not non-sequential data. Ideas?
In-Reply-To: <63b5c8b00912152351n7d3ea5bcyae3fb7b12afdaded@mail.gmail.com>
References: <8eb8d34d0912152021qa354e39ub7f8e728569ed0f9@mail.gmail.com> 
	<63b5c8b00912152351n7d3ea5bcyae3fb7b12afdaded@mail.gmail.com>
Message-ID: <63b5c8b00912160139p119252cdw4dfc898029b5c98b@mail.gmail.com>

Hi,

I thought a bit more about your model, and my suggestion would be for
you to branch on the set of specialSelected set variables first,
before branching on the resultSet. This will be much more efficient,
since that will decide the values that should be included in resultSet
directly.

Cheers,
Mikael

On Wed, Dec 16, 2009 at 8:51 AM, Mikael Zayenz Lagerkvist
<zayenz at gmail.com> wrote:
> Hi,
> I just tried your problem, and on my computer (Athlon 64 3500+, Ubuntu
> Linux, gcc 4.2, debug-build of Gecode 3.2.2) both versions of your program
> produce a lot of solutions in a short time. What kind of system do you use?
> The one with shuffled values is not as fast in the beginning, but that is
> probably due to weak propagation in combination with a branching heuristic
> that tries values not in either set.
> Cheers,
> Mikael
> PS. I would recommend that you use the Driver infrastructure for your
> experiments so that you can easily add various limits (max number of
> solutions/failures/time) and run the program in Gist. Using Gist is very
> good for understanding the behaviour of a Gecode model. Printing the search
> statistics for a completed search is also good when comparing model
> varieties.
>
> 2009/12/16 Holger Winnemoeller <holger.winnemoeller at gmail.com>
>>
>> QUESTION: How can I solve the following problem for anything but toy
>> examples?
>>
>> Say, I have the following sets:
>>
>> All : {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}
>> subA: {0,1,2,3,4}
>> subB: {5,6,7,8,9}
>>
>> If I ask for a subset of "All" which contains 4 elements, of which 2
>> elements are from "subA" and 2 elements are from "subB", I get a variety of
>> results, such as
>> {0,1,5,6}
>> {0,1,5,7}
>> ...
>> {3,4,8,9}
>> ...
>>
>> etc.
>>
>> This works perfectly fine.
>>
>> Now, for cases where subA, and? subB are not strictly sequential (i.e.
>> sorted but non-consecutive numbers)
>>
>> subA: {4,8,14,16,17}
>> subB: {0,3,5,10,12}
>>
>> The system quickly runs out of steam (maybe not for the toy example here,
>> but for |All| = 100, |subA| = |subB| = 20, asking for 10 items -- see
>> attached code). Gecode just keeps computing and never seems to find a
>> solution.
>>
>> Given that the sub-sets are disjoint a solution should really be trivial
>> in any case (take 50% of one subset and 50% of the other). However, I don't
>> want to make the assumption that they are disjoint.
>>
>> I have attached some demo code for what I am talking about, so you can
>> experiment with it.
>>
>> Thanks for your help!
>>
>> Holger.
>>
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org
>> https://www.gecode.org/mailman/listinfo/gecode-users
>>
>
>
>
> --
> Mikael Zayenz Lagerkvist, http://www.ict.kth.se/~zayenz/
>



-- 
Mikael Zayenz Lagerkvist, http://www.ict.kth.se/~zayenz/


From holger.winnemoeller at gmail.com  Wed Dec 16 21:05:57 2009
From: holger.winnemoeller at gmail.com (Holger Winnemoeller)
Date: Wed, 16 Dec 2009 12:05:57 -0800
Subject: [gecode-users] Set constraints working for sequential data,
	but 	not non-sequential data. Ideas?
In-Reply-To: <63b5c8b00912160139p119252cdw4dfc898029b5c98b@mail.gmail.com>
References: <8eb8d34d0912152021qa354e39ub7f8e728569ed0f9@mail.gmail.com>
	<63b5c8b00912152351n7d3ea5bcyae3fb7b12afdaded@mail.gmail.com>
	<63b5c8b00912160139p119252cdw4dfc898029b5c98b@mail.gmail.com>
Message-ID: <8eb8d34d0912161205j422b82dbu9882744b5b49c1a4@mail.gmail.com>

Mikael,

thank you for your answer! Your second mail was spot-on!

I've added "branch(*this, specialSelected, SET_VAL_MIN_INC);" as the last
line in CreateAndRequestCategory

and the code runs like a charm!

I should really try to get Gist working, as I have a feeling that it will
demystify what to me is currently branching Voodoo.

FYI, my system is Dell Intel Core Duo E8400 @ 3GHz with 4GB of RAM on
WindowsXP professional, running Gecode 3.2.0 (x86). It's interesting, though
maybe not surprising, that Gecode seems to run so much faster on your
system. Do you think it's related more to the version of Gecode, the
machine, or the OS? In any case, the correct answer is obviously not to
upgrade the hardware, but to insert the branching statement :-)

Cheers,
Holger.

On Wed, Dec 16, 2009 at 1:39 AM, Mikael Zayenz Lagerkvist
<zayenz at gmail.com>wrote:

> Hi,
>
> I thought a bit more about your model, and my suggestion would be for
> you to branch on the set of specialSelected set variables first,
> before branching on the resultSet. This will be much more efficient,
> since that will decide the values that should be included in resultSet
> directly.
>
> Cheers,
> Mikael
>
> On Wed, Dec 16, 2009 at 8:51 AM, Mikael Zayenz Lagerkvist
> <zayenz at gmail.com> wrote:
> > Hi,
> > I just tried your problem, and on my computer (Athlon 64 3500+, Ubuntu
> > Linux, gcc 4.2, debug-build of Gecode 3.2.2) both versions of your
> program
> > produce a lot of solutions in a short time. What kind of system do you
> use?
> > The one with shuffled values is not as fast in the beginning, but that is
> > probably due to weak propagation in combination with a branching
> heuristic
> > that tries values not in either set.
> > Cheers,
> > Mikael
> > PS. I would recommend that you use the Driver infrastructure for your
> > experiments so that you can easily add various limits (max number of
> > solutions/failures/time) and run the program in Gist. Using Gist is very
> > good for understanding the behaviour of a Gecode model. Printing the
> search
> > statistics for a completed search is also good when comparing model
> > varieties.
> >
> > 2009/12/16 Holger Winnemoeller <holger.winnemoeller at gmail.com>
> >>
> >> QUESTION: How can I solve the following problem for anything but toy
> >> examples?
> >>
> >> Say, I have the following sets:
> >>
> >> All : {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}
> >> subA: {0,1,2,3,4}
> >> subB: {5,6,7,8,9}
> >>
> >> If I ask for a subset of "All" which contains 4 elements, of which 2
> >> elements are from "subA" and 2 elements are from "subB", I get a variety
> of
> >> results, such as
> >> {0,1,5,6}
> >> {0,1,5,7}
> >> ...
> >> {3,4,8,9}
> >> ...
> >>
> >> etc.
> >>
> >> This works perfectly fine.
> >>
> >> Now, for cases where subA, and  subB are not strictly sequential (i.e.
> >> sorted but non-consecutive numbers)
> >>
> >> subA: {4,8,14,16,17}
> >> subB: {0,3,5,10,12}
> >>
> >> The system quickly runs out of steam (maybe not for the toy example
> here,
> >> but for |All| = 100, |subA| = |subB| = 20, asking for 10 items -- see
> >> attached code). Gecode just keeps computing and never seems to find a
> >> solution.
> >>
> >> Given that the sub-sets are disjoint a solution should really be trivial
> >> in any case (take 50% of one subset and 50% of the other). However, I
> don't
> >> want to make the assumption that they are disjoint.
> >>
> >> I have attached some demo code for what I am talking about, so you can
> >> experiment with it.
> >>
> >> Thanks for your help!
> >>
> >> Holger.
> >>
> >> _______________________________________________
> >> Gecode users mailing list
> >> users at gecode.org
> >> https://www.gecode.org/mailman/listinfo/gecode-users
> >>
> >
> >
> >
> > --
> > Mikael Zayenz Lagerkvist, http://www.ict.kth.se/~zayenz/<http://www.ict.kth.se/%7Ezayenz/>
> >
>
>
>
> --
> Mikael Zayenz Lagerkvist, http://www.ict.kth.se/~zayenz/<http://www.ict.kth.se/%7Ezayenz/>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091216/755d371e/attachment.htm>

From holger.winnemoeller at gmail.com  Thu Dec 17 01:36:10 2009
From: holger.winnemoeller at gmail.com (Holger Winnemoeller)
Date: Wed, 16 Dec 2009 16:36:10 -0800
Subject: [gecode-users] Question about: Float variables,
	Literals and/or Constants
Message-ID: <8eb8d34d0912161636t7e415e54qb737aeed4d76ca73@mail.gmail.com>

I wonder if I have found the best solution to the following problem (I doubt
it):

inventory = {0,1,2,3,4, ... , N}
subsetA = some subset of inventory

Goal: Give me a resultSet with elements from inventory given the following
constraints

*  fraction X of items in resultSet are from subSetA
*  some other constraints (lets not worry about that here)

pseudocode notation of a solution might be:

IntVar resultSize = cardinality(resultSet);
SetVar mutualSet = intersection(resultSet, subsetA);
IntVar mutualSize = cardinality(mutualSet);

FloatVar f = div(mutualSize, resultSize);
rel(div, EQ, X);

Now, while I did find a FloatVar class, it's in the namespace
Gecode::FlatZinc::AST, not Gecode, and I have a feeling its use is not
analogous to IntVar.

So, fair enough, I can just repose the constraint:

                |mutualSet| / |resultSet| = X, where X can be approximated
by n/d

<==> d * |mutualSet| = n * |resultSet|, all of which can be expressed in
Int's

So, my solution ends up being:

        IntVar lhs (*this, 0, d * setB.size());        // worst-case domain
    IntVar rhs (*this, 0, n * inventory.size());   // worst-case domain

    // Q1: I would love to write the following lines, but I may not use
integer literals in the mult call. Is there a better way?
    //mult(*this, mutualSize, d, lhs);
    //mult(*this, resultSize, n, rhs);

    // Q2: Is this the way to specify the constant that I want to use? It
seems very roundabout...
    IntVar numerator(*this, n,n);
    IntVar denominator(*this, d,d);

    mult(*this, mutualSize, denominator, lhs);
    mult(*this, resultSize, numerator,   rhs);

    rel(*this, lhs, IRT_EQ, rhs);

The thing is, I do get the correct solution using this approach, but I feel
like I am misusing Gecode, and that there is a cleaner way to express what I
want. So to summarize my questions:

   - Is there a way to just use a Float constraint?
   - If not (have to use Quotient approach), is there a way to express the
   multiplication using integer literals?
   - If not, is there a way to specify an integer constant without defining
   a one-element domain for it?
   - Or am I crazy, and the solution I give is adequate?


Thanks for your help,
Holger.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091216/9c51959f/attachment.htm>

From zayenz at gmail.com  Thu Dec 17 07:44:44 2009
From: zayenz at gmail.com (Mikael Zayenz Lagerkvist)
Date: Thu, 17 Dec 2009 07:44:44 +0100
Subject: [gecode-users] Set constraints working for sequential data,
	but 	not non-sequential data. Ideas?
In-Reply-To: <8eb8d34d0912161205j422b82dbu9882744b5b49c1a4@mail.gmail.com>
References: <8eb8d34d0912152021qa354e39ub7f8e728569ed0f9@mail.gmail.com> 
	<63b5c8b00912152351n7d3ea5bcyae3fb7b12afdaded@mail.gmail.com> 
	<63b5c8b00912160139p119252cdw4dfc898029b5c98b@mail.gmail.com> 
	<8eb8d34d0912161205j422b82dbu9882744b5b49c1a4@mail.gmail.com>
Message-ID: <63b5c8b00912162244n2b84b482we9720943d97fd17d@mail.gmail.com>

2009/12/16 Holger Winnemoeller <holger.winnemoeller at gmail.com>

> I've added "branch(*this, specialSelected, SET_VAL_MIN_INC);" as the last
> line in CreateAndRequestCategory
> and the code runs like a charm!
>

You might want to collect the specialSelected variables, and branch on them
at the same time. Then you could use some selection heuristic between the
variables (e.g., the specialSelected var with the smallest unknown value, a
random choice, ...).



> I should really try to get Gist working, as I have a feeling that it will
> demystify what to me is currently branching Voodoo.
>

Gist is a good tool to use, and if you installed form the MSI then it is
easy to call. See Modeling with Gecode.

In this case, the reason for branching on the specialSelected variables
first is not actually deep mysticism :) When a value is included in
specialSelected, then it must also be included in resultSet, which is
propagated. Adding a value to resultSet gives very little new information
though, since the value in most cases in your example would not come from
either specialSelected set (this is the crucial difference between
randomizing the value, and keeping them in-order).



> FYI, my system is Dell Intel Core Duo E8400 @ 3GHz with 4GB of RAM on
> WindowsXP professional, running Gecode 3.2.0 (x86). It's interesting, though
> maybe not surprising, that Gecode seems to run so much faster on your
> system. Do you think it's related more to the version of Gecode, the
> machine, or the OS? In any case, the correct answer is obviously not to
> upgrade the hardware, but to insert the branching statement :-)
>

My hardware is definitely slower than what you are using, so I would guess
there is something else going wrong. AFAIK, there were no changes to Gecode
between 3.2.2 and 3.2.0 that should explain the difference. It might be
something very simple, such as the output of the program being buffered for
some reason.

Cheers,
Mikael

-- 
Mikael Zayenz Lagerkvist, http://www.ict.kth.se/~zayenz/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091217/fb635497/attachment.htm>

From zayenz at gmail.com  Thu Dec 17 07:53:02 2009
From: zayenz at gmail.com (Mikael Zayenz Lagerkvist)
Date: Thu, 17 Dec 2009 07:53:02 +0100
Subject: [gecode-users] Question about: Float variables,
	Literals and/or 	Constants
In-Reply-To: <8eb8d34d0912161636t7e415e54qb737aeed4d76ca73@mail.gmail.com>
References: <8eb8d34d0912161636t7e415e54qb737aeed4d76ca73@mail.gmail.com>
Message-ID: <63b5c8b00912162253g23939f1bs36ea8ccda8f6f3b7@mail.gmail.com>

Hi,

The float variables are not yet truly integrated into Gecode, so I would not
advise to use them currently.

As for how to express the multiplication with a constant, I would suggest
you use the minimodel interface:
    post(*this, d*mutualSize == n*resultSize);

Cheers,
Mikael

2009/12/17 Holger Winnemoeller <holger.winnemoeller at gmail.com>

> I wonder if I have found the best solution to the following problem (I
> doubt it):
>
> inventory = {0,1,2,3,4, ... , N}
> subsetA = some subset of inventory
>
> Goal: Give me a resultSet with elements from inventory given the following
> constraints
>
> *  fraction X of items in resultSet are from subSetA
> *  some other constraints (lets not worry about that here)
>
> pseudocode notation of a solution might be:
>
> IntVar resultSize = cardinality(resultSet);
> SetVar mutualSet = intersection(resultSet, subsetA);
> IntVar mutualSize = cardinality(mutualSet);
>
> FloatVar f = div(mutualSize, resultSize);
> rel(div, EQ, X);
>
> Now, while I did find a FloatVar class, it's in the namespace
> Gecode::FlatZinc::AST, not Gecode, and I have a feeling its use is not
> analogous to IntVar.
>
> So, fair enough, I can just repose the constraint:
>
>                 |mutualSet| / |resultSet| = X, where X can be approximated
> by n/d
>
> <==> d * |mutualSet| = n * |resultSet|, all of which can be expressed in
> Int's
>
> So, my solution ends up being:
>
>         IntVar lhs (*this, 0, d * setB.size());        // worst-case
> domain
>     IntVar rhs (*this, 0, n * inventory.size());   // worst-case domain
>
>     // Q1: I would love to write the following lines, but I may not use
> integer literals in the mult call. Is there a better way?
>     //mult(*this, mutualSize, d, lhs);
>     //mult(*this, resultSize, n, rhs);
>
>     // Q2: Is this the way to specify the constant that I want to use? It
> seems very roundabout...
>     IntVar numerator(*this, n,n);
>     IntVar denominator(*this, d,d);
>
>     mult(*this, mutualSize, denominator, lhs);
>     mult(*this, resultSize, numerator,   rhs);
>
>     rel(*this, lhs, IRT_EQ, rhs);
>
> The thing is, I do get the correct solution using this approach, but I feel
> like I am misusing Gecode, and that there is a cleaner way to express what I
> want. So to summarize my questions:
>
>    - Is there a way to just use a Float constraint?
>    - If not (have to use Quotient approach), is there a way to express the
>    multiplication using integer literals?
>    - If not, is there a way to specify an integer constant without
>    defining a one-element domain for it?
>    - Or am I crazy, and the solution I give is adequate?
>
>
> Thanks for your help,
> Holger.
>
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users
>
>


-- 
Mikael Zayenz Lagerkvist, http://www.ict.kth.se/~zayenz/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091217/58dd0c0b/attachment-0001.htm>

From holger.winnemoeller at gmail.com  Thu Dec 17 22:08:17 2009
From: holger.winnemoeller at gmail.com (Holger Winnemoeller)
Date: Thu, 17 Dec 2009 13:08:17 -0800
Subject: [gecode-users] Question about: Float variables,
	Literals and/or 	Constants
In-Reply-To: <63b5c8b00912162253g23939f1bs36ea8ccda8f6f3b7@mail.gmail.com>
References: <8eb8d34d0912161636t7e415e54qb737aeed4d76ca73@mail.gmail.com>
	<63b5c8b00912162253g23939f1bs36ea8ccda8f6f3b7@mail.gmail.com>
Message-ID: <8eb8d34d0912171308l4521cb3k1175fb5cddfa8916@mail.gmail.com>

Great! Again, this was totally the solution. Thank you.

Just in case this is ever relevant to someone else, I am attaching my little
demo program that I used to test the approach.

Cheers,
Holger.

On Wed, Dec 16, 2009 at 10:53 PM, Mikael Zayenz Lagerkvist <zayenz at gmail.com
> wrote:

> Hi,
>
> The float variables are not yet truly integrated into Gecode, so I would
> not advise to use them currently.
>
> As for how to express the multiplication with a constant, I would suggest
> you use the minimodel interface:
>     post(*this, d*mutualSize == n*resultSize);
>
> Cheers,
> Mikael
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091217/90328ac0/attachment.htm>
-------------- next part --------------
// 12/16/2009 By Holger Winnemoeller
// License: Do with this what you will - hope it helps...
#include <gecode/set.hh>
#include <gecode/support.hh>
#include <gecode/minimodel.hh>
#include <gecode/kernel.hh>
#include <gecode/search.hh>
#include <vector>
#include <algorithm>

#include "quotient.hpp"

using namespace std;
using namespace Gecode;

struct SubSet : public vector<int>
{
	Quotient quota;
	SubSet(){}
	SubSet(vector<int>& inventory, int takeNumItems, const Quotient& quota) : vector<int> (takeNumItems), quota(quota)
	{
		for(int i=0; i<takeNumItems; ++i) // fill data from allItems
		{
			(*this)[i] = inventory.back();
			inventory.pop_back();
			sort(begin(), end());
		}
	}
	bool contains(int val) const
	{
		for(size_t i=0; i < size(); ++i)
			if((*this)[i] == val) return true;
		return false;
	}
};

// A "Minimal" space definition for the problem
class MiniSpace: public Space
{
	SetVarArray mSetStore;
	void RequestFromSubset(SubSet& subset, IntVar& resultSetSize, int numRequestedSize)
	{
		// 1.) Create a new set domain that holds the "special" items
		IntSet specialSet(&subset[0], (int)subset.size());
		// 2.) Create a set variable that we'll associate with that set later on
		SetVar specialSelected(*this);
		// 3.) Set "specialSelected" to the intersection of whatever a possible solution is, and
		//     the "specialSet". This ensures that we can talk about items that are included
		//     in the solution, but also belong to the special set
		rel(*this, mSetStore[0], SOT_INTER, specialSet, SRT_EQ, specialSelected);
		// 4.) Now ensure that we only have "requestFromEachCategory" of these overlapping items
		IntVar intersectionSize (*this, 0, (int)subset.size());
		cardinality(*this, specialSelected, intersectionSize);

#if 1	// Using the Minimodel interface
		post(*this, subset.quota.numerator * resultSetSize == subset.quota.denominator * intersectionSize);
#else	// Using the clunky Holger way...
		const Quotient& requestFromEachCategory = subset.quota;
		IntVar lhs (*this, 0, requestFromEachCategory.denominator * (int)subset.size());				
		IntVar rhs (*this, 0, requestFromEachCategory.numerator   * numRequestedSize);	
		
		IntVar numerator(*this, requestFromEachCategory.numerator, requestFromEachCategory.numerator);
		IntVar denominator(*this, requestFromEachCategory.denominator, requestFromEachCategory.denominator);

		mult(*this, intersectionSize, denominator, lhs);				
		mult(*this, resultSetSize,    numerator,   rhs);	

		rel(*this, lhs, IRT_EQ, rhs);
#endif
		branch(*this, specialSelected, SET_VAL_MIN_INC); //  THIS IS THE SAVER!!!!!
	}

public:
	MiniSpace(int problemSize, vector<SubSet>& subsets, int numRequestedSize)
	{
		puts("Setting up problem...");
		// Create a SetVariable array (only need one element really, but this allows me to define the domain in one step)
		mSetStore = SetVarArray(*this, 1, IntSet::empty, 0, problemSize);
		SetVar resultSet = mSetStore[0]; // get the one variable that was defined in the above line

		// impose the constraint that we only want "numRequestedSize" items in the result set
		IntVar resultSetSize(*this, 0, numRequestedSize);
		cardinality(*this, resultSet, resultSetSize);
		rel(*this, resultSetSize, IRT_EQ, numRequestedSize);

		for(size_t i=0; i<subsets.size(); ++i)
			RequestFromSubset(subsets[i], resultSetSize, numRequestedSize); 

		// Given these constraints, branch
		branch(*this, mSetStore, SET_VAR_NONE, SET_VAL_MIN_INC);
	}
	MiniSpace(bool share, MiniSpace& s) : Space(share, s) {mSetStore.update(*this, share, s.mSetStore);}
	virtual Space* copy(bool share) {return new MiniSpace(share, *this);}
	void print(const vector<SubSet>& subsets) const
	{   // Print out a result set, but also a distribution of what subsets of an inventory the items belong to
		// the last number is for items that don't belong to any subset (i.e. inventory diff (union subsets))
		vector<int> scores (subsets.size()+1);
		for(size_t i=0; i<scores.size(); ++i)
			scores[i] = 0;
		int nonSubSetIdx = (int) subsets.size();
		for(SetVarGlbValues d(mSetStore[0]);d();++d)
		{
			int id = d.val();
			bool fromSet = false;
			for(size_t i=0; i<subsets.size(); ++i)
				if(subsets[i].contains(id))
				{
					scores[i]++;
					fromSet = true;
					break;
				}
			if(!fromSet)
				scores[nonSubSetIdx]++;
			std::cout << d.val() << " ";
		}
		printf(". Dist(");
		int total = 0;
		for(size_t i=0; i<scores.size(); ++i)
		{
			total += scores[i];
			printf("%s%i",i?",":"",scores[i]);
		}
		printf("), Sum = %i\n", total);

	}
};

int main(int argc, char* argv[])
{
	// Generate an inventory
	int problemSize = 3000;
	int numItemsInCategories = 200;
	int numSubCategories = 4;
	int requestedSize = 40;

	vector<int> inventory (problemSize);
	for(int i=0; i<problemSize; ++i) inventory[i] = problemSize-1-i; // init items
	
	// just to make it a bit more realistic
	random_shuffle(inventory.begin(), inventory.end()); // shuffle items

	// Float support in Gecode still experimental, apparently. Use quotients instead
	Quotient quotas [] = {Quotient(0.5), Quotient(0.25), Quotient(0.1), Quotient(0.1)};

	vector<SubSet> subsets(numSubCategories);
	for(int i=0; i<numSubCategories; ++i)
		subsets[i] = SubSet(inventory, numItemsInCategories, quotas[i]);

	// Run the problem
	MiniSpace problem (
		problemSize,	// total number of items in inventory
		subsets,		// several sub-inventories (non-overlapping) 
		requestedSize	// requesting X items
	); // space instance

	// Gimme my solutions
	DFS<MiniSpace> solver (&problem);
	int count=0;
	puts("Looking for solutions...");
	while(true){
		MiniSpace* solution = solver.next();
		if(!solution) break;
		std::cout << "Solution Nr." << count++ << std::endl;
		solution->print(subsets);
		std::cout << std::endl;
		delete solution;
	}
	std::cout << "Done..." << std::endl;
	system("pause");
	return 0;
}

-------------- next part --------------
// Conversion from float adapted from: http://stackoverflow.com/questions/1656945/how-can-i-turn-a-floating-point-number-into-the-closest-fraction-represented-by-a 
// License: whatever it says in the above link
#pragma once

#include <math.h>

struct Quotient
{
	int numerator, denominator;
	Quotient() : numerator(0), denominator(1){} // equiv = 0
	Quotient(int numerator, int denominator) : numerator(numerator), denominator(denominator){}
	Quotient (float val)
	{
		float input = val;
		int p0 = 1;
		int q0 = 0;
		int p1 = (int) floorf(input);
		int q1 = 1;
		int p2;
		int q2;

		float r = input - p1;
		float next_cf;
		while(r != 0.0f)
		{
			r = 1.0f / r;
			next_cf = floorf(r);
			p2 = (int) (next_cf * p1 + p0);
			q2 = (int) (next_cf * q1 + q0);

			// Limit the numerator and denominator to be 256 or less
			if(p2 > 256 || q2 > 256)
				break;

			// remember the last two fractions
			p0 = p1;
			p1 = p2;
			q0 = q1;
			q1 = q2;

			r -= next_cf;
		}

		input = (float) p1 / q1;
		// hard upper and lower bounds for ratio
		if(input > 256.0f)
		{
			p1 = 256;
			q1 = 1;
		}
		else if(input < 1.0f / 256.0f)
		{
			p1 = 1;
			q1 = 256;
		}
		numerator = p1;
		denominator = q1;
		float error = (toFloat() - val) / val;
		printf("%f = %i / %i with %.2f %% error\n",val, numerator, denominator, 100.0f * error);
	}
	float toFloat() const 
	{
		return (float) numerator / (float) denominator;
	}
};

From holger.winnemoeller at gmail.com  Fri Dec 18 02:08:30 2009
From: holger.winnemoeller at gmail.com (Holger Winnemoeller)
Date: Thu, 17 Dec 2009 17:08:30 -0800
Subject: [gecode-users] Set constraints working for sequential data,
	but 	not non-sequential data. Ideas?
In-Reply-To: <63b5c8b00912162244n2b84b482we9720943d97fd17d@mail.gmail.com>
References: <8eb8d34d0912152021qa354e39ub7f8e728569ed0f9@mail.gmail.com>
	<63b5c8b00912152351n7d3ea5bcyae3fb7b12afdaded@mail.gmail.com>
	<63b5c8b00912160139p119252cdw4dfc898029b5c98b@mail.gmail.com>
	<8eb8d34d0912161205j422b82dbu9882744b5b49c1a4@mail.gmail.com>
	<63b5c8b00912162244n2b84b482we9720943d97fd17d@mail.gmail.com>
Message-ID: <8eb8d34d0912171708j3b13939cv32341fa1854accd5@mail.gmail.com>

>
>
> I've added "branch(*this, specialSelected, SET_VAL_MIN_INC);" as the last
>> line in CreateAndRequestCategory
>>
>> and the code runs like a charm!
>>
>
>  You might want to collect the specialSelected variables, and branch on
> them at the same time. Then you could use some selection heuristic between
> the variables (e.g., the specialSelected var with the smallest unknown
> value, a random choice, ...).
>
>
Ok, this brings up some other questions:

*1) *I assume the way I would collect on all specialSelected variables would
be:

SetVarArray mySpecialSets (*space, numSpecialSets, IntSet::empty, 0,
maxSpecialSetSize);
foreach(SetVar specialSet in mySpecialSets)
{
   // do something
}
branch(*space, mySpecialSets, SET_VAR_NONE, SET_VAL_MIN_INC); // or other
options

Is this what you had in mind?

*2)* The second, related, questions are then:

   - Would mySpecialSets have to be a member of my Space definition?
   - Would I have to propagate this info in the special copy constructor,
   like so:

MySpace(bool share, MySpace& s)
        : Space(share,s) {
            mySpecialSets.update(*this,share,s.mySpecialSets);
    }

   - Or more generally: What kind of variables (IntVar, SetVar, ...) do I
   have to update in this fashion? I gues I am not quite clear on the
   relationship between the branching and the special copy constructor.


Any help is appreciated.
Thanks,

Holger.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091217/f77c18ad/attachment.htm>

From cschulte at kth.se  Fri Dec 18 09:08:15 2009
From: cschulte at kth.se (Christian Schulte)
Date: Fri, 18 Dec 2009 09:08:15 +0100
Subject: [gecode-users] Set constraints working for sequential data,
	but 	not non-sequential data. Ideas?
In-Reply-To: <8eb8d34d0912171708j3b13939cv32341fa1854accd5@mail.gmail.com>
References: <8eb8d34d0912152021qa354e39ub7f8e728569ed0f9@mail.gmail.com>	<63b5c8b00912152351n7d3ea5bcyae3fb7b12afdaded@mail.gmail.com>	<63b5c8b00912160139p119252cdw4dfc898029b5c98b@mail.gmail.com>	<8eb8d34d0912161205j422b82dbu9882744b5b49c1a4@mail.gmail.com>	<63b5c8b00912162244n2b84b482we9720943d97fd17d@mail.gmail.com>
	<8eb8d34d0912171708j3b13939cv32341fa1854accd5@mail.gmail.com>
Message-ID: <000601ca7fb9$4113e2a0$c33ba7e0$@se>

Hi,

 

1)      If you only need these variables for branching store them
temporarily: use a SetVarArgs array instead of of a SetVarArray.

2)      No. Only if you want to have them as part of your solution, say, for
printing, etc. Otherwise branchings take care of themselves.

 

Cheers

Christian

 

--

Christian Schulte, web.ict.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Holger Winnemoeller
Sent: Friday, December 18, 2009 2:09 AM
To: users at gecode.org
Subject: Re: [gecode-users] Set constraints working for sequential data, but
not non-sequential data. Ideas?

 

 

I've added "branch(*this, specialSelected, SET_VAL_MIN_INC);" as the last
line in CreateAndRequestCategory


and the code runs like a charm!

 

You might want to collect the specialSelected variables, and branch on them
at the same time. Then you could use some selection heuristic between the
variables (e.g., the specialSelected var with the smallest unknown value, a
random choice, ...).

 


Ok, this brings up some other questions:

1) I assume the way I would collect on all specialSelected variables would
be:

SetVarArray mySpecialSets (*space, numSpecialSets, IntSet::empty, 0,
maxSpecialSetSize);
foreach(SetVar specialSet in mySpecialSets)
{
   // do something
}
branch(*space, mySpecialSets, SET_VAR_NONE, SET_VAL_MIN_INC); // or other
options

Is this what you had in mind?

2) The second, related, questions are then:

*	Would mySpecialSets have to be a member of my Space definition?
*	Would I have to propagate this info in the special copy constructor,
like so:

MySpace(bool share, MySpace& s)
        : Space(share,s) {
            mySpecialSets.update(*this,share,s.mySpecialSets);
    }

*	Or more generally: What kind of variables (IntVar, SetVar, ...) do I
have to update in this fashion? I gues I am not quite clear on the
relationship between the branching and the special copy constructor.

 

Any help is appreciated.
Thanks,

Holger.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091218/1c57bc80/attachment-0001.htm>

From benouna84 at live.fr  Thu Dec 24 15:20:10 2009
From: benouna84 at live.fr (frank lemoine)
Date: Thu, 24 Dec 2009 15:20:10 +0100
Subject: [gecode-users] gecode error "do not send"
Message-ID: <SNT131-w18E2442AD78A57C0531E14A67F0@phx.gbl>


hello everybody and merry christmas,

 

i know it's not the best time to post but i hope someone casts a glance at this message,

 

I finished a class that filters domains of variables  that I declare statically so i also finished another class that parse a text file and generates the same data structure, after this i put all in the same; file compilation it's ok but in the execution the first part (parsing) it's ok but when the filtering class call a function gecode show me an windows error (do not send).

 

so i have not understand why it's block, hope someone could.

 

best regards

 

Frank.
 		 	   		  
_________________________________________________________________
Nouveau?! Tout Windows Live d?barque dans votre t?l?phone. Voir les Windows phone
http://clk.atdmt.com/FRM/go/175819071/direct/01/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20091224/30400ef1/attachment.htm>

