From manu.baclet at gmail.com  Tue Aug  7 16:02:17 2012
From: manu.baclet at gmail.com (Manuel Baclet)
Date: Tue, 7 Aug 2012 16:02:17 +0200
Subject: [gecode-users] Bug with Tuple,
	Minimizescript (Restart) and several threads
In-Reply-To: <0F99C0F3-1C58-4CE3-ACE6-390EB597E3D9@gecode.org>
References: <0DA7DC12-5472-4639-AEAB-CC403D86234B@gmail.com>
	<0F99C0F3-1C58-4CE3-ACE6-390EB597E3D9@gecode.org>
Message-ID: <780F883B-94B8-4A00-AD01-4F3E39047991@gmail.com>

Hi Guido,
thanks for the fix. I have found two other problems (using osX 10.8). When possible, i tried with Gecode 3.7.3 and the trunk version.

- EPK_SPEED does not work with restart search and several threads. I provide an example:


This gives me seg faults. gdb says:
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0x0000000000000008
[Switching to process 8791 thread 0x1203]
0x000000010004cbcd in Gecode::Int::Extensional::Incremental<Gecode::Int::BoolView>::remove_support (this=0x103008990, home=@0x102800000, l=0x101308280, i=1, n=1) at incremental.hpp:254
254	      while ((*a)->t != l) {


- sequence is not working properly with restart search and several threads. An example:

This gives different random error messages including Segmentation fault: 11, Abort trap: 6 and 
<<test2(8717,0x10d484000) malloc: *** error for object 0x7fb3c3c081d0: pointer being freed was not allocated
     *** set a breakpoint in malloc_error_break to debug>>


gdb reports one of the following error (depending on the execution):
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: 13 at address: 0x0000000000000000
[Switching to process 8828 thread 0x1203]
0x00000001001a1f78 in Gecode::IntSet::~IntSet () at core.hpp:2286
2286	      delete o;
or 
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0x0000000000000000
[Switching to process 8834 thread 0x1203]
Gecode::VarImp<Gecode::Int::IntVarImpConf>::advise (this=<value temporarily unavailable, due to optimizations>, home=@0x1013086d0, me=1, d=@0x1012cee20) at core.hpp:3346
3346	      switch (p.advise(home,*a,d)) {
or
test2(8866,0x1012cf000) malloc: *** error for object 0x1013081f0: pointer being freed was not allocated
*** set a breakpoint in malloc_error_break to debug

Program received signal SIGABRT, Aborted.
[Switching to process 8866 thread 0x1203]
0x00007fff916e2212 in __pthread_kill ()


The following example shows that this can also happen with bab search:


Hope you can fix this,
Cheers,
Manuel


Le 19 juil. 2012 ? 08:55, Guido Tack <tack at gecode.org> a ?crit :

> Hi Manuel,
> the bug is now fixed in the svn trunk.  Thanks again for reporting it!
> 
> Cheers,
> Guido
> 
> On 16/07/2012, at 8:30 AM, Manuel Baclet wrote:
> 
>> Hello,
>> first of all, thank you for this great software tool. I think there is a bug in Gecode when using extensional constraint with tuples,  minimizescript, restart search and several threads. For example, the following program terminates most of the time with a segmentation fault. I tested this on osX and Linux:
>> <test.cp>
>> 
>> Everything is fine when using one thread or using bab search and i don't think that the problem occurs when using DFA or regular expressions instead of tuples.
>> 
>> On Linux, gdb says:
>> [New Thread 0xb62b6b40 (LWP 7988)]
>> [New Thread 0xb5ab5b40 (LWP 7989)]
>> [New Thread 0xb52b4b40 (LWP 7990)]
>> [New Thread 0xb4ab3b40 (LWP 7991)]
>> 
>> Program received signal SIGSEGV, Segmentation fault.
>> [Switching to Thread 0xb62b6b40 (LWP 7988)]
>> 0xb7aacf95 in Gecode::Int::Extensional::Base<Gecode::Int::BoolView, true>::valid (this=0x806f030, t=0x11, dom=0x806e038)
>>   at ./gecode/int/extensional/base.hpp:131
>> 131	      if (!dom[i].get(static_cast<unsigned int>(t[i]-ts()->min)))
>> 
>> Regards,
>> Manuel
>> 
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org
>> https://www.gecode.org/mailman/listinfo/gecode-users
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/9e808c0e/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test.cp
Type: application/octet-stream
Size: 1488 bytes
Desc: not available
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/9e808c0e/attachment.obj>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/9e808c0e/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test2.cp
Type: application/octet-stream
Size: 1326 bytes
Desc: not available
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/9e808c0e/attachment-0001.obj>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/9e808c0e/attachment-0002.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test3.cp
Type: application/octet-stream
Size: 1375 bytes
Desc: not available
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/9e808c0e/attachment-0002.obj>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/9e808c0e/attachment-0003.html>

From manu.baclet at gmail.com  Tue Aug  7 16:13:33 2012
From: manu.baclet at gmail.com (Manuel Baclet)
Date: Tue, 7 Aug 2012 16:13:33 +0200
Subject: [gecode-users] Bugs with tuples+EPK_SPEED and sequence
References: <780F883B-94B8-4A00-AD01-4F3E39047991@gmail.com>
Message-ID: <3A70E402-AC17-46F7-BB82-10772B51F5E8@gmail.com>

This is a duplicate of another message (attachment went wrong).

Hi Guido,
thanks for the fix. I have found two other problems (using osX 10.8). When possible, i tried with Gecode 3.7.3 and the trunk version.

- EPK_SPEED does not work with restart search and several threads. I provide an example:


This gives me seg faults. gdb says:
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0x0000000000000008
[Switching to process 8791read 0x1203]
0x000000010004cbcd in Gecode::Int::Extensional::Incremental<Gecode::Int::BoolView>::remove_support (this=0x103008990, home=@0x102800000, l=0x101308280, i=1, n=1) at incremental.hpp:254
254	      while ((*a)->t != l) {


- sequence is not working properly with restart search and several threads. An example:

This gives different random error messages including Segmentation fault: 11, Abort trap: 6 and 
<<test2(8717,0x10d484000) malloc: *** error for object 0x7fb3c3c081d0: pointer being freed was not allocated
     *** set a breakpoint in malloc_error_break to debug>>


gdb reports one of the following error (depending on the execution):
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: 13 at address: 0x0000000000000000
[Switching to process 8828 thread 0x1203]
0x00000001001a1f78 in Gecode::IntSet::~IntSet () at core.hpp:2286
2286	      delete o;
or 
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0x0000000000000000
[Switching to process 8834 thread 0x1203]
Gecode::VarImp<Gecode::Int::IntVarImpConf>::advise (this=<value temporarily unavailable, due to optimizations>, home=@0x1013086d0, me=1, d=@0x1012cee20) at core.hpp:3346
3346	      switch (p.advise(home,*a,d)) {
or
test2(8866,0x1012cf000) malloc: *** error for object 0x1013081f0: pointer being freed was not allocated
*** set a breakpoint in malloc_error_break to debug

Program received signal SIGABRT, Aborted.
[Switching to process 8866 thread 0x1203]
0x00007fff916e2212 in __pthread_kill ()


The following example shows that this can also happen with bab search:


Hope you can fix this,
Cheers,
Manuel

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/3f6f6fbb/attachment-0004.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test.cp
Type: application/octet-stream
Size: 1488 bytes
Desc: not available
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/3f6f6fbb/attachment-0003.obj>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/3f6f6fbb/attachment-0005.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test2.cp
Type: application/octet-stream
Size: 1326 bytes
Desc: not available
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/3f6f6fbb/attachment-0004.obj>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/3f6f6fbb/attachment-0006.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test3.cp
Type: application/octet-stream
Size: 1375 bytes
Desc: not available
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/3f6f6fbb/attachment-0005.obj>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120807/3f6f6fbb/attachment-0007.html>

From tack at gecode.org  Wed Aug  8 02:08:38 2012
From: tack at gecode.org (Guido Tack)
Date: Wed, 8 Aug 2012 10:08:38 +1000
Subject: [gecode-users] Bugs with tuples+EPK_SPEED and sequence
In-Reply-To: <3A70E402-AC17-46F7-BB82-10772B51F5E8@gmail.com>
References: <780F883B-94B8-4A00-AD01-4F3E39047991@gmail.com>
	<3A70E402-AC17-46F7-BB82-10772B51F5E8@gmail.com>
Message-ID: <8BCE5BDA-4921-4F03-856A-EE5F992EB761@gecode.org>

Thanks for the report!  Those were similar problems to the one you reported earlier and I just fixed them in the trunk.

Cheers,
Guido

On 08/08/2012, at 12:13 AM, Manuel Baclet <manu.baclet at gmail.com> wrote:

> This is a duplicate of another message (attachment went wrong).
> 
> Hi Guido,
> thanks for the fix. I have found two other problems (using osX 10.8). When possible, i tried with Gecode 3.7.3 and the trunk version.
> 
> - EPK_SPEED does not work with restart search and several threads. I provide an example:
> <test.cp>
> 
> This gives me seg faults. gdb says:
> Program received signal EXC_BAD_ACCESS, Could not access memory.
> Reason: KERN_INVALID_ADDRESS at address: 0x0000000000000008
> [Switching to process 8791read 0x1203]
> 0x000000010004cbcd in Gecode::Int::Extensional::Incremental<Gecode::Int::BoolView>::remove_support (this=0x103008990, home=@0x102800000, l=0x101308280, i=1, n=1) at incremental.hpp:254
> 254	      while ((*a)->t != l) {
> 
> 
> - sequence is not working properly with restart search and several threads. An example:
> <test2.cp>
> This gives different random error messages including Segmentation fault: 11, Abort trap: 6 and 
> <<test2(8717,0x10d484000) malloc: *** error for object 0x7fb3c3c081d0: pointer being freed was not allocated
>      *** set a breakpoint in malloc_error_break to debug>>
> 
> 
> gdb reports one of the following error (depending on the execution):
> Program received signal EXC_BAD_ACCESS, Could not access memory.
> Reason: 13 at address: 0x0000000000000000
> [Switching to process 8828 thread 0x1203]
> 0x00000001001a1f78 in Gecode::IntSet::~IntSet () at core.hpp:2286
> 2286	      delete o;
> or 
> Program received signal EXC_BAD_ACCESS, Could not access memory.
> Reason: KERN_INVALID_ADDRESS at address: 0x0000000000000000
> [Switching to process 8834 thread 0x1203]
> Gecode::VarImp<Gecode::Int::IntVarImpConf>::advise (this=<value temporarily unavailable, due to optimizations>, home=@0x1013086d0, me=1, d=@0x1012cee20) at core.hpp:3346
> 3346	      switch (p.advise(home,*a,d)) {
> or
> test2(8866,0x1012cf000) malloc: *** error for object 0x1013081f0: pointer being freed was not allocated
> *** set a breakpoint in malloc_error_break to debug
> 
> Program received signal SIGABRT, Aborted.
> [Switching to process 8866 thread 0x1203]
> 0x00007fff916e2212 in __pthread_kill ()
> 
> 
> The following example shows that this can also happen with bab search:
> <test3.cp>
> 
> Hope you can fix this,
> Cheers,
> Manuel
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120808/2985f353/attachment.html>

From ostrowsk at cs.uni-potsdam.de  Wed Aug  8 13:41:44 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Wed, 08 Aug 2012 13:41:44 +0200
Subject: [gecode-users] Computing Variable Domains
In-Reply-To: <8762jedr13.fsf@univ-orleans.fr>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>
	<8762jedr13.fsf@univ-orleans.fr>
Message-ID: <50225078.8010006@cs.uni-potsdam.de>

Sorry for reposting an old question. I'm just cleaning up my code and
noticed that i still not managed to use gecode's functionality to
precompute domains of IntVar.
So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
I want to precompute the domain of "a".
I'm simply not able to find out how the Ranges iterators are used.
How to i create a range "5..inf" and a range "-inf..10"
How do i create the intersection of both.
And finally how to set the domain of IntVar x to this range then.


I tried to grep the gecode code and the examples but was not able to
find any.

Sorry again for reposting this, i'm ashamed.

Best,
Max





    The best is to look for examples in the code ;-) Just grep for it.

    MinMax is nothing but a base-class for other classes and cannot be used
    directly. Look for the iterators that take arrays as input, they
    will do what
    you want.

    Best
    Christian

    --
    Christian Schulte, KTH, web.it.kth.se/~cschulte/

    -----Original Message-----
    From: users-boun... at gecode.org [mailto:users-boun... at gecode.org] On
    Behalf Of
    Max Ostrowski
    Sent: Thursday, July 21, 2011 10:49 AM
    To: users at gecode.org
    Subject: [gecode-users] Computing Variable Domains (Integer)

    Hello everybody,

    as variables in gecode need to have a domain, i want to compute the
    domain of
    the variables automatically, given the constraints.
    I could also let the constraints restrict the domains of my
    variables, but as i
    understood, this is similar to propagation and could take some time.
    There i want to restrict the domain manually for all unary constraints.
    So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
    the domain should be {6..9,101..104}.
    Therefore i wanted to use some Gecode classes to compute the
    intersection/union/complement etc.. of the sets.
    Am i right that i can use the Int::Iter::Ranges classes for this?
    And second, how do they work?
    So in this case, i would create a

    IntSet a1(Gecode::Iter::Ranges::MinMax(5+1,Int::Limits::max));
    IntSet a2(Gecode::Iter::Ranges::MinMax(Int::Limits::min, 10-1));

    And them somehow the intersection of this.
    But i was neither able to initialize a set with a Range, nor to
    combine Ranges
    recursively.

    So, how do i do this using the helping classes of gecode.

    Best,
    Max

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120808/1dd5c2dc/attachment.html>

From tack at gecode.org  Fri Aug 10 06:44:17 2012
From: tack at gecode.org (Guido Tack)
Date: Fri, 10 Aug 2012 14:44:17 +1000
Subject: [gecode-users] Computing Variable Domains
In-Reply-To: <50225078.8010006@cs.uni-potsdam.de>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>
	<8762jedr13.fsf@univ-orleans.fr>
	<50225078.8010006@cs.uni-potsdam.de>
Message-ID: <F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>

Hi,

here's some code that will do what you want:

      Iter::Ranges::Singleton si00(6,Int::Limits::max);
      Iter::Ranges::Singleton si10(Int::Limits::min,9);
      Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 
        inter0(si00,si10);

      Iter::Ranges::Singleton si01(101,Int::Limits::max);
      Iter::Ranges::Singleton si11(Int::Limits::min,104);
      Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 
        inter1(si01,si11);

      Iter::Ranges::Union<
        Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton>,
        Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> > 
        u(inter0,inter1);

      IntVar a(*this,IntSet(u));

You can also use the n-ary variants of the iterators if you need to compute a union or intersection of more than two sets.

Cheers,
Guido

On 08/08/2012, at 9:41 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:

> Sorry for reposting an old question. I'm just cleaning up my code and noticed that i still not managed to use gecode's functionality to precompute domains of IntVar.
> So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
> I want to precompute the domain of "a".
> I'm simply not able to find out how the Ranges iterators are used.
> How to i create a range "5..inf" and a range "-inf..10"
> How do i create the intersection of both.
> And finally how to set the domain of IntVar x to this range then.
> 
> 
> I tried to grep the gecode code and the examples but was not able to find any.
> 
> Sorry again for reposting this, i'm ashamed.
> 
> Best,
> Max
> 
> 
> 
> 
> 
> The best is to look for examples in the code ;-) Just grep for it.
> 
> MinMax is nothing but a base-class for other classes and cannot be used 
> directly. Look for the iterators that take arrays as input, they will do what 
> you want.
> 
> Best
> Christian
> 
> --
> Christian Schulte, KTH, web.it.kth.se/~cschulte/
> 
> -----Original Message-----
> From: users-boun... at gecode.org [mailto:users-boun... at gecode.org] On Behalf Of 
> Max Ostrowski
> Sent: Thursday, July 21, 2011 10:49 AM
> To: users at gecode.org
> Subject: [gecode-users] Computing Variable Domains (Integer)
> 
> Hello everybody,
> 
> as variables in gecode need to have a domain, i want to compute the domain of 
> the variables automatically, given the constraints.
> I could also let the constraints restrict the domains of my variables, but as i 
> understood, this is similar to propagation and could take some time.
> There i want to restrict the domain manually for all unary constraints.
> So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
> the domain should be {6..9,101..104}.
> Therefore i wanted to use some Gecode classes to compute the 
> intersection/union/complement etc.. of the sets.
> Am i right that i can use the Int::Iter::Ranges classes for this?
> And second, how do they work?
> So in this case, i would create a 
> 
> IntSet a1(Gecode::Iter::Ranges::MinMax(5+1,Int::Limits::max));
> IntSet a2(Gecode::Iter::Ranges::MinMax(Int::Limits::min, 10-1));
> 
> And them somehow the intersection of this.
> But i was neither able to initialize a set with a Range, nor to combine Ranges 
> recursively.
> 
> So, how do i do this using the helping classes of gecode.
> 
> Best,
> Max
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120810/f20995f1/attachment.html>

From ostrowsk at cs.uni-potsdam.de  Mon Aug 13 12:57:24 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Mon, 13 Aug 2012 12:57:24 +0200
Subject: [gecode-users] Computing Variable Domains
In-Reply-To: <F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>
	<8762jedr13.fsf@univ-orleans.fr>
	<50225078.8010006@cs.uni-potsdam.de>
	<F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>
Message-ID: <5028DD94.8020801@cs.uni-potsdam.de>

Thank you very much for the fast answer.
I tried to play around with them but still face a lot of problems.

In the documentation
http://www.gecode.org/doc-latest/reference/group__FuncIterRangesVirt.html it
is written that
"Iterators with virtual member functions have to be used when they are
combined dynamically ..."
The only base class i found is MinMax.

So how can i use the iterator dynamically.
In the given example i have to know the type of the iterator used before.
(To build the intersection of two Singletons for example)
But if i want to build the intersection of two "domains" which could
have been constructed in various ways (for example recursively),
i need to have a general Base Type, right ?
Is the Iter::Ranges thing still the right thing to use or is there
something else.

Also i found only iterators for union/intersection etc...
Given that you want to add two variables a and b with known domain
(stored in a RangeList?), how do you compute the domain of the result.
Is there any functionality for this or do i have to iterate through both
lists of ranges and add them together to form a new list.


I hope i made things clear, if not please ask.


Best,
Max


On 08/10/2012 06:44 AM, Guido Tack wrote:
> Hi,
>
> here's some code that will do what you want:
>
>       Iter::Ranges::Singleton si00(6,Int::Limits::max);
>       Iter::Ranges::Singleton si10(Int::Limits::min,9);
>      
> Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 
>         inter0(si00,si10);
>
>       Iter::Ranges::Singleton si01(101,Int::Limits::max);
>       Iter::Ranges::Singleton si11(Int::Limits::min,104);
>      
> Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 
>         inter1(si01,si11);
>
>       Iter::Ranges::Union<
>        
> Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton>,
>        
> Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> > 
>         u(inter0,inter1);
>
>       IntVar a(*this,IntSet(u));
>
> You can also use the n-ary variants of the iterators if you need to
> compute a union or intersection of more than two sets.
>
> Cheers,
> Guido
>
> On 08/08/2012, at 9:41 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de
> <mailto:ostrowsk at cs.uni-potsdam.de>> wrote:
>
>> Sorry for reposting an old question. I'm just cleaning up my code and
>> noticed that i still not managed to use gecode's functionality to
>> precompute domains of IntVar.
>> So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
>> I want to precompute the domain of "a".
>> I'm simply not able to find out how the Ranges iterators are used.
>> How to i create a range "5..inf" and a range "-inf..10"
>> How do i create the intersection of both.
>> And finally how to set the domain of IntVar x to this range then.
>>
>>
>> I tried to grep the gecode code and the examples but was not able to
>> find any.
>>
>> Sorry again for reposting this, i'm ashamed.
>>
>> Best,
>> Max
>>
>>
>>
>>
>>
>>     The best is to look for examples in the code ;-) Just grep for it.
>>
>>     MinMax is nothing but a base-class for other classes and cannot
>>     be used
>>     directly. Look for the iterators that take arrays as input, they
>>     will do what
>>     you want.
>>
>>     Best
>>     Christian
>>
>>     --
>>     Christian Schulte, KTH, web.it.kth.se/~cschulte/
>>     <http://web.it.kth.se/%7Ecschulte/>
>>
>>     -----Original Message-----
>>     From: users-boun... at gecode.org [mailto:users-boun... at gecode.org]
>>     On Behalf Of
>>     Max Ostrowski
>>     Sent: Thursday, July 21, 2011 10:49 AM
>>     To: users at gecode.org
>>     Subject: [gecode-users] Computing Variable Domains (Integer)
>>
>>     Hello everybody,
>>
>>     as variables in gecode need to have a domain, i want to compute
>>     the domain of
>>     the variables automatically, given the constraints.
>>     I could also let the constraints restrict the domains of my
>>     variables, but as i
>>     understood, this is similar to propagation and could take some time.
>>     There i want to restrict the domain manually for all unary
>>     constraints.
>>     So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
>>     the domain should be {6..9,101..104}.
>>     Therefore i wanted to use some Gecode classes to compute the
>>     intersection/union/complement etc.. of the sets.
>>     Am i right that i can use the Int::Iter::Ranges classes for this?
>>     And second, how do they work?
>>     So in this case, i would create a
>>
>>     IntSet a1(Gecode::Iter::Ranges::MinMax(5+1,Int::Limits::max));
>>     IntSet a2(Gecode::Iter::Ranges::MinMax(Int::Limits::min, 10-1));
>>
>>     And them somehow the intersection of this.
>>     But i was neither able to initialize a set with a Range, nor to
>>     combine Ranges
>>     recursively.
>>
>>     So, how do i do this using the helping classes of gecode.
>>
>>     Best,
>>     Max
>>
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org <mailto:users at gecode.org>
>> https://www.gecode.org/mailman/listinfo/gecode-users
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120813/e79eea51/attachment.html>

From tack at gecode.org  Tue Aug 14 06:52:20 2012
From: tack at gecode.org (Guido Tack)
Date: Tue, 14 Aug 2012 14:52:20 +1000
Subject: [gecode-users] Computing Variable Domains
In-Reply-To: <5028DD94.8020801@cs.uni-potsdam.de>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>
	<8762jedr13.fsf@univ-orleans.fr>
	<50225078.8010006@cs.uni-potsdam.de>
	<F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>
	<5028DD94.8020801@cs.uni-potsdam.de>
Message-ID: <5133A276-37A2-4596-B4AF-077C89004AA7@gecode.org>

Sorry but I'm not sure I understand what you're trying to do.  Are you trying to precompute bounds on the domains of a and b given that there is a constraint a+b=c in your model?  We don't have specialised iterators for that kind of computation, and just running propagation (i.e. calling status once) will give you the same result.  You should only restrict the variables to reasonable initial domains (i.e., use some easy to compute upper and lower bounds). But you don't have to do the propagators' job.

Cheers,
Guido

On 13/08/2012, at 8:57 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:

> Thank you very much for the fast answer.
> I tried to play around with them but still face a lot of problems.
> 
> In the documentation http://www.gecode.org/doc-latest/reference/group__FuncIterRangesVirt.html it is written that
> "Iterators with virtual member functions have to be used when they are combined dynamically ..."
> The only base class i found is MinMax.
> 
> So how can i use the iterator dynamically.
> In the given example i have to know the type of the iterator used before.
> (To build the intersection of two Singletons for example)
> But if i want to build the intersection of two "domains" which could have been constructed in various ways (for example recursively),
> i need to have a general Base Type, right ?
> Is the Iter::Ranges thing still the right thing to use or is there something else.
> 
> Also i found only iterators for union/intersection etc...
> Given that you want to add two variables a and b with known domain (stored in a RangeList?), how do you compute the domain of the result.
> Is there any functionality for this or do i have to iterate through both lists of ranges and add them together to form a new list.
> 
> 
> I hope i made things clear, if not please ask.
> 
> 
> Best,
> Max
> 
> 
> On 08/10/2012 06:44 AM, Guido Tack wrote:
>> 
>> Hi,
>> 
>> here's some code that will do what you want:
>> 
>>       Iter::Ranges::Singleton si00(6,Int::Limits::max);
>>       Iter::Ranges::Singleton si10(Int::Limits::min,9);
>>       Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 
>>         inter0(si00,si10);
>> 
>>       Iter::Ranges::Singleton si01(101,Int::Limits::max);
>>       Iter::Ranges::Singleton si11(Int::Limits::min,104);
>>       Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 
>>         inter1(si01,si11);
>> 
>>       Iter::Ranges::Union<
>>         Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton>,
>>         Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> > 
>>         u(inter0,inter1);
>> 
>>       IntVar a(*this,IntSet(u));
>> 
>> You can also use the n-ary variants of the iterators if you need to compute a union or intersection of more than two sets.
>> 
>> Cheers,
>> Guido
>> 
>> On 08/08/2012, at 9:41 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:
>> 
>>> Sorry for reposting an old question. I'm just cleaning up my code and noticed that i still not managed to use gecode's functionality to precompute domains of IntVar.
>>> So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
>>> I want to precompute the domain of "a".
>>> I'm simply not able to find out how the Ranges iterators are used.
>>> How to i create a range "5..inf" and a range "-inf..10"
>>> How do i create the intersection of both.
>>> And finally how to set the domain of IntVar x to this range then.
>>> 
>>> 
>>> I tried to grep the gecode code and the examples but was not able to find any.
>>> 
>>> Sorry again for reposting this, i'm ashamed.
>>> 
>>> Best,
>>> Max
>>> 
>>> 
>>> 
>>> 
>>> 
>>> The best is to look for examples in the code ;-) Just grep for it.
>>> 
>>> MinMax is nothing but a base-class for other classes and cannot be used 
>>> directly. Look for the iterators that take arrays as input, they will do what 
>>> you want.
>>> 
>>> Best
>>> Christian
>>> 
>>> --
>>> Christian Schulte, KTH, web.it.kth.se/~cschulte/
>>> 
>>> -----Original Message-----
>>> From: users-boun... at gecode.org [mailto:users-boun... at gecode.org] On Behalf Of 
>>> Max Ostrowski
>>> Sent: Thursday, July 21, 2011 10:49 AM
>>> To: users at gecode.org
>>> Subject: [gecode-users] Computing Variable Domains (Integer)
>>> 
>>> Hello everybody,
>>> 
>>> as variables in gecode need to have a domain, i want to compute the domain of 
>>> the variables automatically, given the constraints.
>>> I could also let the constraints restrict the domains of my variables, but as i 
>>> understood, this is similar to propagation and could take some time.
>>> There i want to restrict the domain manually for all unary constraints.
>>> So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
>>> the domain should be {6..9,101..104}.
>>> Therefore i wanted to use some Gecode classes to compute the 
>>> intersection/union/complement etc.. of the sets.
>>> Am i right that i can use the Int::Iter::Ranges classes for this?
>>> And second, how do they work?
>>> So in this case, i would create a 
>>> 
>>> IntSet a1(Gecode::Iter::Ranges::MinMax(5+1,Int::Limits::max));
>>> IntSet a2(Gecode::Iter::Ranges::MinMax(Int::Limits::min, 10-1));
>>> 
>>> And them somehow the intersection of this.
>>> But i was neither able to initialize a set with a Range, nor to combine Ranges 
>>> recursively.
>>> 
>>> So, how do i do this using the helping classes of gecode.
>>> 
>>> Best,
>>> Max
>>> _______________________________________________
>>> Gecode users mailing list
>>> users at gecode.org
>>> https://www.gecode.org/mailman/listinfo/gecode-users
>> 
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120814/fb314fbd/attachment.html>

From ostrowsk at cs.uni-potsdam.de  Tue Aug 14 09:33:44 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Tue, 14 Aug 2012 09:33:44 +0200
Subject: [gecode-users] Computing Variable Domains
In-Reply-To: <5133A276-37A2-4596-B4AF-077C89004AA7@gecode.org>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>
	<8762jedr13.fsf@univ-orleans.fr>
	<50225078.8010006@cs.uni-potsdam.de>
	<F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>
	<5028DD94.8020801@cs.uni-potsdam.de>
	<5133A276-37A2-4596-B4AF-077C89004AA7@gecode.org>
Message-ID: <5029FF58.7050103@cs.uni-potsdam.de>

OK, i see.
This was indeed the thing i wanted to do.
I had some bad experiences with posting propagators on unrestricted
variables.
Given that my supports has a declarative language for the description of
the constraints, no domain is given as input.
That why i wanted to compute one.
But i will now leave it with a simple bound computation using
boost::numeric::interval.

Thanks a lot,
Max

On 08/14/2012 06:52 AM, Guido Tack wrote:
> Sorry but I'm not sure I understand what you're trying to do.  Are you
> trying to precompute bounds on the domains of a and b given that there
> is a constraint a+b=c in your model?  We don't have specialised
> iterators for that kind of computation, and just running propagation
> (i.e. calling status once) will give you the same result.  You should
> only restrict the variables to reasonable initial domains (i.e., use
> some easy to compute upper and lower bounds). But you don't have to do
> the propagators' job.
>
> Cheers,
> Guido
>
> On 13/08/2012, at 8:57 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de
> <mailto:ostrowsk at cs.uni-potsdam.de>> wrote:
>
>> Thank you very much for the fast answer.
>> I tried to play around with them but still face a lot of problems.
>>
>> In the documentation
>> http://www.gecode.org/doc-latest/reference/group__FuncIterRangesVirt.html
>> it is written that
>> "Iterators with virtual member functions have to be used when they
>> are combined dynamically ..."
>> The only base class i found is MinMax.
>>
>> So how can i use the iterator dynamically.
>> In the given example i have to know the type of the iterator used before.
>> (To build the intersection of two Singletons for example)
>> But if i want to build the intersection of two "domains" which could
>> have been constructed in various ways (for example recursively),
>> i need to have a general Base Type, right ?
>> Is the Iter::Ranges thing still the right thing to use or is there
>> something else.
>>
>> Also i found only iterators for union/intersection etc...
>> Given that you want to add two variables a and b with known domain
>> (stored in a RangeList?), how do you compute the domain of the result.
>> Is there any functionality for this or do i have to iterate through
>> both lists of ranges and add them together to form a new list.
>>
>>
>> I hope i made things clear, if not please ask.
>>
>>
>> Best,
>> Max
>>
>>
>> On 08/10/2012 06:44 AM, Guido Tack wrote:
>>> Hi,
>>>
>>> here's some code that will do what you want:
>>>
>>>       Iter::Ranges::Singleton si00(6,Int::Limits::max);
>>>       Iter::Ranges::Singleton si10(Int::Limits::min,9);
>>>      
>>> Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 
>>>         inter0(si00,si10);
>>>
>>>       Iter::Ranges::Singleton si01(101,Int::Limits::max);
>>>       Iter::Ranges::Singleton si11(Int::Limits::min,104);
>>>      
>>> Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 
>>>         inter1(si01,si11);
>>>
>>>       Iter::Ranges::Union<
>>>        
>>> Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton>,
>>>        
>>> Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> > 
>>>         u(inter0,inter1);
>>>
>>>       IntVar a(*this,IntSet(u));
>>>
>>> You can also use the n-ary variants of the iterators if you need to
>>> compute a union or intersection of more than two sets.
>>>
>>> Cheers,
>>> Guido
>>>
>>> On 08/08/2012, at 9:41 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de
>>> <mailto:ostrowsk at cs.uni-potsdam.de>> wrote:
>>>
>>>> Sorry for reposting an old question. I'm just cleaning up my code
>>>> and noticed that i still not managed to use gecode's functionality
>>>> to precompute domains of IntVar.
>>>> So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
>>>> I want to precompute the domain of "a".
>>>> I'm simply not able to find out how the Ranges iterators are used.
>>>> How to i create a range "5..inf" and a range "-inf..10"
>>>> How do i create the intersection of both.
>>>> And finally how to set the domain of IntVar x to this range then.
>>>>
>>>>
>>>> I tried to grep the gecode code and the examples but was not able
>>>> to find any.
>>>>
>>>> Sorry again for reposting this, i'm ashamed.
>>>>
>>>> Best,
>>>> Max
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>     The best is to look for examples in the code ;-) Just grep for it.
>>>>
>>>>     MinMax is nothing but a base-class for other classes and cannot
>>>>     be used
>>>>     directly. Look for the iterators that take arrays as input,
>>>>     they will do what
>>>>     you want.
>>>>
>>>>     Best
>>>>     Christian
>>>>
>>>>     --
>>>>     Christian Schulte, KTH, web.it.kth.se/~cschulte/
>>>>     <http://web.it.kth.se/%7Ecschulte/>
>>>>
>>>>     -----Original Message-----
>>>>     From: users-boun... at gecode.org
>>>>     [mailto:users-boun... at gecode.org] On Behalf Of
>>>>     Max Ostrowski
>>>>     Sent: Thursday, July 21, 2011 10:49 AM
>>>>     To: users at gecode.org
>>>>     Subject: [gecode-users] Computing Variable Domains (Integer)
>>>>
>>>>     Hello everybody,
>>>>
>>>>     as variables in gecode need to have a domain, i want to compute
>>>>     the domain of
>>>>     the variables automatically, given the constraints.
>>>>     I could also let the constraints restrict the domains of my
>>>>     variables, but as i
>>>>     understood, this is similar to propagation and could take some
>>>>     time.
>>>>     There i want to restrict the domain manually for all unary
>>>>     constraints.
>>>>     So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
>>>>     the domain should be {6..9,101..104}.
>>>>     Therefore i wanted to use some Gecode classes to compute the
>>>>     intersection/union/complement etc.. of the sets.
>>>>     Am i right that i can use the Int::Iter::Ranges classes for this?
>>>>     And second, how do they work?
>>>>     So in this case, i would create a
>>>>
>>>>     IntSet a1(Gecode::Iter::Ranges::MinMax(5+1,Int::Limits::max));
>>>>     IntSet a2(Gecode::Iter::Ranges::MinMax(Int::Limits::min, 10-1));
>>>>
>>>>     And them somehow the intersection of this.
>>>>     But i was neither able to initialize a set with a Range, nor to
>>>>     combine Ranges
>>>>     recursively.
>>>>
>>>>     So, how do i do this using the helping classes of gecode.
>>>>
>>>>     Best,
>>>>     Max
>>>>
>>>> _______________________________________________
>>>> Gecode users mailing list
>>>> users at gecode.org <mailto:users at gecode.org>
>>>> https://www.gecode.org/mailman/listinfo/gecode-users
>>>
>>
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org <mailto:users at gecode.org>
>> https://www.gecode.org/mailman/listinfo/gecode-users
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120814/7626f55c/attachment-0001.html>

From cschulte at kth.se  Tue Aug 14 10:19:18 2012
From: cschulte at kth.se (Christian Schulte)
Date: Tue, 14 Aug 2012 10:19:18 +0200
Subject: [gecode-users] Computing Variable Domains
In-Reply-To: <5029FF58.7050103@cs.uni-potsdam.de>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>	<8762jedr13.fsf@univ-orleans.fr>	<50225078.8010006@cs.uni-potsdam.de>	<F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>	<5028DD94.8020801@cs.uni-potsdam.de>	<5133A276-37A2-4596-B4AF-077C89004AA7@gecode.org>
	<5029FF58.7050103@cs.uni-potsdam.de>
Message-ID: <006c01cd79f5$80915910$81b40b30$@se>

I think Guido's proposal is a very good one: just reasonable bounds. Here,
reasonable means that the only thing you have to get right is to come up
with bounds for linear constraints. The other constraints do not suffer that
easily from arithmetic overflow.

 

Keep it simple!

 

Christian

 

--

Christian Schulte, www.ict.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Max Ostrowski
Sent: Tuesday, August 14, 2012 9:34 AM
To: Guido Tack
Cc: users at gecode.org
Subject: Re: [gecode-users] Computing Variable Domains

 

OK, i see.
This was indeed the thing i wanted to do.
I had some bad experiences with posting propagators on unrestricted
variables.
Given that my supports has a declarative language for the description of the
constraints, no domain is given as input.
That why i wanted to compute one.
But i will now leave it with a simple bound computation using
boost::numeric::interval.

Thanks a lot,
Max

On 08/14/2012 06:52 AM, Guido Tack wrote: 

Sorry but I'm not sure I understand what you're trying to do.  Are you
trying to precompute bounds on the domains of a and b given that there is a
constraint a+b=c in your model?  We don't have specialised iterators for
that kind of computation, and just running propagation (i.e. calling status
once) will give you the same result.  You should only restrict the variables
to reasonable initial domains (i.e., use some easy to compute upper and
lower bounds). But you don't have to do the propagators' job.

 

Cheers, 

Guido

 

On 13/08/2012, at 8:57 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:





Thank you very much for the fast answer.
I tried to play around with them but still face a lot of problems.

In the documentation
http://www.gecode.org/doc-latest/reference/group__FuncIterRangesVirt.html it
is written that
"Iterators with virtual member functions have to be used when they are
combined dynamically ..."
The only base class i found is MinMax.

So how can i use the iterator dynamically.
In the given example i have to know the type of the iterator used before.
(To build the intersection of two Singletons for example)
But if i want to build the intersection of two "domains" which could have
been constructed in various ways (for example recursively),
i need to have a general Base Type, right ?
Is the Iter::Ranges thing still the right thing to use or is there something
else.

Also i found only iterators for union/intersection etc...
Given that you want to add two variables a and b with known domain (stored
in a RangeList?), how do you compute the domain of the result.
Is there any functionality for this or do i have to iterate through both
lists of ranges and add them together to form a new list.


I hope i made things clear, if not please ask.


Best,
Max


On 08/10/2012 06:44 AM, Guido Tack wrote: 

Hi, 

 

here's some code that will do what you want:

 

      Iter::Ranges::Singleton si00(6,Int::Limits::max);

      Iter::Ranges::Singleton si10(Int::Limits::min,9);

      Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 

        inter0(si00,si10);

 

      Iter::Ranges::Singleton si01(101,Int::Limits::max);

      Iter::Ranges::Singleton si11(Int::Limits::min,104);

      Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton> 

        inter1(si01,si11);

 

      Iter::Ranges::Union<

 
Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton>,

        Iter::Ranges::Inter<Iter::Ranges::Singleton,Iter::Ranges::Singleton>
> 

        u(inter0,inter1);

 

      IntVar a(*this,IntSet(u));

 

You can also use the n-ary variants of the iterators if you need to compute
a union or intersection of more than two sets.

 

Cheers,

Guido

 

On 08/08/2012, at 9:41 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:





Sorry for reposting an old question. I'm just cleaning up my code and
noticed that i still not managed to use gecode's functionality to precompute
domains of IntVar.
So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
I want to precompute the domain of "a".
I'm simply not able to find out how the Ranges iterators are used.
How to i create a range "5..inf" and a range "-inf..10"
How do i create the intersection of both.
And finally how to set the domain of IntVar x to this range then.


I tried to grep the gecode code and the examples but was not able to find
any.

Sorry again for reposting this, i'm ashamed.

Best,
Max






The best is to look for examples in the code ;-) Just grep for it.

MinMax is nothing but a base-class for other classes and cannot be used 
directly. Look for the iterators that take arrays as input, they will do
what 
you want.

Best
Christian

--
Christian Schulte, KTH, web.it.kth.se/~cschulte/
<http://web.it.kth.se/%7Ecschulte/> 

-----Original Message-----
From: users-boun... at gecode.org [mailto:users-boun... at gecode.org] On Behalf
Of 
Max Ostrowski
Sent: Thursday, July 21, 2011 10:49 AM
To: users at gecode.org
Subject: [gecode-users] Computing Variable Domains (Integer)

Hello everybody,

as variables in gecode need to have a domain, i want to compute the domain
of 
the variables automatically, given the constraints.
I could also let the constraints restrict the domains of my variables, but
as i 
understood, this is similar to propagation and could take some time.
There i want to restrict the domain manually for all unary constraints.
So, given a constraint "(a>5 /\ a<10) \/ (a>100 /\ a<105)"
the domain should be {6..9,101..104}.
Therefore i wanted to use some Gecode classes to compute the 
intersection/union/complement etc.. of the sets.
Am i right that i can use the Int::Iter::Ranges classes for this?
And second, how do they work?
So in this case, i would create a 

IntSet a1(Gecode::Iter::Ranges::MinMax(5+1,Int::Limits::max));
IntSet a2(Gecode::Iter::Ranges::MinMax(Int::Limits::min, 10-1));

And them somehow the intersection of this.
But i was neither able to initialize a set with a Range, nor to combine
Ranges 
recursively.

So, how do i do this using the helping classes of gecode.

Best,
Max

_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users

 

 

_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120814/e57e3806/attachment.html>

From ostrowsk at cs.uni-potsdam.de  Fri Aug 17 15:24:18 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Fri, 17 Aug 2012 15:24:18 +0200
Subject: [gecode-users] Removing propagators from a Space
In-Reply-To: <006c01cd79f5$80915910$81b40b30$@se>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>	<8762jedr13.fsf@univ-orleans.fr>	<50225078.8010006@cs.uni-potsdam.de>	<F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>	<5028DD94.8020801@cs.uni-potsdam.de>	<5133A276-37A2-4596-B4AF-077C89004AA7@gecode.org>
	<5029FF58.7050103@cs.uni-potsdam.de>
	<006c01cd79f5$80915910$81b40b30$@se>
Message-ID: <502E4602.4030503@cs.uni-potsdam.de>

Is there a way to remove all propagators from a space "a".
In this way the space contains only the restricted variables so far but
no constraints on them.
I need such a space and i want to avoid creating an empty space "b" and
adding all variables and constraining them to the values they had in "a".


Is this possible?


Best,
Max


From tack at gecode.org  Fri Aug 17 21:05:57 2012
From: tack at gecode.org (Guido Tack)
Date: Sat, 18 Aug 2012 05:05:57 +1000
Subject: [gecode-users] Removing propagators from a Space
In-Reply-To: <502E4602.4030503@cs.uni-potsdam.de>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>
	<8762jedr13.fsf@univ-orleans.fr>
	<50225078.8010006@cs.uni-potsdam.de>
	<F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>
	<5028DD94.8020801@cs.uni-potsdam.de>
	<5133A276-37A2-4596-B4AF-077C89004AA7@gecode.org>
	<5029FF58.7050103@cs.uni-potsdam.de>
	<006c01cd79f5$80915910$81b40b30$@se>
	<502E4602.4030503@cs.uni-potsdam.de>
Message-ID: <E7260558-A16F-4604-B0CE-06BEC6D588CC@gecode.org>

No, that's currently not supported.  You'll have to work around it as you suggested.

Cheers,
Guido

-- 
Guido Tack
http://www.csse.monash.edu/~guidot/



On 17/08/2012, at 11:24 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:

> Is there a way to remove all propagators from a space "a".
> In this way the space contains only the restricted variables so far but
> no constraints on them.
> I need such a space and i want to avoid creating an empty space "b" and
> adding all variables and constraining them to the values they had in "a".
> 
> 
> Is this possible?
> 
> 
> Best,
> Max
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120818/81e69dfe/attachment.html>

From cschulte at kth.se  Fri Aug 17 21:17:17 2012
From: cschulte at kth.se (Christian Schulte)
Date: Fri, 17 Aug 2012 21:17:17 +0200
Subject: [gecode-users] Removing propagators from a Space
In-Reply-To: <E7260558-A16F-4604-B0CE-06BEC6D588CC@gecode.org>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>	<8762jedr13.fsf@univ-orleans.fr>	<50225078.8010006@cs.uni-potsdam.de>	<F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>	<5028DD94.8020801@cs.uni-potsdam.de>	<5133A276-37A2-4596-B4AF-077C89004AA7@gecode.org>	<5029FF58.7050103@cs.uni-potsdam.de>	<006c01cd79f5$80915910$81b40b30$@se>	<502E4602.4030503@cs.uni-potsdam.de>
	<E7260558-A16F-4604-B0CE-06BEC6D588CC@gecode.org>
Message-ID: <000601cd7cac$ec06f330$c414d990$@kth.se>

But I could add it for Gecode 4.*, should not be that hard. Do you want it?

 

Christian

 

--

Christian Schulte, www.ict.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Guido Tack
Sent: Friday, August 17, 2012 9:06 PM
To: Max Ostrowski
Cc: users at gecode.org
Subject: Re: [gecode-users] Removing propagators from a Space

 

No, that's currently not supported.  You'll have to work around it as you
suggested.

 

Cheers,

Guido

 

-- 

Guido Tack

http://www.csse.monash.edu/~guidot/

 

 

 

On 17/08/2012, at 11:24 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de>
wrote:





Is there a way to remove all propagators from a space "a".
In this way the space contains only the restricted variables so far but
no constraints on them.
I need such a space and i want to avoid creating an empty space "b" and
adding all variables and constraining them to the values they had in "a".


Is this possible?


Best,
Max

_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120817/c91a048d/attachment.html>

From ostrowsk at cs.uni-potsdam.de  Mon Aug 20 09:33:42 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Mon, 20 Aug 2012 09:33:42 +0200
Subject: [gecode-users] Removing propagators from a Space
In-Reply-To: <000601cd7cac$ec06f330$c414d990$@kth.se>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>	<8762jedr13.fsf@univ-orleans.fr>	<50225078.8010006@cs.uni-potsdam.de>	<F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>	<5028DD94.8020801@cs.uni-potsdam.de>	<5133A276-37A2-4596-B4AF-077C89004AA7@gecode.org>	<5029FF58.7050103@cs.uni-potsdam.de>	<006c01cd79f5$80915910$81b40b30$@se>	<502E4602.4030503@cs.uni-potsdam.de>
	<E7260558-A16F-4604-B0CE-06BEC6D588CC@gecode.org>
	<000601cd7cac$ec06f330$c414d990$@kth.se>
Message-ID: <5031E856.5050405@cs.uni-potsdam.de>

That would be cool.
I think it is not useful for the normal use of GeCode, so you have to
decide if you want to bloat your code with this.
But I would appreciate it.
If there would be also the possibility to only remove certain
constraints, that would be even more awesome.
But here I see why it is difficult, as Propagators would need to be
identified by something.


Best,
Max

On 08/17/2012 09:17 PM, Christian Schulte wrote:
>
> But I could add it for Gecode 4.*, should not be that hard. Do you
> want it?
>
>  
>
> Christian
>
>  
>
> --
>
> Christian Schulte, www.ict.kth.se/~cschulte/
>
>  
>
> *From:* users-bounces at gecode.org [mailto:users-bounces at gecode.org] *On
> Behalf Of *Guido Tack
> *Sent:* Friday, August 17, 2012 9:06 PM
> *To:* Max Ostrowski
> *Cc:* users at gecode.org
> *Subject:* Re: [gecode-users] Removing propagators from a Space
>
>  
>
> No, that's currently not supported.  You'll have to work around it as
> you suggested.
>
>  
>
> Cheers,
>
> Guido
>
>  
>
> -- 
>
> Guido Tack
>
> http://www.csse.monash.edu/~guidot/
> <http://www.csse.monash.edu/%7Eguidot/>
>
>  
>
>  
>
>  
>
> On 17/08/2012, at 11:24 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de
> <mailto:ostrowsk at cs.uni-potsdam.de>> wrote:
>
>
>
> Is there a way to remove all propagators from a space "a".
> In this way the space contains only the restricted variables so far but
> no constraints on them.
> I need such a space and i want to avoid creating an empty space "b" and
> adding all variables and constraining them to the values they had in "a".
>
>
> Is this possible?
>
>
> Best,
> Max
>
> _______________________________________________
> Gecode users mailing list
> users at gecode.org <mailto:users at gecode.org>
> https://www.gecode.org/mailman/listinfo/gecode-users
>
>  
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120820/e3fc2819/attachment.html>

From cschulte at kth.se  Tue Aug 21 09:49:47 2012
From: cschulte at kth.se (Christian Schulte)
Date: Tue, 21 Aug 2012 09:49:47 +0200
Subject: [gecode-users] Removing propagators from a Space
In-Reply-To: <5031E856.5050405@cs.uni-potsdam.de>
References: <91367EF5-E6B5-4E6F-A392-BD56CC09C6BE@uniud.it>	<8762jedr13.fsf@univ-orleans.fr>	<50225078.8010006@cs.uni-potsdam.de>	<F2E1FCDB-4708-4032-B524-2FEDC156C978@gecode.org>	<5028DD94.8020801@cs.uni-potsdam.de>	<5133A276-37A2-4596-B4AF-077C89004AA7@gecode.org>	<5029FF58.7050103@cs.uni-potsdam.de>	<006c01cd79f5$80915910$81b40b30$@se>	<502E4602.4030503@cs.uni-potsdam.de>	<E7260558-A16F-4604-B0CE-06BEC6D588CC@gecode.org>	<000601cd7cac$ec06f330$c414d990$@kth.se>
	<5031E856.5050405@cs.uni-potsdam.de>
Message-ID: <00ec01cd7f71$8a604790$9f20d6b0$@kth.se>

Removing all is easy and useful. Removing some is a pain in the .

 

I'll do the former.

 

Christian

 

--

Christian Schulte, KTH, web.it.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Max Ostrowski
Sent: Monday, August 20, 2012 9:34 AM
To: cschulte at kth.se
Cc: 'Guido Tack'; users at gecode.org
Subject: Re: [gecode-users] Removing propagators from a Space

 

That would be cool.
I think it is not useful for the normal use of GeCode, so you have to decide
if you want to bloat your code with this.
But I would appreciate it.
If there would be also the possibility to only remove certain constraints,
that would be even more awesome.
But here I see why it is difficult, as Propagators would need to be
identified by something.


Best,
Max

On 08/17/2012 09:17 PM, Christian Schulte wrote: 

But I could add it for Gecode 4.*, should not be that hard. Do you want it?

 

Christian

 

--

Christian Schulte, www.ict.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Guido Tack
Sent: Friday, August 17, 2012 9:06 PM
To: Max Ostrowski
Cc: users at gecode.org
Subject: Re: [gecode-users] Removing propagators from a Space

 

No, that's currently not supported.  You'll have to work around it as you
suggested.

 

Cheers,

Guido

 

-- 

Guido Tack

http://www.csse.monash.edu/~guidot/ <http://www.csse.monash.edu/%7Eguidot/> 

 

 

 

On 17/08/2012, at 11:24 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de>
wrote:






Is there a way to remove all propagators from a space "a".
In this way the space contains only the restricted variables so far but
no constraints on them.
I need such a space and i want to avoid creating an empty space "b" and
adding all variables and constraining them to the values they had in "a".


Is this possible?


Best,
Max

_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120821/dc68a8d4/attachment.html>

From ostrowsk at cs.uni-potsdam.de  Tue Aug 21 10:11:43 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Tue, 21 Aug 2012 10:11:43 +0200
Subject: [gecode-users] Writing Advisors
Message-ID: <503342BF.4010500@cs.uni-potsdam.de>

Hi, i want to write an advisor for my propagator that gets notified when the
watched variable changes it bounds.
In the attached code, the advise method now prints the view min and max.
According to the Gecode Documentation min(d)/max(d) return the old value
of the variable,
while min()/max() return the new value, is this correct?

In my current test setting, i have only one variable "a=[0..10]"
Then i add the constraint a>5.
The advisor is called properly.
The first line prints:

0 5 6 10

This would mean that the domain of "a" before the progagation was [0..5]
and now is [6..10].
This of course can't be true (as they do not overlap).
So how do I use the Delta Information correctly.
I found no example actually using this information.

2nd Question:
With my two if statements in the advisor method,
will i catch all changes of the bounds? Or is it possible to catch more.


Best,
Max

PS: Thanks for the possibility to remove all propagators.

class Waiter : public Propagator {

        ...

        class Watcher  : public Advisor {
        public:
            Int::IntView b_;
            unsigned int lowerVar_;
            Watcher(Space& home, Propagator& p,
                    Council<Watcher>& c, Int::IntView b, Clasp::Var lower)
                : Advisor(home,p,c), b_(b), lowerVar_(lower)
            {
                b_.subscribe(home,*this);
            }

            Watcher(Space& home, bool share, Watcher& w)
                : Advisor(home,share,w), lowerVar_(w.lowerVar_)
            {
                b_.update(home,share,w.b_);
            }

            void dispose(Space& home, Council<Watcher>& c)
            {
                b_.cancel(home,*this);
                Advisor::dispose(home,c);
            }
        };
        Council<Watcher> c_;
    public:
        Waiter(Space& home) : Propagator(home), c_(home)
        {
            home.notice(*this,AP_DISPOSE);
        }

        Waiter(Space& home, bool shared, Waiter& p)
            : Propagator(home,shared,p)
        {
            c_.update(home,shared,p.c_);
        }

        void init(Space& home, GecodeSolver* csps, Int::IntView b,
unsigned int varNumber)
        {
            solver = csps;
            ...
            (void) new (home) Watcher(home,*this,c_,b,varNumber);
        }

        /// Perform copying during cloning
        virtual  Actor* copy(Space& home, bool share) {
            return new (home) Waiter(home,share,*this);
        }

        /// Const function (defined as low unary)
        PropCost cost(const Space&, const ModEventDelta&) const {
            return PropCost::unary(PropCost::LO);
        }

        virtual size_t dispose(Space &home) {
            home.ignore(*this,AP_DISPOSE);
            c_.dispose(home);
            (void) Propagator::dispose(home);
            return sizeof(*this);
        }

        virtual ExecStatus advise(Space &home, Advisor &a, const Delta &d)
        {
            std::cout << static_cast<Watcher&>(a).b_.min(d) << " " <<
static_cast<Watcher&>(a).b_.max(d) << "\t" <<
static_cast<Watcher&>(a).b_.min() << " " <<
static_cast<Watcher&>(a).b_.max() << std::endl;
            Gecode::ModEvent e =
static_cast<Watcher&>(a).b_.modevent(d); //use this modevent
            if (e == Gecode::Int::ME_INT_BND)
            {
                if (!static_cast<Watcher&>(a).b_.any(d))
                {
                    if (static_cast<Watcher&>(a).b_.min(d) !=
static_cast<Watcher&>(a).b_.min()) // minimum has changed
                    {
                        ...
                    }
                    if (static_cast<Watcher&>(a).b_.max(d) !=
static_cast<Watcher&>(a).b_.max()) // maximum has changed
                    {
                        ...
                    }
                }
            }
            if (static_cast<Watcher&>(a).b_.assigned())
                return home.ES_FIX_DISPOSE(c_,static_cast<Watcher&>(a));
            else
                return ES_FIX;
        }


        virtual ExecStatus propagate(Space &home, const ModEventDelta &med)
        {
            return ES_FIX;
        }

    };
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120821/7bf19dcf/attachment.html>

From cschulte at kth.se  Tue Aug 21 10:27:24 2012
From: cschulte at kth.se (Christian Schulte)
Date: Tue, 21 Aug 2012 10:27:24 +0200
Subject: [gecode-users] Writing Advisors
In-Reply-To: <503342BF.4010500@cs.uni-potsdam.de>
References: <503342BF.4010500@cs.uni-potsdam.de>
Message-ID: <026901cd7f76$cb5f47a0$621dd6e0$@kth.se>

Please read the examples in MPG again. It is not the old domain. It is the
delta (as the name suggests).

 

Christian

 

--

Christian Schulte, KTH, web.it.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Max Ostrowski
Sent: Tuesday, August 21, 2012 10:12 AM
To: users at gecode.org
Subject: [gecode-users] Writing Advisors

 

Hi, i want to write an advisor for my propagator that gets notified when the
watched variable changes it bounds.
In the attached code, the advise method now prints the view min and max.
According to the Gecode Documentation min(d)/max(d) return the old value of
the variable,
while min()/max() return the new value, is this correct?

In my current test setting, i have only one variable "a=[0..10]"
Then i add the constraint a>5.
The advisor is called properly.
The first line prints:

0 5 6 10

This would mean that the domain of "a" before the progagation was [0..5] and
now is [6..10].
This of course can't be true (as they do not overlap).
So how do I use the Delta Information correctly.
I found no example actually using this information.

2nd Question:
With my two if statements in the advisor method,
will i catch all changes of the bounds? Or is it possible to catch more.


Best,
Max

PS: Thanks for the possibility to remove all propagators.

class Waiter : public Propagator {

        ...

        class Watcher  : public Advisor {
        public:
            Int::IntView b_;
            unsigned int lowerVar_;
            Watcher(Space& home, Propagator& p,
                    Council<Watcher>& c, Int::IntView b, Clasp::Var lower)
                : Advisor(home,p,c), b_(b), lowerVar_(lower)
            {
                b_.subscribe(home,*this);
            }

            Watcher(Space& home, bool share, Watcher& w)
                : Advisor(home,share,w), lowerVar_(w.lowerVar_)
            {
                b_.update(home,share,w.b_);
            }

            void dispose(Space& home, Council<Watcher>& c)
            {
                b_.cancel(home,*this);
                Advisor::dispose(home,c);
            }
        };
        Council<Watcher> c_;
    public:
        Waiter(Space& home) : Propagator(home), c_(home)
        {
            home.notice(*this,AP_DISPOSE);
        }

        Waiter(Space& home, bool shared, Waiter& p)
            : Propagator(home,shared,p)
        {
            c_.update(home,shared,p.c_);
        }

        void init(Space& home, GecodeSolver* csps, Int::IntView b, unsigned
int varNumber)
        {
            solver = csps;
            ...
            (void) new (home) Watcher(home,*this,c_,b,varNumber);
        }

        /// Perform copying during cloning
        virtual  Actor* copy(Space& home, bool share) {
            return new (home) Waiter(home,share,*this);
        }

        /// Const function (defined as low unary)
        PropCost cost(const Space&, const ModEventDelta&) const {
            return PropCost::unary(PropCost::LO);
        }

        virtual size_t dispose(Space &home) {
            home.ignore(*this,AP_DISPOSE);
            c_.dispose(home);
            (void) Propagator::dispose(home);
            return sizeof(*this);
        }

        virtual ExecStatus advise(Space &home, Advisor &a, const Delta &d)
        {
            std::cout << static_cast<Watcher&>(a).b_.min(d) << " " <<
static_cast<Watcher&>(a).b_.max(d) << "\t" <<
static_cast<Watcher&>(a).b_.min() << " " <<
static_cast<Watcher&>(a).b_.max() << std::endl;
            Gecode::ModEvent e = static_cast<Watcher&>(a).b_.modevent(d);
//use this modevent
            if (e == Gecode::Int::ME_INT_BND)
            {
                if (!static_cast<Watcher&>(a).b_.any(d))
                {
                    if (static_cast<Watcher&>(a).b_.min(d) !=
static_cast<Watcher&>(a).b_.min()) // minimum has changed
                    {
                        ...
                    }
                    if (static_cast<Watcher&>(a).b_.max(d) !=
static_cast<Watcher&>(a).b_.max()) // maximum has changed
                    {
                        ...
                    }
                }
            }
            if (static_cast<Watcher&>(a).b_.assigned())
                return home.ES_FIX_DISPOSE(c_,static_cast<Watcher&>(a));
            else
                return ES_FIX;
        }


        virtual ExecStatus propagate(Space &home, const ModEventDelta &med)
        {
            return ES_FIX;
        }

    }; 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120821/ba49ffac/attachment-0001.html>

From ostrowsk at cs.uni-potsdam.de  Tue Aug 21 11:05:25 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Tue, 21 Aug 2012 11:05:25 +0200
Subject: [gecode-users] Writing Advisors
In-Reply-To: <026901cd7f76$cb5f47a0$621dd6e0$@kth.se>
References: <503342BF.4010500@cs.uni-potsdam.de>
	<026901cd7f76$cb5f47a0$621dd6e0$@kth.se>
Message-ID: <50334F55.4030400@cs.uni-potsdam.de>

I'm very sorry that I misinterpreted the manual.
But on page 288 you state
"Only if x.any(d) is false, x.min(d) returns the previously (that is,
the value before the domain modification) smallest value of x and
x.max(d) returns the previously largest value of x."
Isn't this the bounds of the old domain?


Unfortunately in the only example of the advise() function that uses the
Delta in the MPG (page 287) you use
Int::BoolView::zero(d)
to determine that the variable has been assigned to zero.

Could you just state me what the min(d)==0 and max(d)==5 means when the
domain is restricted from [0..10] to [6..10].

Thanks again for your patience.
Max


On 08/21/2012 10:27 AM, Christian Schulte wrote:
>
> Please read the examples in MPG again. It is not the old domain. It is
> the delta (as the name suggests).
>
>  
>
> Christian
>
>  
>
> --
>
> Christian Schulte, KTH, web.it.kth.se/~cschulte/
>
>  
>
> *From:* users-bounces at gecode.org [mailto:users-bounces at gecode.org] *On
> Behalf Of *Max Ostrowski
> *Sent:* Tuesday, August 21, 2012 10:12 AM
> *To:* users at gecode.org
> *Subject:* [gecode-users] Writing Advisors
>
>  
>
> Hi, i want to write an advisor for my propagator that gets notified
> when the
> watched variable changes it bounds.
> In the attached code, the advise method now prints the view min and max.
> According to the Gecode Documentation min(d)/max(d) return the old
> value of the variable,
> while min()/max() return the new value, is this correct?
>
> In my current test setting, i have only one variable "a=[0..10]"
> Then i add the constraint a>5.
> The advisor is called properly.
> The first line prints:
>
> 0 5 6 10
>
> This would mean that the domain of "a" before the progagation was
> [0..5] and now is [6..10].
> This of course can't be true (as they do not overlap).
> So how do I use the Delta Information correctly.
> I found no example actually using this information.
>
> 2nd Question:
> With my two if statements in the advisor method,
> will i catch all changes of the bounds? Or is it possible to catch more.
>
>
> Best,
> Max
>
> PS: Thanks for the possibility to remove all propagators.
>
> class Waiter : public Propagator {
>
>         ...
>
>         class Watcher  : public Advisor {
>         public:
>             Int::IntView b_;
>             unsigned int lowerVar_;
>             Watcher(Space& home, Propagator& p,
>                     Council<Watcher>& c, Int::IntView b, Clasp::Var lower)
>                 : Advisor(home,p,c), b_(b), lowerVar_(lower)
>             {
>                 b_.subscribe(home,*this);
>             }
>
>             Watcher(Space& home, bool share, Watcher& w)
>                 : Advisor(home,share,w), lowerVar_(w.lowerVar_)
>             {
>                 b_.update(home,share,w.b_);
>             }
>
>             void dispose(Space& home, Council<Watcher>& c)
>             {
>                 b_.cancel(home,*this);
>                 Advisor::dispose(home,c);
>             }
>         };
>         Council<Watcher> c_;
>     public:
>         Waiter(Space& home) : Propagator(home), c_(home)
>         {
>             home.notice(*this,AP_DISPOSE);
>         }
>
>         Waiter(Space& home, bool shared, Waiter& p)
>             : Propagator(home,shared,p)
>         {
>             c_.update(home,shared,p.c_);
>         }
>
>         void init(Space& home, GecodeSolver* csps, Int::IntView b,
> unsigned int varNumber)
>         {
>             solver = csps;
>             ...
>             (void) new (home) Watcher(home,*this,c_,b,varNumber);
>         }
>
>         /// Perform copying during cloning
>         virtual  Actor* copy(Space& home, bool share) {
>             return new (home) Waiter(home,share,*this);
>         }
>
>         /// Const function (defined as low unary)
>         PropCost cost(const Space&, const ModEventDelta&) const {
>             return PropCost::unary(PropCost::LO);
>         }
>
>         virtual size_t dispose(Space &home) {
>             home.ignore(*this,AP_DISPOSE);
>             c_.dispose(home);
>             (void) Propagator::dispose(home);
>             return sizeof(*this);
>         }
>
>         virtual ExecStatus advise(Space &home, Advisor &a, const Delta &d)
>         {
>             std::cout << static_cast<Watcher&>(a).b_.min(d) << " " <<
> static_cast<Watcher&>(a).b_.max(d) << "\t" <<
> static_cast<Watcher&>(a).b_.min() << " " <<
> static_cast<Watcher&>(a).b_.max() << std::endl;
>             Gecode::ModEvent e =
> static_cast<Watcher&>(a).b_.modevent(d); //use this modevent
>             if (e == Gecode::Int::ME_INT_BND)
>             {
>                 if (!static_cast<Watcher&>(a).b_.any(d))
>                 {
>                     if (static_cast<Watcher&>(a).b_.min(d) !=
> static_cast<Watcher&>(a).b_.min()) // minimum has changed
>                     {
>                         ...
>                     }
>                     if (static_cast<Watcher&>(a).b_.max(d) !=
> static_cast<Watcher&>(a).b_.max()) // maximum has changed
>                     {
>                         ...
>                     }
>                 }
>             }
>             if (static_cast<Watcher&>(a).b_.assigned())
>                 return home.ES_FIX_DISPOSE(c_,static_cast<Watcher&>(a));
>             else
>                 return ES_FIX;
>         }
>
>
>         virtual ExecStatus propagate(Space &home, const ModEventDelta
> &med)
>         {
>             return ES_FIX;
>         }
>
>     };
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120821/e5678b4c/attachment.html>

From cschulte at kth.se  Tue Aug 21 11:10:45 2012
From: cschulte at kth.se (Christian Schulte)
Date: Tue, 21 Aug 2012 11:10:45 +0200
Subject: [gecode-users] Writing Advisors
In-Reply-To: <50334F55.4030400@cs.uni-potsdam.de>
References: <503342BF.4010500@cs.uni-potsdam.de>
	<026901cd7f76$cb5f47a0$621dd6e0$@kth.se>
	<50334F55.4030400@cs.uni-potsdam.de>
Message-ID: <029701cd7f7c$d9a369d0$8cea3d70$@kth.se>

Oh damn, I have to fix the doc. It is really the delta: what has been
removed. So in your example, 0..5 has been removed, that is what the delta
tells you.

 

Christian

 

--

Christian Schulte, KTH, web.it.kth.se/~cschulte/

 

From: Max Ostrowski [mailto:ostrowsk at cs.uni-potsdam.de] 
Sent: Tuesday, August 21, 2012 11:05 AM
To: cschulte at kth.se
Cc: users at gecode.org
Subject: Re: [gecode-users] Writing Advisors

 

I'm very sorry that I misinterpreted the manual.
But on page 288 you state
"Only if x.any(d) is false, x.min(d) returns the previously (that is, the
value before the domain modification) smallest value of x and x.max(d)
returns the previously largest value of x."
Isn't this the bounds of the old domain?


Unfortunately in the only example of the advise() function that uses the
Delta in the MPG (page 287) you use 
Int::BoolView::zero(d)
to determine that the variable has been assigned to zero.

Could you just state me what the min(d)==0 and max(d)==5 means when the
domain is restricted from [0..10] to [6..10].

Thanks again for your patience.
Max


On 08/21/2012 10:27 AM, Christian Schulte wrote: 

Please read the examples in MPG again. It is not the old domain. It is the
delta (as the name suggests).

 

Christian

 

--

Christian Schulte, KTH, web.it.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Max Ostrowski
Sent: Tuesday, August 21, 2012 10:12 AM
To: users at gecode.org
Subject: [gecode-users] Writing Advisors

 

Hi, i want to write an advisor for my propagator that gets notified when the
watched variable changes it bounds.
In the attached code, the advise method now prints the view min and max.
According to the Gecode Documentation min(d)/max(d) return the old value of
the variable,
while min()/max() return the new value, is this correct?

In my current test setting, i have only one variable "a=[0..10]"
Then i add the constraint a>5.
The advisor is called properly.
The first line prints:

0 5 6 10

This would mean that the domain of "a" before the progagation was [0..5] and
now is [6..10].
This of course can't be true (as they do not overlap).
So how do I use the Delta Information correctly.
I found no example actually using this information.

2nd Question:
With my two if statements in the advisor method,
will i catch all changes of the bounds? Or is it possible to catch more.


Best,
Max

PS: Thanks for the possibility to remove all propagators.

class Waiter : public Propagator {

        ...

        class Watcher  : public Advisor {
        public:
            Int::IntView b_;
            unsigned int lowerVar_;
            Watcher(Space& home, Propagator& p,
                    Council<Watcher>& c, Int::IntView b, Clasp::Var lower)
                : Advisor(home,p,c), b_(b), lowerVar_(lower)
            {
                b_.subscribe(home,*this);
            }

            Watcher(Space& home, bool share, Watcher& w)
                : Advisor(home,share,w), lowerVar_(w.lowerVar_)
            {
                b_.update(home,share,w.b_);
            }

            void dispose(Space& home, Council<Watcher>& c)
            {
                b_.cancel(home,*this);
                Advisor::dispose(home,c);
            }
        };
        Council<Watcher> c_;
    public:
        Waiter(Space& home) : Propagator(home), c_(home)
        {
            home.notice(*this,AP_DISPOSE);
        }

        Waiter(Space& home, bool shared, Waiter& p)
            : Propagator(home,shared,p)
        {
            c_.update(home,shared,p.c_);
        }

        void init(Space& home, GecodeSolver* csps, Int::IntView b, unsigned
int varNumber)
        {
            solver = csps;
            ...
            (void) new (home) Watcher(home,*this,c_,b,varNumber);
        }

        /// Perform copying during cloning
        virtual  Actor* copy(Space& home, bool share) {
            return new (home) Waiter(home,share,*this);
        }

        /// Const function (defined as low unary)
        PropCost cost(const Space&, const ModEventDelta&) const {
            return PropCost::unary(PropCost::LO);
        }

        virtual size_t dispose(Space &home) {
            home.ignore(*this,AP_DISPOSE);
            c_.dispose(home);
            (void) Propagator::dispose(home);
            return sizeof(*this);
        }

        virtual ExecStatus advise(Space &home, Advisor &a, const Delta &d)
        {
            std::cout << static_cast<Watcher&>(a).b_.min(d) << " " <<
static_cast<Watcher&>(a).b_.max(d) << "\t" <<
static_cast<Watcher&>(a).b_.min() << " " <<
static_cast<Watcher&>(a).b_.max() << std::endl;
            Gecode::ModEvent e = static_cast<Watcher&>(a).b_.modevent(d);
//use this modevent
            if (e == Gecode::Int::ME_INT_BND)
            {
                if (!static_cast<Watcher&>(a).b_.any(d))
                {
                    if (static_cast<Watcher&>(a).b_.min(d) !=
static_cast<Watcher&>(a).b_.min()) // minimum has changed
                    {
                        ...
                    }
                    if (static_cast<Watcher&>(a).b_.max(d) !=
static_cast<Watcher&>(a).b_.max()) // maximum has changed
                    {
                        ...
                    }
                }
            }
            if (static_cast<Watcher&>(a).b_.assigned())
                return home.ES_FIX_DISPOSE(c_,static_cast<Watcher&>(a));
            else
                return ES_FIX;
        }


        virtual ExecStatus propagate(Space &home, const ModEventDelta &med)
        {
            return ES_FIX;
        }

    }; 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120821/33e7e94e/attachment-0001.html>

From jdunn at aquezada.com  Wed Aug 22 04:53:30 2012
From: jdunn at aquezada.com (Julian C. Dunn)
Date: Tue, 21 Aug 2012 22:53:30 -0400
Subject: [gecode-users] Fedora packaging Gecode
Message-ID: <1E7B4FAA-98BD-448C-A523-2109183C4215@aquezada.com>

All:

I am working on packaging Gecode into Fedora Linux. During the review process, my reviewer pointed out this problem with Gecode:

---

gecode.x86_64: W: shared-lib-calls-exit /usr/lib64/libgecodegist.so.32.0 exit at GLIBC_2.2.5

This library package calls exit() or _exit(), probably in a non-fork()
context. Doing so from a library is strongly discouraged - when a library
function calls exit(), it prevents the calling program from handling the
error, reporting it to the user, closing files properly, and cleaning up any
state that the program has. It is preferred for the library to return an
actual error code and let the calling program decide how to handle the
situation.

---

While they told me that this is not a blocker to inclusion in Fedora, they advised me to inform upstream (you) such that you might consider fixing it. Could you give me some feedback about that so I can append it to the review request?

- Julian

From tack at gecode.org  Wed Aug 22 08:30:12 2012
From: tack at gecode.org (Guido Tack)
Date: Wed, 22 Aug 2012 08:30:12 +0200
Subject: [gecode-users] Fedora packaging Gecode
In-Reply-To: <1E7B4FAA-98BD-448C-A523-2109183C4215@aquezada.com>
References: <1E7B4FAA-98BD-448C-A523-2109183C4215@aquezada.com>
Message-ID: <BF47AAB3-5F55-4B2F-8581-6ECAB959CEBE@gecode.org>

Hi Julian,

this has come up a number of times.  The exit is only called when a buggy callback (i.e. user code) throws an exception in Gist.  I'll have a look and display an error dialog instead.

Cheers,
Guido

-- 
Guido Tack
http://www.csse.monash.edu/~guidot/



On 22/08/2012, at 4:53 AM, "Julian C. Dunn" <jdunn at aquezada.com> wrote:

> All:
> 
> I am working on packaging Gecode into Fedora Linux. During the review process, my reviewer pointed out this problem with Gecode:
> 
> ---
> 
> gecode.x86_64: W: shared-lib-calls-exit /usr/lib64/libgecodegist.so.32.0 exit at GLIBC_2.2.5
> 
> This library package calls exit() or _exit(), probably in a non-fork()
> context. Doing so from a library is strongly discouraged - when a library
> function calls exit(), it prevents the calling program from handling the
> error, reporting it to the user, closing files properly, and cleaning up any
> state that the program has. It is preferred for the library to return an
> actual error code and let the calling program decide how to handle the
> situation.
> 
> ---
> 
> While they told me that this is not a blocker to inclusion in Fedora, they advised me to inform upstream (you) such that you might consider fixing it. Could you give me some feedback about that so I can append it to the review request?
> 
> - Julian
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120822/6019d746/attachment.html>

From elinyong at gmail.com  Wed Aug 22 15:16:42 2012
From: elinyong at gmail.com (Yong LIN)
Date: Wed, 22 Aug 2012 21:16:42 +0800
Subject: [gecode-users] regarding the advisors in GeCode
Message-ID: <CADfnOYvyYvYETjDUyk6qwiUwKgbehzBQwjSfUQmcaefhTqZCVA@mail.gmail.com>

Hi All,

I have a few questions regarding the structure of advisor in the GeCode
system ask for your advices.

1. I see that a propagator maintains a list of advisors and each advisor
monitors one of the variables that the propagator subscribes. I am
wondering whether it is certain that every variable of a propagator will be
monitored by one and only one advisor respectively in current propagator
(from variable's perspective, it is possible to have multiple advisors,
since a variable could be subscribed by more than one propagator) ?  and
every propagator in a space should have a list of advisors for its
variables?

2. I see that the constraint propagation is conducted through executing
propagators scheduled in a queue. But, when I attempt to access the list of
advisors of a executing propagator (by p -> u.advisors, which should return
the pointer to the head of the advisor list of the propagator),  I get a
NULL pointer. I am wondering what's is the reason for not being able to
access the advisors of a propagator. Whether we need explicitly switch it
on?

Thanks very much for your advices in advance!
best regards,
Lin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120822/7991ed69/attachment.html>

From cschulte at kth.se  Wed Aug 22 16:16:13 2012
From: cschulte at kth.se (Christian Schulte)
Date: Wed, 22 Aug 2012 16:16:13 +0200
Subject: [gecode-users] regarding the advisors in GeCode
In-Reply-To: <CADfnOYvyYvYETjDUyk6qwiUwKgbehzBQwjSfUQmcaefhTqZCVA@mail.gmail.com>
References: <CADfnOYvyYvYETjDUyk6qwiUwKgbehzBQwjSfUQmcaefhTqZCVA@mail.gmail.com>
Message-ID: <004201cd8070$b0767c60$11637520$@kth.se>

Hi,

 

Please read the documentation first.

 

Christian

 

--

Christian Schulte, KTH, web.it.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Yong LIN
Sent: Wednesday, August 22, 2012 3:17 PM
To: users at gecode.org
Subject: [gecode-users] regarding the advisors in GeCode

 

Hi All,

I have a few questions regarding the structure of advisor in the GeCode
system ask for your advices.

1. I see that a propagator maintains a list of advisors and each advisor
monitors one of the variables that the propagator subscribes. I am wondering
whether it is certain that every variable of a propagator will be monitored
by one and only one advisor respectively in current propagator (from
variable's perspective, it is possible to have multiple advisors, since a
variable could be subscribed by more than one propagator) ?  and every
propagator in a space should have a list of advisors for its variables? 

2. I see that the constraint propagation is conducted through executing
propagators scheduled in a queue. But, when I attempt to access the list of
advisors of a executing propagator (by p -> u.advisors, which should return
the pointer to the head of the advisor list of the propagator),  I get a
NULL pointer. I am wondering what's is the reason for not being able to
access the advisors of a propagator. Whether we need explicitly switch it
on? 
 
Thanks very much for your advices in advance!
best regards,
Lin 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120822/2c02d1bc/attachment.html>

From ostrowsk at cs.uni-potsdam.de  Thu Aug 23 12:08:11 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Thu, 23 Aug 2012 12:08:11 +0200
Subject: [gecode-users] Propagating to Fixpoint
Message-ID: <5036010B.90505@cs.uni-potsdam.de>

Can the order of propagation influence the final result?


Given a list of reified constraints L posted with ICL_DEF

for (i in L)
{
i == true;
status();
}

// the space is failed

Now the same thing with the list sorted by some order

randomize_order(L)
for (i in L)
{
i == true;
status();
}

// the space not failed



Can this happen (not using circuit and nvalues) only usign linear
constraints.
Why does this happen.


Best,
Max



From tack at gecode.org  Thu Aug 23 12:40:03 2012
From: tack at gecode.org (Guido Tack)
Date: Thu, 23 Aug 2012 12:40:03 +0200
Subject: [gecode-users] Propagating to Fixpoint
In-Reply-To: <5036010B.90505@cs.uni-potsdam.de>
References: <5036010B.90505@cs.uni-potsdam.de>
Message-ID: <2E93DC33-2B0F-4FA9-A261-2273F3F718C1@gecode.org>

I guess under certain conditions the code that posts the constraints (not the actual propagator) can be stronger than ICL_DEF, in which case this can happen.
If it's not too complicated, could you send us a concrete example?

Cheers,
Guido

-- 
Guido Tack


On 23/08/2012, at 12:08, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:

> Can the order of propagation influence the final result?
> 
> 
> Given a list of reified constraints L posted with ICL_DEF
> 
> for (i in L)
> {
> i == true;
> status();
> }
> 
> // the space is failed
> 
> Now the same thing with the list sorted by some order
> 
> randomize_order(L)
> for (i in L)
> {
> i == true;
> status();
> }
> 
> // the space not failed
> 
> 
> 
> Can this happen (not using circuit and nvalues) only usign linear
> constraints.
> Why does this happen.
> 
> 
> Best,
> Max
> 
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users


From ostrowsk at cs.uni-potsdam.de  Thu Aug 23 13:20:23 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Thu, 23 Aug 2012 13:20:23 +0200
Subject: [gecode-users] Propagating to Fixpoint
In-Reply-To: <2E93DC33-2B0F-4FA9-A261-2273F3F718C1@gecode.org>
References: <5036010B.90505@cs.uni-potsdam.de>
	<2E93DC33-2B0F-4FA9-A261-2273F3F718C1@gecode.org>
Message-ID: <503611F7.1050905@cs.uni-potsdam.de>

Actually its quite complicated.
I'm currently debugging and have 60 constraints written on paper that
have this effect.
Two of them are actually not reified constraints but directly using
IntView::lq(constant)

I can give you a description where it happens in my system, but it will
be a mess for you to write simplified code that reproduces this.

Actually given two spaces original1 and original2 that are equal,
variables are constraint like this:

posx(6)=[0..185] posx(5)=[0..190] posx(4)=[0..142] posx(3)=[0..158]
posx(2)=[0..113] posx(1)=[0..157]


all reified constraints are posted with free boolean variables, using



linear(*this, intArgs, intVarArgs, r,0,b_[boolvar],ICL_DEF);

Now i set the boolean variables accordingly, always doing propagation
(calling status()) after each single posting

To original1 false ((-1 $* posx(3))+posx(1))$<=0

To original1 false ( 10+(-1 $* posx(6))+posx(5))$>0
To original1 false ( 58+(-1 $* posx(5))+posx(4))$>0
To original1 true posx(6)<=69                            // this is no
reified constraint, but just posted IntView(posx(6)).lq(69)
To original1 false ( 43+(-1 $* posx(6))+posx(1))$>0
To original1 false ((-1 $* posx(5))+posx(2))$<=0
To original1 true ((-1 $* posx(1))+posx(3))$<=0
To original1 true ((-1 $* posx(4))+posx(3))$<=0
To original1 false ( 42+(-1 $* posx(5))+posx(3))$>0
To original1 false ( 42+(-1 $* posx(6))+posx(3))$>0
To original1 true ( -42+(-1 $* posx(3))+posx(1))$<0
To original1 true ( -15+(-1 $* posx(6))+posx(1))$<0
To original1 true ( 58+(-1 $* posx(1))+posx(4))$>0
To original1 true ( 42+(-1 $* posx(1))+posx(3))$>0
To original1 false ((-1 $* posx(1))+posx(2))$<=0
To original1 true ((-1 $* posx(6))+posx(1))$<=0
To original1 true ((-1 $* posx(5))+posx(1))$<=0
To original1 true ( -10+(-1 $* posx(5))+posx(1))$<0
To original1 true ((-1 $* posx(2))+posx(1))$<=0
To original1 false ( 43+(-1 $* posx(2))+posx(1))$>0
To original1 true ( -28+(-1 $* posx(1))+posx(6))$>0
To original1 false ( 28+(-1 $* posx(6))+posx(1))$>0
To original1 false ( -43+(-1 $* posx(1))+posx(2))$<0
To original1 true ( -58+(-1 $* posx(4))+posx(1))$<0
To original1 true posx(1)<=29                          // this is no
reified constraint, but just posted IntView(posx(1)).lq(29)
To original1 false ((-1 $* posx(1))+posx(4))$<=0       // lets call this
constraint X

Now this space is failed.

Something similar with the second space, but posting nr. 5 is different.

To original2 false ((-1 $* posx(3))+posx(1))$<=0
To original2 false ( 10+(-1 $* posx(6))+posx(5))$>0
To original2 false ( 58+(-1 $* posx(5))+posx(4))$>0
To original2 false ((-1 $* posx(1))+posx(4))$<=0       // this is
constraint X, it is now posted on this position, no longer as the last
constraint anymore
To original2 true posx(6)<=69                          // this is no
reified constraint, but just posted IntView(posx(6)).lq(69)
To original2 false ( 43+(-1 $* posx(6))+posx(1))$>0
To original2 false ((-1 $* posx(5))+posx(2))$<=0
To original2 true ((-1 $* posx(1))+posx(3))$<=0
To original2 true ((-1 $* posx(4))+posx(3))$<=0
To original2 false ( 42+(-1 $* posx(5))+posx(3))$>0
To original2 false ( 42+(-1 $* posx(6))+posx(3))$>0
To original2 true ( -42+(-1 $* posx(3))+posx(1))$<0
To original2 true ( -15+(-1 $* posx(6))+posx(1))$<0
To original2 true ( 58+(-1 $* posx(1))+posx(4))$>0
To original2 true ( 42+(-1 $* posx(1))+posx(3))$>0
To original2 false ((-1 $* posx(1))+posx(2))$<=0
To original2 true ((-1 $* posx(6))+posx(1))$<=0
To original2 true ((-1 $* posx(5))+posx(1))$<=0
To original2 true ( -10+(-1 $* posx(5))+posx(1))$<0
To original2 true ((-1 $* posx(2))+posx(1))$<=0
To original2 false ( 43+(-1 $* posx(2))+posx(1))$>0
To original2 true ( -28+(-1 $* posx(1))+posx(6))$>0
To original2 false ( 28+(-1 $* posx(6))+posx(1))$>0
To original2 false ( -43+(-1 $* posx(1))+posx(2))$<0
To original2 true ( -58+(-1 $* posx(4))+posx(1))$<0
To original2 true posx(1)<=29                                        //
this is no reified constraint, but just posted IntView(posx(1)).lq(29)

This Space is not failed




I know this is quite a huge blob of data and you probably wont have the
time to reconstruct it.
I will just have to adjust my code that this can happen.
BTW: Can you confirm that this is due to the use of IntView::lq ?
I never experienced this without them.

Best,
Max




On 08/23/2012 12:40 PM, Guido Tack wrote:
> I guess under certain conditions the code that posts the constraints (not the actual propagator) can be stronger than ICL_DEF, in which case this can happen.
> If it's not too complicated, could you send us a concrete example?
>
> Cheers,
> Guido
>
>   

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120823/4026e836/attachment.html>

From tack at gecode.org  Thu Aug 23 13:44:35 2012
From: tack at gecode.org (Guido Tack)
Date: Thu, 23 Aug 2012 13:44:35 +0200
Subject: [gecode-users] Propagating to Fixpoint
In-Reply-To: <503611F7.1050905@cs.uni-potsdam.de>
References: <5036010B.90505@cs.uni-potsdam.de>
	<2E93DC33-2B0F-4FA9-A261-2273F3F718C1@gecode.org>
	<503611F7.1050905@cs.uni-potsdam.de>
Message-ID: <8AF9CF15-CE97-4F36-A94B-B72FEDCFF10B@gecode.org>

Without looking at the details: Do you check the return value of IntView::lq?  The view functions are not meant to be used in models. If lq returns failure, you have to check that yourself, or the space won't be failed.

Cheers,
Guido

-- 
Guido Tack


On 23/08/2012, at 13:20, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:

> Actually its quite complicated.
> I'm currently debugging and have 60 constraints written on paper that have this effect.
> Two of them are actually not reified constraints but directly using IntView::lq(constant)
> 
> I can give you a description where it happens in my system, but it will be a mess for you to write simplified code that reproduces this.
> 
> Actually given two spaces original1 and original2 that are equal,
> variables are constraint like this:
> posx(6)=[0..185]
> posx(5)=[0..190] posx(4)=[0..142] posx(3)=[0..158] posx(2)=[0..113]
> posx(1)=[0..157]
> 
> 
> 
> all
> reified constraints are posted with free boolean variables, using
> 
> 
> 
> linear(*this, intArgs, intVarArgs, r,0,b_[boolvar],ICL_DEF);
> 
> Now i set the boolean variables accordingly, always doing propagation (calling status()) after each single posting
> 
> To
> original1 false ((-1 $* posx(3))+posx(1))$<=0
> To original1 false ( 10+(-1 $* posx(6))+posx(5))$>0
> To original1 false ( 58+(-1 $* posx(5))+posx(4))$>0
> To original1 true posx(6)<=69                            // this is no reified constraint, but just posted IntView(posx(6)).lq(69)
> To original1 false ( 43+(-1 $* posx(6))+posx(1))$>0
> To original1 false ((-1 $* posx(5))+posx(2))$<=0
> To original1 true ((-1 $* posx(1))+posx(3))$<=0
> To original1 true ((-1 $* posx(4))+posx(3))$<=0
> To original1 false ( 42+(-1 $* posx(5))+posx(3))$>0
> To original1 false ( 42+(-1 $* posx(6))+posx(3))$>0
> To original1 true ( -42+(-1 $* posx(3))+posx(1))$<0
> To original1 true ( -15+(-1 $* posx(6))+posx(1))$<0
> To original1 true ( 58+(-1 $* posx(1))+posx(4))$>0
> To original1 true ( 42+(-1 $* posx(1))+posx(3))$>0
> To original1 false ((-1 $* posx(1))+posx(2))$<=0
> To original1 true ((-1 $* posx(6))+posx(1))$<=0
> To original1 true ((-1 $* posx(5))+posx(1))$<=0
> To original1 true ( -10+(-1 $* posx(5))+posx(1))$<0
> To original1 true ((-1 $* posx(2))+posx(1))$<=0
> To original1 false ( 43+(-1 $* posx(2))+posx(1))$>0
> To original1 true ( -28+(-1 $* posx(1))+posx(6))$>0
> To original1 false ( 28+(-1 $* posx(6))+posx(1))$>0
> To original1 false ( -43+(-1 $* posx(1))+posx(2))$<0
> To original1 true ( -58+(-1 $* posx(4))+posx(1))$<0
> To original1 true posx(1)<=29                          // this is no reified constraint, but just posted IntView(posx(1)).lq(29)
> To original1 false ((-1 $* posx(1))+posx(4))$<=0       // lets call this constraint X
> 
> Now this space is failed.
> 
> Something similar with the second space, but posting nr. 5 is different.
> 
> To original2 false ((-1 $* posx(3))+posx(1))$<=0
> To original2 false ( 10+(-1 $* posx(6))+posx(5))$>0
> To original2 false ( 58+(-1 $* posx(5))+posx(4))$>0
> To original2 false ((-1 $* posx(1))+posx(4))$<=0       // this is constraint X, it is now posted on this position, no longer as the last constraint anymore
> To original2 true posx(6)<=69                          // this is no reified constraint, but just posted IntView(posx(6)).lq(69)
> To original2 false ( 43+(-1 $* posx(6))+posx(1))$>0
> To original2 false ((-1 $* posx(5))+posx(2))$<=0
> To original2 true ((-1 $* posx(1))+posx(3))$<=0
> To original2 true ((-1 $* posx(4))+posx(3))$<=0
> To original2 false ( 42+(-1 $* posx(5))+posx(3))$>0
> To original2 false ( 42+(-1 $* posx(6))+posx(3))$>0
> To original2 true ( -42+(-1 $* posx(3))+posx(1))$<0
> To original2 true ( -15+(-1 $* posx(6))+posx(1))$<0
> To original2 true ( 58+(-1 $* posx(1))+posx(4))$>0
> To original2 true ( 42+(-1 $* posx(1))+posx(3))$>0
> To original2 false ((-1 $* posx(1))+posx(2))$<=0
> To original2 true ((-1 $* posx(6))+posx(1))$<=0
> To original2 true ((-1 $* posx(5))+posx(1))$<=0
> To original2 true ( -10+(-1 $* posx(5))+posx(1))$<0
> To original2 true ((-1 $* posx(2))+posx(1))$<=0
> To original2 false ( 43+(-1 $* posx(2))+posx(1))$>0
> To original2 true ( -28+(-1 $* posx(1))+posx(6))$>0
> To original2 false ( 28+(-1 $* posx(6))+posx(1))$>0
> To original2 false ( -43+(-1 $* posx(1))+posx(2))$<0
> To original2 true ( -58+(-1 $* posx(4))+posx(1))$<0
> To original2 true posx(1)<=29                                        // this is no reified constraint, but just posted IntView(posx(1)).lq(29)
> 
> This Space is not failed
> 
> 
> 
> 
> I know this is quite a huge blob of data and you probably wont have the time to reconstruct it.
> I will just have to adjust my code that this can happen.
> BTW: Can you confirm that this is due to the use of IntView::lq ?
> I never experienced this without them.
> 
> Best,
> Max
> 
> 
> 
> 
> On 08/23/2012 12:40 PM, Guido Tack wrote:
>> 
>> I guess under certain conditions the code that posts the constraints (not the actual propagator) can be stronger than ICL_DEF, in which case this can happen.
>> If it's not too complicated, could you send us a concrete example?
>> 
>> Cheers,
>> Guido
>> 
>>   
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120823/82aea58c/attachment-0001.html>

From ostrowsk at cs.uni-potsdam.de  Thu Aug 23 14:04:30 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Thu, 23 Aug 2012 14:04:30 +0200
Subject: [gecode-users] Propagating to Fixpoint
In-Reply-To: <8AF9CF15-CE97-4F36-A94B-B72FEDCFF10B@gecode.org>
References: <5036010B.90505@cs.uni-potsdam.de>
	<2E93DC33-2B0F-4FA9-A261-2273F3F718C1@gecode.org>
	<503611F7.1050905@cs.uni-potsdam.de>
	<8AF9CF15-CE97-4F36-A94B-B72FEDCFF10B@gecode.org>
Message-ID: <50361C4E.3030403@cs.uni-potsdam.de>

Great, this really solves the problem.
Have not thought of this.
Thank you very very much.
In my example everything works as expected and the fixpoint is always
the same.
Are you sure that it can still happen that the fixpoint of the same set
of constraints is different,
if i use a different order?
Then i have to stick to my fallback method.


Nevertheless,
big thanks for solving my problem. Everything works now and is a hundred
times faster :)

Best,
Max

On 08/23/2012 01:44 PM, Guido Tack wrote:
> Without looking at the details: Do you check the return value of
> IntView::lq?  The view functions are not meant to be used in models.
> If lq returns failure, you have to check that yourself, or the space
> won't be failed.
>
> Cheers,
> Guido
>
> -- 
> Guido Tack
>
>
> On 23/08/2012, at 13:20, Max Ostrowski <ostrowsk at cs.uni-potsdam.de
> <mailto:ostrowsk at cs.uni-potsdam.de>> wrote:
>
>> Actually its quite complicated.
>> I'm currently debugging and have 60 constraints written on paper that
>> have this effect.
>> Two of them are actually not reified constraints but directly using
>> IntView::lq(constant)
>>
>> I can give you a description where it happens in my system, but it
>> will be a mess for you to write simplified code that reproduces this.
>>
>> Actually given two spaces original1 and original2 that are equal,
>> variables are constraint like this:
>>
>> posx(6)=[0..185] posx(5)=[0..190] posx(4)=[0..142] posx(3)=[0..158]
>> posx(2)=[0..113] posx(1)=[0..157]
>>
>>
>> all reified constraints are posted with free boolean variables, using
>>
>>
>>
>> linear(*this, intArgs, intVarArgs, r,0,b_[boolvar],ICL_DEF);
>>
>> Now i set the boolean variables accordingly, always doing propagation
>> (calling status()) after each single posting
>>
>> To original1 false ((-1 $* posx(3))+posx(1))$<=0
>>
>> To original1 false ( 10+(-1 $* posx(6))+posx(5))$>0
>> To original1 false ( 58+(-1 $* posx(5))+posx(4))$>0
>> To original1 true posx(6)<=69                            // this is
>> no reified constraint, but just posted IntView(posx(6)).lq(69)
>> To original1 false ( 43+(-1 $* posx(6))+posx(1))$>0
>> To original1 false ((-1 $* posx(5))+posx(2))$<=0
>> To original1 true ((-1 $* posx(1))+posx(3))$<=0
>> To original1 true ((-1 $* posx(4))+posx(3))$<=0
>> To original1 false ( 42+(-1 $* posx(5))+posx(3))$>0
>> To original1 false ( 42+(-1 $* posx(6))+posx(3))$>0
>> To original1 true ( -42+(-1 $* posx(3))+posx(1))$<0
>> To original1 true ( -15+(-1 $* posx(6))+posx(1))$<0
>> To original1 true ( 58+(-1 $* posx(1))+posx(4))$>0
>> To original1 true ( 42+(-1 $* posx(1))+posx(3))$>0
>> To original1 false ((-1 $* posx(1))+posx(2))$<=0
>> To original1 true ((-1 $* posx(6))+posx(1))$<=0
>> To original1 true ((-1 $* posx(5))+posx(1))$<=0
>> To original1 true ( -10+(-1 $* posx(5))+posx(1))$<0
>> To original1 true ((-1 $* posx(2))+posx(1))$<=0
>> To original1 false ( 43+(-1 $* posx(2))+posx(1))$>0
>> To original1 true ( -28+(-1 $* posx(1))+posx(6))$>0
>> To original1 false ( 28+(-1 $* posx(6))+posx(1))$>0
>> To original1 false ( -43+(-1 $* posx(1))+posx(2))$<0
>> To original1 true ( -58+(-1 $* posx(4))+posx(1))$<0
>> To original1 true posx(1)<=29                          // this is no
>> reified constraint, but just posted IntView(posx(1)).lq(29)
>> To original1 false ((-1 $* posx(1))+posx(4))$<=0       // lets call
>> this constraint X
>>
>> Now this space is failed.
>>
>> Something similar with the second space, but posting nr. 5 is different.
>>
>> To original2 false ((-1 $* posx(3))+posx(1))$<=0
>> To original2 false ( 10+(-1 $* posx(6))+posx(5))$>0
>> To original2 false ( 58+(-1 $* posx(5))+posx(4))$>0
>> To original2 false ((-1 $* posx(1))+posx(4))$<=0       // this is
>> constraint X, it is now posted on this position, no longer as the
>> last constraint anymore
>> To original2 true posx(6)<=69                          // this is no
>> reified constraint, but just posted IntView(posx(6)).lq(69)
>> To original2 false ( 43+(-1 $* posx(6))+posx(1))$>0
>> To original2 false ((-1 $* posx(5))+posx(2))$<=0
>> To original2 true ((-1 $* posx(1))+posx(3))$<=0
>> To original2 true ((-1 $* posx(4))+posx(3))$<=0
>> To original2 false ( 42+(-1 $* posx(5))+posx(3))$>0
>> To original2 false ( 42+(-1 $* posx(6))+posx(3))$>0
>> To original2 true ( -42+(-1 $* posx(3))+posx(1))$<0
>> To original2 true ( -15+(-1 $* posx(6))+posx(1))$<0
>> To original2 true ( 58+(-1 $* posx(1))+posx(4))$>0
>> To original2 true ( 42+(-1 $* posx(1))+posx(3))$>0
>> To original2 false ((-1 $* posx(1))+posx(2))$<=0
>> To original2 true ((-1 $* posx(6))+posx(1))$<=0
>> To original2 true ((-1 $* posx(5))+posx(1))$<=0
>> To original2 true ( -10+(-1 $* posx(5))+posx(1))$<0
>> To original2 true ((-1 $* posx(2))+posx(1))$<=0
>> To original2 false ( 43+(-1 $* posx(2))+posx(1))$>0
>> To original2 true ( -28+(-1 $* posx(1))+posx(6))$>0
>> To original2 false ( 28+(-1 $* posx(6))+posx(1))$>0
>> To original2 false ( -43+(-1 $* posx(1))+posx(2))$<0
>> To original2 true ( -58+(-1 $* posx(4))+posx(1))$<0
>> To original2 true posx(1)<=29                                       
>> // this is no reified constraint, but just posted IntView(posx(1)).lq(29)
>>
>> This Space is not failed
>>
>>
>>
>>
>> I know this is quite a huge blob of data and you probably wont have
>> the time to reconstruct it.
>> I will just have to adjust my code that this can happen.
>> BTW: Can you confirm that this is due to the use of IntView::lq ?
>> I never experienced this without them.
>>
>> Best,
>> Max
>>
>>
>>
>>
>> On 08/23/2012 12:40 PM, Guido Tack wrote:
>>> I guess under certain conditions the code that posts the constraints (not the actual propagator) can be stronger than ICL_DEF, in which case this can happen.
>>> If it's not too complicated, could you send us a concrete example?
>>>
>>> Cheers,
>>> Guido
>>>
>>>   
>>
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org <mailto:users at gecode.org>
>> https://www.gecode.org/mailman/listinfo/gecode-users

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120823/b6df6a10/attachment.html>

From tack at gecode.org  Thu Aug 23 16:16:37 2012
From: tack at gecode.org (Guido Tack)
Date: Thu, 23 Aug 2012 16:16:37 +0200
Subject: [gecode-users] Propagating to Fixpoint
In-Reply-To: <50361C4E.3030403@cs.uni-potsdam.de>
References: <5036010B.90505@cs.uni-potsdam.de>
	<2E93DC33-2B0F-4FA9-A261-2273F3F718C1@gecode.org>
	<503611F7.1050905@cs.uni-potsdam.de>
	<8AF9CF15-CE97-4F36-A94B-B72FEDCFF10B@gecode.org>
	<50361C4E.3030403@cs.uni-potsdam.de>
Message-ID: <652EA5EF-7F1E-443B-B5CF-316DC31B1A46@gecode.org>

I'm not sure, I just think there could be cases where (especially if you use MiniModel) the posting function does some additional reasoning.

Cheers,
Guido

-- 
Guido Tack
http://www.csse.monash.edu/~guidot/



On 23/08/2012, at 2:04 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:

> Great, this really solves the problem.
> Have not thought of this.
> Thank you very very much.
> In my example everything works as expected and the fixpoint is always the same.
> Are you sure that it can still happen that the fixpoint of the same set of constraints is different,
> if i use a different order?
> Then i have to stick to my fallback method.
> 
> 
> Nevertheless,
> big thanks for solving my problem. Everything works now and is a hundred times faster :)
> 
> Best,
> Max
> 
> On 08/23/2012 01:44 PM, Guido Tack wrote:
>> 
>> Without looking at the details: Do you check the return value of IntView::lq?  The view functions are not meant to be used in models. If lq returns failure, you have to check that yourself, or the space won't be failed.
>> 
>> Cheers,
>> Guido
>> 
>> -- 
>> Guido Tack
>> 
>> 
>> On 23/08/2012, at 13:20, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:
>> 
>>> Actually its quite complicated.
>>> I'm currently debugging and have 60 constraints written on paper that have this effect.
>>> Two of them are actually not reified constraints but directly using IntView::lq(constant)
>>> 
>>> I can give you a description where it happens in my system, but it will be a mess for you to write simplified code that reproduces this.
>>> 
>>> Actually given two spaces original1 and original2 that are equal,
>>> variables are constraint like this:
>>> posx(6)=[0..185] posx(5)=[0..190] posx(4)=[0..142] posx(3)=[0..158] posx(2)=[0..113] posx(1)=[0..157]
>>> 
>>> all reified constraints are posted with free boolean variables, using
>>> 
>>> 
>>> linear(*this, intArgs, intVarArgs, r,0,b_[boolvar],ICL_DEF);
>>> 
>>> Now i set the boolean variables accordingly, always doing propagation (calling status()) after each single posting
>>> 
>>> To original1 false ((-1 $* posx(3))+posx(1))$<=0
>>> To original1 false ( 10+(-1 $* posx(6))+posx(5))$>0
>>> To original1 false ( 58+(-1 $* posx(5))+posx(4))$>0
>>> To original1 true posx(6)<=69                            // this is no reified constraint, but just posted IntView(posx(6)).lq(69)
>>> To original1 false ( 43+(-1 $* posx(6))+posx(1))$>0
>>> To original1 false ((-1 $* posx(5))+posx(2))$<=0
>>> To original1 true ((-1 $* posx(1))+posx(3))$<=0
>>> To original1 true ((-1 $* posx(4))+posx(3))$<=0
>>> To original1 false ( 42+(-1 $* posx(5))+posx(3))$>0
>>> To original1 false ( 42+(-1 $* posx(6))+posx(3))$>0
>>> To original1 true ( -42+(-1 $* posx(3))+posx(1))$<0
>>> To original1 true ( -15+(-1 $* posx(6))+posx(1))$<0
>>> To original1 true ( 58+(-1 $* posx(1))+posx(4))$>0
>>> To original1 true ( 42+(-1 $* posx(1))+posx(3))$>0
>>> To original1 false ((-1 $* posx(1))+posx(2))$<=0
>>> To original1 true ((-1 $* posx(6))+posx(1))$<=0
>>> To original1 true ((-1 $* posx(5))+posx(1))$<=0
>>> To original1 true ( -10+(-1 $* posx(5))+posx(1))$<0
>>> To original1 true ((-1 $* posx(2))+posx(1))$<=0
>>> To original1 false ( 43+(-1 $* posx(2))+posx(1))$>0
>>> To original1 true ( -28+(-1 $* posx(1))+posx(6))$>0
>>> To original1 false ( 28+(-1 $* posx(6))+posx(1))$>0
>>> To original1 false ( -43+(-1 $* posx(1))+posx(2))$<0
>>> To original1 true ( -58+(-1 $* posx(4))+posx(1))$<0
>>> To original1 true posx(1)<=29                          // this is no reified constraint, but just posted IntView(posx(1)).lq(29)
>>> To original1 false ((-1 $* posx(1))+posx(4))$<=0       // lets call this constraint X
>>> 
>>> Now this space is failed.
>>> 
>>> Something similar with the second space, but posting nr. 5 is different.
>>> 
>>> To original2 false ((-1 $* posx(3))+posx(1))$<=0
>>> To original2 false ( 10+(-1 $* posx(6))+posx(5))$>0
>>> To original2 false ( 58+(-1 $* posx(5))+posx(4))$>0
>>> To original2 false ((-1 $* posx(1))+posx(4))$<=0       // this is constraint X, it is now posted on this position, no longer as the last constraint anymore
>>> To original2 true posx(6)<=69                          // this is no reified constraint, but just posted IntView(posx(6)).lq(69)
>>> To original2 false ( 43+(-1 $* posx(6))+posx(1))$>0
>>> To original2 false ((-1 $* posx(5))+posx(2))$<=0
>>> To original2 true ((-1 $* posx(1))+posx(3))$<=0
>>> To original2 true ((-1 $* posx(4))+posx(3))$<=0
>>> To original2 false ( 42+(-1 $* posx(5))+posx(3))$>0
>>> To original2 false ( 42+(-1 $* posx(6))+posx(3))$>0
>>> To original2 true ( -42+(-1 $* posx(3))+posx(1))$<0
>>> To original2 true ( -15+(-1 $* posx(6))+posx(1))$<0
>>> To original2 true ( 58+(-1 $* posx(1))+posx(4))$>0
>>> To original2 true ( 42+(-1 $* posx(1))+posx(3))$>0
>>> To original2 false ((-1 $* posx(1))+posx(2))$<=0
>>> To original2 true ((-1 $* posx(6))+posx(1))$<=0
>>> To original2 true ((-1 $* posx(5))+posx(1))$<=0
>>> To original2 true ( -10+(-1 $* posx(5))+posx(1))$<0
>>> To original2 true ((-1 $* posx(2))+posx(1))$<=0
>>> To original2 false ( 43+(-1 $* posx(2))+posx(1))$>0
>>> To original2 true ( -28+(-1 $* posx(1))+posx(6))$>0
>>> To original2 false ( 28+(-1 $* posx(6))+posx(1))$>0
>>> To original2 false ( -43+(-1 $* posx(1))+posx(2))$<0
>>> To original2 true ( -58+(-1 $* posx(4))+posx(1))$<0
>>> To original2 true posx(1)<=29                                        // this is no reified constraint, but just posted IntView(posx(1)).lq(29)
>>> 
>>> This Space is not failed
>>> 
>>> 
>>> 
>>> 
>>> I know this is quite a huge blob of data and you probably wont have the time to reconstruct it.
>>> I will just have to adjust my code that this can happen.
>>> BTW: Can you confirm that this is due to the use of IntView::lq ?
>>> I never experienced this without them.
>>> 
>>> Best,
>>> Max
>>> 
>>> 
>>> 
>>> 
>>> On 08/23/2012 12:40 PM, Guido Tack wrote:
>>>> 
>>>> I guess under certain conditions the code that posts the constraints (not the actual propagator) can be stronger than ICL_DEF, in which case this can happen.
>>>> If it's not too complicated, could you send us a concrete example?
>>>> 
>>>> Cheers,
>>>> Guido
>>>> 
>>>>   
>>> 
>>> _______________________________________________
>>> Gecode users mailing list
>>> users at gecode.org
>>> https://www.gecode.org/mailman/listinfo/gecode-users
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120823/6be381d2/attachment-0001.html>

From ostrowsk at cs.uni-potsdam.de  Thu Aug 23 16:20:01 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Thu, 23 Aug 2012 16:20:01 +0200
Subject: [gecode-users] Propagating to Fixpoint
In-Reply-To: <652EA5EF-7F1E-443B-B5CF-316DC31B1A46@gecode.org>
References: <5036010B.90505@cs.uni-potsdam.de>
	<2E93DC33-2B0F-4FA9-A261-2273F3F718C1@gecode.org>
	<503611F7.1050905@cs.uni-potsdam.de>
	<8AF9CF15-CE97-4F36-A94B-B72FEDCFF10B@gecode.org>
	<50361C4E.3030403@cs.uni-potsdam.de>
	<652EA5EF-7F1E-443B-B5CF-316DC31B1A46@gecode.org>
Message-ID: <50363C11.3090802@cs.uni-potsdam.de>

I have rewritten my code to compute the domains of the intermediate
variables myself and now do not use minimodel anymore.
(Mainly because the consistency given by ICL was ignored).
So if you somewhen find out if or if not this can happen (without using
MiniModel) it would be nice to know.

Best,
Max

On 08/23/2012 04:16 PM, Guido Tack wrote:
> I'm not sure, I just think there could be cases where (especially if
> you use MiniModel) the posting function does some additional reasoning.
>
> Cheers,
> Guido
>
> -- 
> Guido Tack
> http://www.csse.monash.edu/~guidot/
> <http://www.csse.monash.edu/%7Eguidot/>
>
>
>
> On 23/08/2012, at 2:04 PM, Max Ostrowski <ostrowsk at cs.uni-potsdam.de
> <mailto:ostrowsk at cs.uni-potsdam.de>> wrote:
>
>> Great, this really solves the problem.
>> Have not thought of this.
>> Thank you very very much.
>> In my example everything works as expected and the fixpoint is always
>> the same.
>> Are you sure that it can still happen that the fixpoint of the same
>> set of constraints is different,
>> if i use a different order?
>> Then i have to stick to my fallback method.
>>
>>
>> Nevertheless,
>> big thanks for solving my problem. Everything works now and is a
>> hundred times faster :)
>>
>> Best,
>> Max
>>
>> On 08/23/2012 01:44 PM, Guido Tack wrote:
>>> Without looking at the details: Do you check the return value of
>>> IntView::lq?  The view functions are not meant to be used in models.
>>> If lq returns failure, you have to check that yourself, or the space
>>> won't be failed.
>>>
>>> Cheers,
>>> Guido
>>>
>>> -- 
>>> Guido Tack
>>>
>>>
>>> On 23/08/2012, at 13:20, Max Ostrowski <ostrowsk at cs.uni-potsdam.de
>>> <mailto:ostrowsk at cs.uni-potsdam.de>> wrote:
>>>
>>>> Actually its quite complicated.
>>>> I'm currently debugging and have 60 constraints written on paper
>>>> that have this effect.
>>>> Two of them are actually not reified constraints but directly using
>>>> IntView::lq(constant)
>>>>
>>>> I can give you a description where it happens in my system, but it
>>>> will be a mess for you to write simplified code that reproduces this.
>>>>
>>>> Actually given two spaces original1 and original2 that are equal,
>>>> variables are constraint like this:
>>>> posx(6)=[0..185] posx(5)=[0..190] posx(4)=[0..142] posx(3)=[0..158]
>>>> posx(2)=[0..113] posx(1)=[0..157]
>>>>
>>>> all reified constraints are posted with free boolean variables, using
>>>>
>>>>
>>>> linear(*this, intArgs, intVarArgs, r,0,b_[boolvar],ICL_DEF);
>>>>
>>>> Now i set the boolean variables accordingly, always doing
>>>> propagation (calling status()) after each single posting
>>>>
>>>> To original1 false ((-1 $* posx(3))+posx(1))$<=0
>>>> To original1 false ( 10+(-1 $* posx(6))+posx(5))$>0
>>>> To original1 false ( 58+(-1 $* posx(5))+posx(4))$>0
>>>> To original1 true posx(6)<=69                            // this is
>>>> no reified constraint, but just posted IntView(posx(6)).lq(69)
>>>> To original1 false ( 43+(-1 $* posx(6))+posx(1))$>0
>>>> To original1 false ((-1 $* posx(5))+posx(2))$<=0
>>>> To original1 true ((-1 $* posx(1))+posx(3))$<=0
>>>> To original1 true ((-1 $* posx(4))+posx(3))$<=0
>>>> To original1 false ( 42+(-1 $* posx(5))+posx(3))$>0
>>>> To original1 false ( 42+(-1 $* posx(6))+posx(3))$>0
>>>> To original1 true ( -42+(-1 $* posx(3))+posx(1))$<0
>>>> To original1 true ( -15+(-1 $* posx(6))+posx(1))$<0
>>>> To original1 true ( 58+(-1 $* posx(1))+posx(4))$>0
>>>> To original1 true ( 42+(-1 $* posx(1))+posx(3))$>0
>>>> To original1 false ((-1 $* posx(1))+posx(2))$<=0
>>>> To original1 true ((-1 $* posx(6))+posx(1))$<=0
>>>> To original1 true ((-1 $* posx(5))+posx(1))$<=0
>>>> To original1 true ( -10+(-1 $* posx(5))+posx(1))$<0
>>>> To original1 true ((-1 $* posx(2))+posx(1))$<=0
>>>> To original1 false ( 43+(-1 $* posx(2))+posx(1))$>0
>>>> To original1 true ( -28+(-1 $* posx(1))+posx(6))$>0
>>>> To original1 false ( 28+(-1 $* posx(6))+posx(1))$>0
>>>> To original1 false ( -43+(-1 $* posx(1))+posx(2))$<0
>>>> To original1 true ( -58+(-1 $* posx(4))+posx(1))$<0
>>>> To original1 true posx(1)<=29                          // this is
>>>> no reified constraint, but just posted IntView(posx(1)).lq(29)
>>>> To original1 false ((-1 $* posx(1))+posx(4))$<=0       // lets call
>>>> this constraint X
>>>>
>>>> Now this space is failed.
>>>>
>>>> Something similar with the second space, but posting nr. 5 is
>>>> different.
>>>>
>>>> To original2 false ((-1 $* posx(3))+posx(1))$<=0
>>>> To original2 false ( 10+(-1 $* posx(6))+posx(5))$>0
>>>> To original2 false ( 58+(-1 $* posx(5))+posx(4))$>0
>>>> To original2 false ((-1 $* posx(1))+posx(4))$<=0       // this is
>>>> constraint X, it is now posted on this position, no longer as the
>>>> last constraint anymore
>>>> To original2 true posx(6)<=69                          // this is
>>>> no reified constraint, but just posted IntView(posx(6)).lq(69)
>>>> To original2 false ( 43+(-1 $* posx(6))+posx(1))$>0
>>>> To original2 false ((-1 $* posx(5))+posx(2))$<=0
>>>> To original2 true ((-1 $* posx(1))+posx(3))$<=0
>>>> To original2 true ((-1 $* posx(4))+posx(3))$<=0
>>>> To original2 false ( 42+(-1 $* posx(5))+posx(3))$>0
>>>> To original2 false ( 42+(-1 $* posx(6))+posx(3))$>0
>>>> To original2 true ( -42+(-1 $* posx(3))+posx(1))$<0
>>>> To original2 true ( -15+(-1 $* posx(6))+posx(1))$<0
>>>> To original2 true ( 58+(-1 $* posx(1))+posx(4))$>0
>>>> To original2 true ( 42+(-1 $* posx(1))+posx(3))$>0
>>>> To original2 false ((-1 $* posx(1))+posx(2))$<=0
>>>> To original2 true ((-1 $* posx(6))+posx(1))$<=0
>>>> To original2 true ((-1 $* posx(5))+posx(1))$<=0
>>>> To original2 true ( -10+(-1 $* posx(5))+posx(1))$<0
>>>> To original2 true ((-1 $* posx(2))+posx(1))$<=0
>>>> To original2 false ( 43+(-1 $* posx(2))+posx(1))$>0
>>>> To original2 true ( -28+(-1 $* posx(1))+posx(6))$>0
>>>> To original2 false ( 28+(-1 $* posx(6))+posx(1))$>0
>>>> To original2 false ( -43+(-1 $* posx(1))+posx(2))$<0
>>>> To original2 true ( -58+(-1 $* posx(4))+posx(1))$<0
>>>> To original2 true
>>>> posx(1)<=29                                        // this is no
>>>> reified constraint, but just posted IntView(posx(1)).lq(29)
>>>>
>>>> This Space is not failed
>>>>
>>>>
>>>>
>>>>
>>>> I know this is quite a huge blob of data and you probably wont have
>>>> the time to reconstruct it.
>>>> I will just have to adjust my code that this can happen.
>>>> BTW: Can you confirm that this is due to the use of IntView::lq ?
>>>> I never experienced this without them.
>>>>
>>>> Best,
>>>> Max
>>>>
>>>>
>>>>
>>>>
>>>> On 08/23/2012 12:40 PM, Guido Tack wrote:
>>>>> I guess under certain conditions the code that posts the constraints (not the actual propagator) can be stronger than ICL_DEF, in which case this can happen.
>>>>> If it's not too complicated, could you send us a concrete example?
>>>>>
>>>>> Cheers,
>>>>> Guido
>>>>>
>>>>>   
>>>>
>>>> _______________________________________________
>>>> Gecode users mailing list
>>>> users at gecode.org <mailto:users at gecode.org>
>>>> https://www.gecode.org/mailman/listinfo/gecode-users
>>
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org <mailto:users at gecode.org>
>> https://www.gecode.org/mailman/listinfo/gecode-users
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120823/7bc95c3b/attachment.html>

From cschulte at kth.se  Fri Aug 24 09:54:04 2012
From: cschulte at kth.se (Christian Schulte)
Date: Fri, 24 Aug 2012 09:54:04 +0200
Subject: [gecode-users] Propagating to Fixpoint
In-Reply-To: <50361C4E.3030403@cs.uni-potsdam.de>
References: <5036010B.90505@cs.uni-potsdam.de>	<2E93DC33-2B0F-4FA9-A261-2273F3F718C1@gecode.org>	<503611F7.1050905@cs.uni-potsdam.de>	<8AF9CF15-CE97-4F36-A94B-B72FEDCFF10B@gecode.org>
	<50361C4E.3030403@cs.uni-potsdam.de>
Message-ID: <001801cd81cd$a2c4d5e0$e84e81a0$@se>

There are in fact several big fat warnings in MPG saying that views are not for modeling! They are there for a reason!

 

Christian

 

--

Christian Schulte, www.ict.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf Of Max Ostrowski
Sent: Thursday, August 23, 2012 2:05 PM
To: Guido Tack
Cc: users at gecode.org
Subject: Re: [gecode-users] Propagating to Fixpoint

 

Great, this really solves the problem.
Have not thought of this.
Thank you very very much.
In my example everything works as expected and the fixpoint is always the same.
Are you sure that it can still happen that the fixpoint of the same set of constraints is different,
if i use a different order?
Then i have to stick to my fallback method.


Nevertheless,
big thanks for solving my problem. Everything works now and is a hundred times faster :)

Best,
Max

On 08/23/2012 01:44 PM, Guido Tack wrote: 

Without looking at the details: Do you check the return value of IntView::lq?  The view functions are not meant to be used in models. If lq returns failure, you have to check that yourself, or the space won't be failed.

 

Cheers,

Guido


--  

Guido Tack

 


On 23/08/2012, at 13:20, Max Ostrowski <ostrowsk at cs.uni-potsdam.de> wrote:

Actually its quite complicated.
I'm currently debugging and have 60 constraints written on paper that have this effect.
Two of them are actually not reified constraints but directly using IntView::lq(constant)

I can give you a description where it happens in my system, but it will be a mess for you to write simplified code that reproduces this.

Actually given two spaces original1 and original2 that are equal,
variables are constraint like this: 

posx(6)=[0..185] posx(5)=[0..190] posx(4)=[0..142] posx(3)=[0..158] posx(2)=[0..113] posx(1)=[0..157]

 

all reified constraints are posted with free boolean variables, using



linear(*this, intArgs, intVarArgs, r,0,b_[boolvar],ICL_DEF);

Now i set the boolean variables accordingly, always doing propagation (calling status()) after each single posting

To original1 false ((-1 $* posx(3))+posx(1))$<=0

To original1 false ( 10+(-1 $* posx(6))+posx(5))$>0
To original1 false ( 58+(-1 $* posx(5))+posx(4))$>0
To original1 true posx(6)<=69                            // this is no reified constraint, but just posted IntView(posx(6)).lq(69)
To original1 false ( 43+(-1 $* posx(6))+posx(1))$>0
To original1 false ((-1 $* posx(5))+posx(2))$<=0
To original1 true ((-1 $* posx(1))+posx(3))$<=0
To original1 true ((-1 $* posx(4))+posx(3))$<=0
To original1 false ( 42+(-1 $* posx(5))+posx(3))$>0
To original1 false ( 42+(-1 $* posx(6))+posx(3))$>0
To original1 true ( -42+(-1 $* posx(3))+posx(1))$<0
To original1 true ( -15+(-1 $* posx(6))+posx(1))$<0
To original1 true ( 58+(-1 $* posx(1))+posx(4))$>0
To original1 true ( 42+(-1 $* posx(1))+posx(3))$>0
To original1 false ((-1 $* posx(1))+posx(2))$<=0
To original1 true ((-1 $* posx(6))+posx(1))$<=0
To original1 true ((-1 $* posx(5))+posx(1))$<=0
To original1 true ( -10+(-1 $* posx(5))+posx(1))$<0
To original1 true ((-1 $* posx(2))+posx(1))$<=0
To original1 false ( 43+(-1 $* posx(2))+posx(1))$>0
To original1 true ( -28+(-1 $* posx(1))+posx(6))$>0
To original1 false ( 28+(-1 $* posx(6))+posx(1))$>0
To original1 false ( -43+(-1 $* posx(1))+posx(2))$<0
To original1 true ( -58+(-1 $* posx(4))+posx(1))$<0
To original1 true posx(1)<=29                          // this is no reified constraint, but just posted IntView(posx(1)).lq(29)
To original1 false ((-1 $* posx(1))+posx(4))$<=0       // lets call this constraint X

Now this space is failed.

Something similar with the second space, but posting nr. 5 is different.

To original2 false ((-1 $* posx(3))+posx(1))$<=0
To original2 false ( 10+(-1 $* posx(6))+posx(5))$>0
To original2 false ( 58+(-1 $* posx(5))+posx(4))$>0
To original2 false ((-1 $* posx(1))+posx(4))$<=0       // this is constraint X, it is now posted on this position, no longer as the last constraint anymore
To original2 true posx(6)<=69                          // this is no reified constraint, but just posted IntView(posx(6)).lq(69)
To original2 false ( 43+(-1 $* posx(6))+posx(1))$>0
To original2 false ((-1 $* posx(5))+posx(2))$<=0
To original2 true ((-1 $* posx(1))+posx(3))$<=0
To original2 true ((-1 $* posx(4))+posx(3))$<=0
To original2 false ( 42+(-1 $* posx(5))+posx(3))$>0
To original2 false ( 42+(-1 $* posx(6))+posx(3))$>0
To original2 true ( -42+(-1 $* posx(3))+posx(1))$<0
To original2 true ( -15+(-1 $* posx(6))+posx(1))$<0
To original2 true ( 58+(-1 $* posx(1))+posx(4))$>0
To original2 true ( 42+(-1 $* posx(1))+posx(3))$>0
To original2 false ((-1 $* posx(1))+posx(2))$<=0
To original2 true ((-1 $* posx(6))+posx(1))$<=0
To original2 true ((-1 $* posx(5))+posx(1))$<=0
To original2 true ( -10+(-1 $* posx(5))+posx(1))$<0
To original2 true ((-1 $* posx(2))+posx(1))$<=0
To original2 false ( 43+(-1 $* posx(2))+posx(1))$>0
To original2 true ( -28+(-1 $* posx(1))+posx(6))$>0
To original2 false ( 28+(-1 $* posx(6))+posx(1))$>0
To original2 false ( -43+(-1 $* posx(1))+posx(2))$<0
To original2 true ( -58+(-1 $* posx(4))+posx(1))$<0
To original2 true posx(1)<=29                                        // this is no reified constraint, but just posted IntView(posx(1)).lq(29)

This Space is not failed




I know this is quite a huge blob of data and you probably wont have the time to reconstruct it.
I will just have to adjust my code that this can happen.
BTW: Can you confirm that this is due to the use of IntView::lq ?
I never experienced this without them.

Best,
Max




On 08/23/2012 12:40 PM, Guido Tack wrote: 

I guess under certain conditions the code that posts the constraints (not the actual propagator) can be stronger than ICL_DEF, in which case this can happen.
If it's not too complicated, could you send us a concrete example?
 
Cheers,
Guido
 
  

 

_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120824/f0980940/attachment-0001.html>

From ostrowsk at cs.uni-potsdam.de  Fri Aug 24 09:57:02 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Fri, 24 Aug 2012 09:57:02 +0200
Subject: [gecode-users] Propagating to Fixpoint
In-Reply-To: <001801cd81cd$a2c4d5e0$e84e81a0$@se>
References: <5036010B.90505@cs.uni-potsdam.de>	<2E93DC33-2B0F-4FA9-A261-2273F3F718C1@gecode.org>	<503611F7.1050905@cs.uni-potsdam.de>	<8AF9CF15-CE97-4F36-A94B-B72FEDCFF10B@gecode.org>
	<50361C4E.3030403@cs.uni-potsdam.de>
	<001801cd81cd$a2c4d5e0$e84e81a0$@se>
Message-ID: <503733CE.6010104@cs.uni-potsdam.de>

I was not modeling but writing a propagator.

Thanks for solving my problem.
Best,
Max

On 08/24/2012 09:54 AM, Christian Schulte wrote:
>
> There are in fact several big fat warnings in MPG saying that views
> are not for modeling! They are there for a reason!
>
>  
>
> Christian
>
>  
>
> --
>
> Christian Schulte, www.ict.kth.se/~cschulte/
>
>  
>
> *From:* users-bounces at gecode.org [mailto:users-bounces at gecode.org] *On
> Behalf Of *Max Ostrowski
> *Sent:* Thursday, August 23, 2012 2:05 PM
> *To:* Guido Tack
> *Cc:* users at gecode.org
> *Subject:* Re: [gecode-users] Propagating to Fixpoint
>
>  
>
> Great, this really solves the problem.
> Have not thought of this.
> Thank you very very much.
> In my example everything works as expected and the fixpoint is always
> the same.
> Are you sure that it can still happen that the fixpoint of the same
> set of constraints is different,
> if i use a different order?
> Then i have to stick to my fallback method.
>
>
> Nevertheless,
> big thanks for solving my problem. Everything works now and is a
> hundred times faster :)
>
> Best,
> Max
>
> On 08/23/2012 01:44 PM, Guido Tack wrote:
>
> Without looking at the details: Do you check the return value of
> IntView::lq?  The view functions are not meant to be used in models.
> If lq returns failure, you have to check that yourself, or the space
> won't be failed.
>
>  
>
> Cheers,
>
> Guido
>
>
> -- 
>
> Guido Tack
>
>  
>
>
> On 23/08/2012, at 13:20, Max Ostrowski <ostrowsk at cs.uni-potsdam.de
> <mailto:ostrowsk at cs.uni-potsdam.de>> wrote:
>
>     Actually its quite complicated.
>     I'm currently debugging and have 60 constraints written on paper
>     that have this effect.
>     Two of them are actually not reified constraints but directly
>     using IntView::lq(constant)
>
>     I can give you a description where it happens in my system, but it
>     will be a mess for you to write simplified code that reproduces this.
>
>     Actually given two spaces original1 and original2 that are equal,
>     variables are constraint like this:
>
>     posx(6)=[0..185] posx(5)=[0..190] posx(4)=[0..142]
>     posx(3)=[0..158] posx(2)=[0..113] posx(1)=[0..157]
>
>      
>
>     all reified constraints are posted with free boolean variables, using
>
>
>
>     linear(*this, intArgs, intVarArgs, r,0,b_[boolvar],ICL_DEF);
>
>     Now i set the boolean variables accordingly, always doing
>     propagation (calling status()) after each single posting
>
>     To original1 false ((-1 $* posx(3))+posx(1))$<=0
>
>     To original1 false ( 10+(-1 $* posx(6))+posx(5))$>0
>     To original1 false ( 58+(-1 $* posx(5))+posx(4))$>0
>     To original1 true posx(6)<=69                            // this
>     is no reified constraint, but just posted IntView(posx(6)).lq(69)
>     To original1 false ( 43+(-1 $* posx(6))+posx(1))$>0
>     To original1 false ((-1 $* posx(5))+posx(2))$<=0
>     To original1 true ((-1 $* posx(1))+posx(3))$<=0
>     To original1 true ((-1 $* posx(4))+posx(3))$<=0
>     To original1 false ( 42+(-1 $* posx(5))+posx(3))$>0
>     To original1 false ( 42+(-1 $* posx(6))+posx(3))$>0
>     To original1 true ( -42+(-1 $* posx(3))+posx(1))$<0
>     To original1 true ( -15+(-1 $* posx(6))+posx(1))$<0
>     To original1 true ( 58+(-1 $* posx(1))+posx(4))$>0
>     To original1 true ( 42+(-1 $* posx(1))+posx(3))$>0
>     To original1 false ((-1 $* posx(1))+posx(2))$<=0
>     To original1 true ((-1 $* posx(6))+posx(1))$<=0
>     To original1 true ((-1 $* posx(5))+posx(1))$<=0
>     To original1 true ( -10+(-1 $* posx(5))+posx(1))$<0
>     To original1 true ((-1 $* posx(2))+posx(1))$<=0
>     To original1 false ( 43+(-1 $* posx(2))+posx(1))$>0
>     To original1 true ( -28+(-1 $* posx(1))+posx(6))$>0
>     To original1 false ( 28+(-1 $* posx(6))+posx(1))$>0
>     To original1 false ( -43+(-1 $* posx(1))+posx(2))$<0
>     To original1 true ( -58+(-1 $* posx(4))+posx(1))$<0
>     To original1 true posx(1)<=29                          // this is
>     no reified constraint, but just posted IntView(posx(1)).lq(29)
>     To original1 false ((-1 $* posx(1))+posx(4))$<=0       // lets
>     call this constraint X
>
>     Now this space is failed.
>
>     Something similar with the second space, but posting nr. 5 is
>     different.
>
>     To original2 false ((-1 $* posx(3))+posx(1))$<=0
>     To original2 false ( 10+(-1 $* posx(6))+posx(5))$>0
>     To original2 false ( 58+(-1 $* posx(5))+posx(4))$>0
>     To original2 false ((-1 $* posx(1))+posx(4))$<=0       // this is
>     constraint X, it is now posted on this position, no longer as the
>     last constraint anymore
>     To original2 true posx(6)<=69                          // this is
>     no reified constraint, but just posted IntView(posx(6)).lq(69)
>     To original2 false ( 43+(-1 $* posx(6))+posx(1))$>0
>     To original2 false ((-1 $* posx(5))+posx(2))$<=0
>     To original2 true ((-1 $* posx(1))+posx(3))$<=0
>     To original2 true ((-1 $* posx(4))+posx(3))$<=0
>     To original2 false ( 42+(-1 $* posx(5))+posx(3))$>0
>     To original2 false ( 42+(-1 $* posx(6))+posx(3))$>0
>     To original2 true ( -42+(-1 $* posx(3))+posx(1))$<0
>     To original2 true ( -15+(-1 $* posx(6))+posx(1))$<0
>     To original2 true ( 58+(-1 $* posx(1))+posx(4))$>0
>     To original2 true ( 42+(-1 $* posx(1))+posx(3))$>0
>     To original2 false ((-1 $* posx(1))+posx(2))$<=0
>     To original2 true ((-1 $* posx(6))+posx(1))$<=0
>     To original2 true ((-1 $* posx(5))+posx(1))$<=0
>     To original2 true ( -10+(-1 $* posx(5))+posx(1))$<0
>     To original2 true ((-1 $* posx(2))+posx(1))$<=0
>     To original2 false ( 43+(-1 $* posx(2))+posx(1))$>0
>     To original2 true ( -28+(-1 $* posx(1))+posx(6))$>0
>     To original2 false ( 28+(-1 $* posx(6))+posx(1))$>0
>     To original2 false ( -43+(-1 $* posx(1))+posx(2))$<0
>     To original2 true ( -58+(-1 $* posx(4))+posx(1))$<0
>     To original2 true
>     posx(1)<=29                                        // this is no
>     reified constraint, but just posted IntView(posx(1)).lq(29)
>
>     This Space is not failed
>
>
>
>
>     I know this is quite a huge blob of data and you probably wont
>     have the time to reconstruct it.
>     I will just have to adjust my code that this can happen.
>     BTW: Can you confirm that this is due to the use of IntView::lq ?
>     I never experienced this without them.
>
>     Best,
>     Max
>
>
>
>
>     On 08/23/2012 12:40 PM, Guido Tack wrote:
>
>     I guess under certain conditions the code that posts the constraints (not the actual propagator) can be stronger than ICL_DEF, in which case this can happen.
>
>     If it's not too complicated, could you send us a concrete example?
>
>      
>
>     Cheers,
>
>     Guido
>
>      
>
>       
>
>      
>
>     _______________________________________________
>     Gecode users mailing list
>     users at gecode.org <mailto:users at gecode.org>
>     https://www.gecode.org/mailman/listinfo/gecode-users
>
>  
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20120824/1c7c3cf3/attachment.html>

From maik.riechert at arcor.de  Mon Aug 27 22:05:56 2012
From: maik.riechert at arcor.de (Maik Riechert)
Date: Mon, 27 Aug 2012 22:05:56 +0200
Subject: [gecode-users] Does Gecode compile to constraint-free code?
Message-ID: <503BD324.8000608@arcor.de>

Hi all,

I'm quite new to the whole space of constraint programming and have 
recently made use of a finite domain constraint solving framework called 
monadiccp [1] for one of my current projects [2]. I measured the 
performance and saw that it was ~800x slower than my direct 
constraint-free implementation.

The framework also supports Gecode (apart from a pure Haskell 
implementation) but after seeing this slowdown I haven't tested it yet 
as the C-to-Haskell interfacing probabably also produces some overhead 
and I doubt it can get really fast.

I came across the paper "Compiling Constraint Solving using Projection" 
from Harvey et al [3] which I find quite promising. In my particular 
case I have very few (at the moment two) constraint systems which need 
to be solved thousands of times. They have 10-20 constraints and vary 
only in their input arguments, i.e. the constraints itself stay the same.

As the solver I use is a runtime solver which reads/simplifies/solves 
the whole system over and over, it is slow. The question is: Could the 
approach of the paper be used to derive constraint-free equations *once* 
and then use those in the actual algorithm? And does Gecode maybe 
support that already?

Cheers
Maik

[1] http://hackage.haskell.org/package/monadiccp/
[2] 
https://github.com/neothemachine/adp-multi/blob/master/src/ADP/Multi/Rewriting/ConstraintSolver.hs#L213
[3] 
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.17.3194&rep=rep1&type=pdf


From cschulte at kth.se  Tue Aug 28 09:33:17 2012
From: cschulte at kth.se (Christian Schulte)
Date: Tue, 28 Aug 2012 09:33:17 +0200
Subject: [gecode-users] Does Gecode compile to constraint-free code?
In-Reply-To: <503BD324.8000608@arcor.de>
References: <503BD324.8000608@arcor.de>
Message-ID: <00cb01cd84ef$6428d460$2c7a7d20$@kth.se>

Hi,

I am not sure that I get your question. For realistic constraints such as
those available in Gecode this is not really possible. Warwick's paper talks
about a slightly different setup (solving very simple [linear] constraints
repeatedly).

Why not just try to resolve using Gecode?

Christian

--
Christian Schulte, www.ict.kth.se/~cschulte/



-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Maik Riechert
Sent: Monday, August 27, 2012 10:06 PM
To: users at gecode.org
Subject: [gecode-users] Does Gecode compile to constraint-free code?

Hi all,

I'm quite new to the whole space of constraint programming and have recently
made use of a finite domain constraint solving framework called monadiccp
[1] for one of my current projects [2]. I measured the performance and saw
that it was ~800x slower than my direct constraint-free implementation.

The framework also supports Gecode (apart from a pure Haskell
implementation) but after seeing this slowdown I haven't tested it yet as
the C-to-Haskell interfacing probabably also produces some overhead and I
doubt it can get really fast.

I came across the paper "Compiling Constraint Solving using Projection" 
from Harvey et al [3] which I find quite promising. In my particular case I
have very few (at the moment two) constraint systems which need to be solved
thousands of times. They have 10-20 constraints and vary only in their input
arguments, i.e. the constraints itself stay the same.

As the solver I use is a runtime solver which reads/simplifies/solves the
whole system over and over, it is slow. The question is: Could the approach
of the paper be used to derive constraint-free equations *once* and then use
those in the actual algorithm? And does Gecode maybe support that already?

Cheers
Maik

[1] http://hackage.haskell.org/package/monadiccp/
[2]
https://github.com/neothemachine/adp-multi/blob/master/src/ADP/Multi/Rewriti
ng/ConstraintSolver.hs#L213
[3]
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.17.3194&rep=rep1&ty
pe=pdf

_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users



From maik.riechert at arcor.de  Tue Aug 28 10:31:35 2012
From: maik.riechert at arcor.de (Maik Riechert)
Date: Tue, 28 Aug 2012 10:31:35 +0200
Subject: [gecode-users] Does Gecode compile to constraint-free code?
In-Reply-To: <00cb01cd84ef$6428d460$2c7a7d20$@kth.se>
References: <503BD324.8000608@arcor.de>
	<00cb01cd84ef$6428d460$2c7a7d20$@kth.se>
Message-ID: <503C81E7.7030202@arcor.de>

> I am not sure that I get your question.

I also just asked it on StackOverflow, maybe it makes it more clear:

http://stackoverflow.com/questions/12155312/deriving-equations-for-finite-domain-constraint-system

> For realistic constraints such as
> those available in Gecode this is not really possible. Warwick's paper talks
> about a slightly different setup (solving very simple [linear] constraints
> repeatedly).

I think this is exactly what I'm doing, solving very simple linear 
finite domain constraints repeatedly. So, you say that Gecode's main use 
case is solving very big constraint systems few times / once, right?

Regards
Maik


From cschulte at kth.se  Tue Aug 28 11:20:10 2012
From: cschulte at kth.se (Christian Schulte)
Date: Tue, 28 Aug 2012 11:20:10 +0200
Subject: [gecode-users] Does Gecode compile to constraint-free code?
In-Reply-To: <503C81E7.7030202@arcor.de>
References: <503BD324.8000608@arcor.de>	<00cb01cd84ef$6428d460$2c7a7d20$@kth.se>
	<503C81E7.7030202@arcor.de>
Message-ID: <00d901cd84fe$52b118f0$f8134ad0$@kth.se>

Why think about premature optimization? Gecode is pretty efficient and your
problems are trivial. So I first would try it without further thinking about
optimization.

Best
Christian

--
Christian Schulte, www.ict.kth.se/~cschulte/



-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Maik Riechert
Sent: Tuesday, August 28, 2012 10:32 AM
To: cschulte at kth.se
Cc: users at gecode.org
Subject: Re: [gecode-users] Does Gecode compile to constraint-free code?

> I am not sure that I get your question.

I also just asked it on StackOverflow, maybe it makes it more clear:

http://stackoverflow.com/questions/12155312/deriving-equations-for-finite-do
main-constraint-system

> For realistic constraints such as
> those available in Gecode this is not really possible. Warwick's paper 
> talks about a slightly different setup (solving very simple [linear] 
> constraints repeatedly).

I think this is exactly what I'm doing, solving very simple linear finite
domain constraints repeatedly. So, you say that Gecode's main use case is
solving very big constraint systems few times / once, right?

Regards
Maik

_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users



From maik.riechert at arcor.de  Fri Aug 31 11:04:40 2012
From: maik.riechert at arcor.de (Maik Riechert)
Date: Fri, 31 Aug 2012 11:04:40 +0200
Subject: [gecode-users] Compiling Gecode under MinGW
Message-ID: <50407E28.1080600@arcor.de>

Hi,

As I want to use Gecode in Windows with Haskell and cabal-install uses 
GCC, I need to rebuild it from source in MinGW/MSYS.

I did a ./configure --with-host-os=linux which went through and then 
"make" which had these errors:

g++ -I. -mthreads -ffast-math -fno-strict-aliasing -O3 
-fvisibility=hidden -ggdb -pipe -Wall -Wextra -pthread -DNDEBUG   \
         -c -o gecode/support/exception.o  gecode/support/exception.cpp
In file included from ./gecode/support/thread.hpp:264:0,
                  from ./gecode/support.hh:130,
                  from gecode/support/exception.cpp:38:
./gecode/support/thread/pthreads.hpp: In static member function 'static 
void Gecode::Support::Thread::sleep(unsigned int)':
./gecode/support/thread/pthreads.hpp:125:7: error: '::sleep' has not 
been declared
./gecode/support/thread/pthreads.hpp: In static member function 'static 
unsigned int Gecode::Support::Thread::npu()':
./gecode/support/thread/pthreads.hpp:133:36: error: 
'_SC_NPROCESSORS_ONLN' was not declared in this scope
./gecode/support/thread/pthreads.hpp:133:56: error: 'sysconf' was not 
declared in this scope
gecode/support/exception.cpp: At global scope:
gecode/support/exception.cpp:46:3: warning: 
'Gecode::Exception::Exception(const char*, const char*)' redeclared 
without dllimport attribute after being referenced with dll linkage 
[enabled by default]
gecode/support/exception.cpp:59:3: warning: 'virtual const char* 
Gecode::Exception::what() const' redeclared without dllimport attribute: 
previous dllimport ignored [-Wattributes]
make[1]: *** [gecode/support/exception.o] Error 1


Is it possible to make this compatible? Why is it failing at all?

Cheers
Maik


From cschulte at kth.se  Fri Aug 31 12:17:26 2012
From: cschulte at kth.se (Christian Schulte)
Date: Fri, 31 Aug 2012 12:17:26 +0200
Subject: [gecode-users] Compiling Gecode under MinGW
In-Reply-To: <50407E28.1080600@arcor.de>
References: <50407E28.1080600@arcor.de>
Message-ID: <009601cd8761$d2898de0$779ca9a0$@kth.se>

The reason is simple: we do not support MinGW as a platform. It is possible
to make it compatible and it shouldn't be that hard: one would just have to
find out that it is MinGW and use the pthreads package instead on the
Windows thread package.

However we are not willing to do that ourselves. If somebody sends a patch
(hint! Hint!) we will surely incorporate it.

Christian

--
Christian Schulte, www.ict.kth.se/~cschulte/



-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Maik Riechert
Sent: Friday, August 31, 2012 11:05 AM
To: users at gecode.org
Subject: [gecode-users] Compiling Gecode under MinGW

Hi,

As I want to use Gecode in Windows with Haskell and cabal-install uses GCC,
I need to rebuild it from source in MinGW/MSYS.

I did a ./configure --with-host-os=linux which went through and then "make"
which had these errors:

g++ -I. -mthreads -ffast-math -fno-strict-aliasing -O3
-fvisibility=hidden -ggdb -pipe -Wall -Wextra -pthread -DNDEBUG   \
         -c -o gecode/support/exception.o  gecode/support/exception.cpp In
file included from ./gecode/support/thread.hpp:264:0,
                  from ./gecode/support.hh:130,
                  from gecode/support/exception.cpp:38:
./gecode/support/thread/pthreads.hpp: In static member function 'static void
Gecode::Support::Thread::sleep(unsigned int)':
./gecode/support/thread/pthreads.hpp:125:7: error: '::sleep' has not been
declared
./gecode/support/thread/pthreads.hpp: In static member function 'static
unsigned int Gecode::Support::Thread::npu()':
./gecode/support/thread/pthreads.hpp:133:36: error: 
'_SC_NPROCESSORS_ONLN' was not declared in this scope
./gecode/support/thread/pthreads.hpp:133:56: error: 'sysconf' was not
declared in this scope
gecode/support/exception.cpp: At global scope:
gecode/support/exception.cpp:46:3: warning: 
'Gecode::Exception::Exception(const char*, const char*)' redeclared without
dllimport attribute after being referenced with dll linkage [enabled by
default]
gecode/support/exception.cpp:59:3: warning: 'virtual const char*
Gecode::Exception::what() const' redeclared without dllimport attribute: 
previous dllimport ignored [-Wattributes]
make[1]: *** [gecode/support/exception.o] Error 1


Is it possible to make this compatible? Why is it failing at all?

Cheers
Maik

_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users



From ostrowsk at cs.uni-potsdam.de  Fri Aug 31 13:27:05 2012
From: ostrowsk at cs.uni-potsdam.de (Max Ostrowski)
Date: Fri, 31 Aug 2012 13:27:05 +0200
Subject: [gecode-users] Advisor: Delta Modification
In-Reply-To: <009601cd8761$d2898de0$779ca9a0$@kth.se>
References: <50407E28.1080600@arcor.de>
	<009601cd8761$d2898de0$779ca9a0$@kth.se>
Message-ID: <50409F89.8080003@cs.uni-potsdam.de>

Hi everybody,

in case of the modification event Gecode::Int::ME_INT_VAL
i want to know what is the meaning of the IntView::min(d) and max(d)
methods (d==delta)

In the case of ME_INT_BND,
min(d)..max(d) is the range that was removed from the domain.

In the case of ME_INT_VAL
i sometimes have it being a removed range,
but sometimes it is min(d)=1 and max(d)=0.
I thought that this means that the domain was restricted on both sides
of the variable,
eg. x==6 while it was x = [1..10] before.
But this does not seem to be true in all cases.
So what is the meaning of these values.

Best,
Max



From cschulte at kth.se  Fri Aug 31 13:34:28 2012
From: cschulte at kth.se (Christian Schulte)
Date: Fri, 31 Aug 2012 13:34:28 +0200
Subject: [gecode-users] Advisor: Delta Modification
In-Reply-To: <50409F89.8080003@cs.uni-potsdam.de>
References: <50407E28.1080600@arcor.de>	<009601cd8761$d2898de0$779ca9a0$@kth.se>
	<50409F89.8080003@cs.uni-potsdam.de>
Message-ID: <009d01cd876c$94d5f500$be81df00$@kth.se>

You first have to check with any()! Only if that is false, min and max make
sense!

Christian

--
Christian Schulte, www.ict.kth.se/~cschulte/



-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Max Ostrowski
Sent: Friday, August 31, 2012 1:27 PM
To: users at gecode.org
Subject: [gecode-users] Advisor: Delta Modification

Hi everybody,

in case of the modification event Gecode::Int::ME_INT_VAL i want to know
what is the meaning of the IntView::min(d) and max(d) methods (d==delta)

In the case of ME_INT_BND,
min(d)..max(d) is the range that was removed from the domain.

In the case of ME_INT_VAL
i sometimes have it being a removed range, but sometimes it is min(d)=1 and
max(d)=0.
I thought that this means that the domain was restricted on both sides of
the variable, eg. x==6 while it was x = [1..10] before.
But this does not seem to be true in all cases.
So what is the meaning of these values.

Best,
Max


_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users



