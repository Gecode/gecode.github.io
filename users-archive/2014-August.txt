From kisshen at cisco.com  Fri Aug  1 22:44:37 2014
From: kisshen at cisco.com (Kish Shen)
Date: Fri, 01 Aug 2014 21:44:37 +0100
Subject: [gecode-users] Memory usage of Space
Message-ID: <53DBFC35.7050308@cisco.com>

Hi,

One of our ECLiPSe user is trying out his program with our Gecode 
interface (his original is written for ECLiPSe's native ic solver), and 
one of the problem he has run into is that the execution seems to 
consume a lot of memory (> 1.5G), and reducing the cloning apparently 
does not help much.

However, he can only measure the memory consumption indirectly, by 
looking at the memory usage of the process, and so it is difficult to be 
precise.

Is there any existing way of measuring, or at least estimating, the 
amount of memory used by Gecode? In this case, the search is done in 
ECLiPSe, rather than using Gecode's search engines, so the creation of 
clones of the Space are all done from ECLiPSe, so I assume Gecode have 
not got a "global" way of tracking all the cloned Spaces. However, I 
should be able to do this from ECLiPSe, but I need to be able to get the 
memory usage (or estimate) of each Space -- is there any available 
procedure to get this?

Thanks in advance for any information/help!

Kish


From gustavo.ggutierrez at gmail.com  Sat Aug  2 18:41:48 2014
From: gustavo.ggutierrez at gmail.com (Gustavo Gutierrez)
Date: Sat, 2 Aug 2014 11:41:48 -0500
Subject: [gecode-users] Constant view disposer
Message-ID: <CAFcfiNXTGWkg4jXnT-k=s+rKQ-m2aizcTUQhbPERHGZXHrh88g@mail.gmail.com>

Dear all,

I am well aware of the disposal mechanism implemented in geocode for the
variable implementations that require to be explicitly disposed. Actually I
am using it for a variable implementation that uses some reference counting
mechanism. I was wondering if there is some kind of disposal support for
constant views.

To be more precise, a constant view in my case has an attribute which is
reference counted. I need its counter to be decremented when the view gets
destroyed (or disposed). I was looking in the documentation for a dispose
method. Something similar to what exists in RelVarImpBase. It is quite
probable that I am missing something and hence I would like any help on
this.

Kind regards,
-- 
Gustavo Gutierrez
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140802/bb35a9ab/attachment.html>

From cschulte at kth.se  Mon Aug  4 10:38:11 2014
From: cschulte at kth.se (Christian Schulte)
Date: Mon, 4 Aug 2014 10:38:11 +0200
Subject: [gecode-users] Memory usage of Space
In-Reply-To: <53DBFC35.7050308@cisco.com>
References: <53DBFC35.7050308@cisco.com>
Message-ID: <00e301cfafbf$6d58bc60$480a3520$@kth.se>

Hi Kish,

Sorry there is not really anything that allows you to do so. You can build
Gecode with heap tracking (see configure --help) but I do not really know
whether this would help.

Cheers
Christian

--
Christian Schulte, KTH, web.it.kth.se/~cschulte/

-----Original Message-----
From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf
Of Kish Shen
Sent: Friday, August 1, 2014 10:45 PM
To: users at gecode.org
Subject: [gecode-users] Memory usage of Space

Hi,

One of our ECLiPSe user is trying out his program with our Gecode interface
(his original is written for ECLiPSe's native ic solver), and one of the
problem he has run into is that the execution seems to consume a lot of
memory (> 1.5G), and reducing the cloning apparently does not help much.

However, he can only measure the memory consumption indirectly, by looking
at the memory usage of the process, and so it is difficult to be precise.

Is there any existing way of measuring, or at least estimating, the amount
of memory used by Gecode? In this case, the search is done in ECLiPSe,
rather than using Gecode's search engines, so the creation of clones of the
Space are all done from ECLiPSe, so I assume Gecode have not got a "global"
way of tracking all the cloned Spaces. However, I should be able to do this
from ECLiPSe, but I need to be able to get the memory usage (or estimate) of
each Space -- is there any available procedure to get this?

Thanks in advance for any information/help!

Kish

_______________________________________________
Gecode users mailing list
users at gecode.org
https://www.gecode.org/mailman/listinfo/gecode-users



From cschulte at kth.se  Mon Aug  4 10:52:02 2014
From: cschulte at kth.se (Christian Schulte)
Date: Mon, 4 Aug 2014 10:52:02 +0200
Subject: [gecode-users] Constant view disposer
In-Reply-To: <CAFcfiNXTGWkg4jXnT-k=s+rKQ-m2aizcTUQhbPERHGZXHrh88g@mail.gmail.com>
References: <CAFcfiNXTGWkg4jXnT-k=s+rKQ-m2aizcTUQhbPERHGZXHrh88g@mail.gmail.com>
Message-ID: <00e501cfafc1$5c77fcb0$1567f610$@kth.se>

Hi Gustavo,

 

Unfortunately, there is currently no way to have dispose called on a constant view, it is only available for variable implementations.

 

There are two ways you could deal with this: (a) do not use constant views but just variable views (b) extend Gecode such that also constant views can register for disposal. (b) might actually not be that difficult, it could re-use the infra structure that is already there for disposal of variable implementations. If you come up with a patch for (b) we could see whether we add it to Gecode provided it only costs when the feature is being used.

 

Cheers

Christian

 

--

Christian Schulte, KTH, web.it.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf Of Gustavo Gutierrez
Sent: Saturday, August 2, 2014 06:42 PM
To: gecode list
Subject: [gecode-users] Constant view disposer

 

Dear all,

 

I am well aware of the disposal mechanism implemented in geocode for the variable implementations that require to be explicitly disposed. Actually I am using it for a variable implementation that uses some reference counting mechanism. I was wondering if there is some kind of disposal support for constant views.

 

To be more precise, a constant view in my case has an attribute which is reference counted. I need its counter to be decremented when the view gets destroyed (or disposed). I was looking in the documentation for a dispose method. Something similar to what exists in RelVarImpBase. It is quite probable that I am missing something and hence I would like any help on this.

 

Kind regards,

-- 
Gustavo Gutierrez 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140804/1184cff4/attachment.html>

From richard.portell at gmail.com  Wed Aug 13 17:35:18 2014
From: richard.portell at gmail.com (Chd Orti)
Date: Wed, 13 Aug 2014 17:35:18 +0200
Subject: [gecode-users] unknown system size
Message-ID: <CAPigQkcCTPt457oWpdsoA-Qke+qHjK6YpHMTRxRYfg8tNdNMbg@mail.gmail.com>

Hello,
I have an array of integers with unknown size,  with an easy constraint for
example :
Sum of array integers = 10;
It could be 1,9, or 3,3,4, or 1,1,1,7, etc ...
Is there a way gecode can handle that ?
Cheers,
Richard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140813/75b0092f/attachment.html>

From tack at gecode.org  Thu Aug 14 02:30:00 2014
From: tack at gecode.org (Guido Tack)
Date: Thu, 14 Aug 2014 10:30:00 +1000
Subject: [gecode-users] unknown system size
In-Reply-To: <CAPigQkcCTPt457oWpdsoA-Qke+qHjK6YpHMTRxRYfg8tNdNMbg@mail.gmail.com>
References: <CAPigQkcCTPt457oWpdsoA-Qke+qHjK6YpHMTRxRYfg8tNdNMbg@mail.gmail.com>
Message-ID: <41941034-DB1A-4883-96DF-9F043F448170@gecode.org>

Arrays need to have a fixed size.  What you can do is to say that the sum of the array is 10, but that only the first n entries are different from 0 (you will need to express this using constraints).  This is not really a Gecode question though, it's a general problem when modelling for most constraint solvers.

Cheers,
Guido

On 14 Aug 2014, at 1:35 am, Chd Orti <richard.portell at gmail.com> wrote:

> Hello,
> I have an array of integers with unknown size,  with an easy constraint for example :
> Sum of array integers = 10; 
> It could be 1,9, or 3,3,4, or 1,1,1,7, etc ...
> Is there a way gecode can handle that ?
> Cheers,
> Richard
> 
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users



From gustavo.ggutierrez at gmail.com  Tue Aug 19 16:33:21 2014
From: gustavo.ggutierrez at gmail.com (Gustavo Gutierrez)
Date: Tue, 19 Aug 2014 09:33:21 -0500
Subject: [gecode-users] Set propagators and modification event delta
Message-ID: <CAFcfiNUHi3u_abrCjkWWfpfWseW60Wgojcn_K6kb5jB8bETOmA@mail.gmail.com>

Dear all,

I am trying to write a propagator and I really would like to take advantage
of the modification event information offered by the geocode kernel in the
respective argument to the propagate method. To that end, I am looking at
set propagators as an example. In concrete I am looking at the code of the
intersection propagator in inter.hpp.

That implementation calls testSetEventLB defined in common.hpp. My question
is concrete: does this function returns true when the modification event
passed as parameter signals a modification of the lower bound?. My
intuition from its definition and the internal functions it uses tell me so
but I would like to corroborate it with you.

There are other testSetEvent* that take a different number of arguments
(all of them being modification events). For example, testSetEventLB with
two arguments. Does this one returns true if any of the two events imply
modification to the lower bounds?

Best regards,
-- 
Gustavo Gutierrez
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140819/713a3a99/attachment.html>

From cschulte at kth.se  Wed Aug 20 09:58:51 2014
From: cschulte at kth.se (Christian Schulte)
Date: Wed, 20 Aug 2014 09:58:51 +0200
Subject: [gecode-users] Set propagators and modification event delta
In-Reply-To: <CAFcfiNUHi3u_abrCjkWWfpfWseW60Wgojcn_K6kb5jB8bETOmA@mail.gmail.com>
References: <CAFcfiNUHi3u_abrCjkWWfpfWseW60Wgojcn_K6kb5jB8bETOmA@mail.gmail.com>
Message-ID: <000c01cfbc4c$94dab010$be901030$@se>

Hi, I will have to leave this to Guido... Cheers Christian

 

--

Christian Schulte, Professor of Computer Science, KTH, www.gecode.org/~schulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf Of Gustavo Gutierrez
Sent: Tuesday, August 19, 2014 4:33 PM
To: gecode list
Subject: [gecode-users] Set propagators and modification event delta

 

Dear all,

 

I am trying to write a propagator and I really would like to take advantage of the modification event information offered by the geocode kernel in the respective argument to the propagate method. To that end, I am looking at set propagators as an example. In concrete I am looking at the code of the intersection propagator in inter.hpp.

 

That implementation calls testSetEventLB defined in common.hpp. My question is concrete: does this function returns true when the modification event passed as parameter signals a modification of the lower bound?. My intuition from its definition and the internal functions it uses tell me so but I would like to corroborate it with you.

 

There are other testSetEvent* that take a different number of arguments (all of them being modification events). For example, testSetEventLB with two arguments. Does this one returns true if any of the two events imply modification to the lower bounds?

 

Best regards, 

-- 

Gustavo Gutierrez 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140820/be1109fc/attachment.html>

From tack at gecode.org  Wed Aug 20 10:27:04 2014
From: tack at gecode.org (Guido Tack)
Date: Wed, 20 Aug 2014 18:27:04 +1000
Subject: [gecode-users] Set propagators and modification event delta
In-Reply-To: <CAFcfiNUHi3u_abrCjkWWfpfWseW60Wgojcn_K6kb5jB8bETOmA@mail.gmail.com>
References: <CAFcfiNUHi3u_abrCjkWWfpfWseW60Wgojcn_K6kb5jB8bETOmA@mail.gmail.com>
Message-ID: <99D545EE-276E-443B-BA3B-20C95DC4A048@gecode.org>

Hi Gustavo,

modification events are really sets of modifications, e.g. if you have only a lower bound modification the event is ME_SET_GLB, for only upper bound it's ME_SET_LUB, but if both have been modified you get ME_SET_BB.  

You guessed correctly: The testSetEventLB function returns true if the argument event contains a lower bound modification (so it could be ME_SET_GLB, ME_SET_BB, ME_SET_CGLB or ME_SET_CBB).  The versions with multiple arguments test whether any of them contains a lower bound modification (the implementation computes the union of the events and then does the check).

Cheers,
Guido

On 20 Aug 2014, at 12:33 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com> wrote:

> Dear all,
> 
> I am trying to write a propagator and I really would like to take advantage of the modification event information offered by the geocode kernel in the respective argument to the propagate method. To that end, I am looking at set propagators as an example. In concrete I am looking at the code of the intersection propagator in inter.hpp.
> 
> That implementation calls testSetEventLB defined in common.hpp. My question is concrete: does this function returns true when the modification event passed as parameter signals a modification of the lower bound?. My intuition from its definition and the internal functions it uses tell me so but I would like to corroborate it with you.
> 
> There are other testSetEvent* that take a different number of arguments (all of them being modification events). For example, testSetEventLB with two arguments. Does this one returns true if any of the two events imply modification to the lower bounds?
> 
> Best regards, 
> -- 
> Gustavo Gutierrez
> _______________________________________________
> Gecode users mailing list
> users at gecode.org
> https://www.gecode.org/mailman/listinfo/gecode-users



From gustavo.ggutierrez at gmail.com  Wed Aug 20 19:26:16 2014
From: gustavo.ggutierrez at gmail.com (Gustavo Gutierrez)
Date: Wed, 20 Aug 2014 10:26:16 -0700 (PDT)
Subject: [gecode-users] Set propagators and modification event delta
In-Reply-To: <99D545EE-276E-443B-BA3B-20C95DC4A048@gecode.org>
References: <99D545EE-276E-443B-BA3B-20C95DC4A048@gecode.org>
Message-ID: <1408555575624.b75f6557@Nodemailer>

Hi Guido,


Thanks for the answer. Did you measured the impact of using modification events in the propagate method versus normal implementations of the propagators? ?




What I mean by normal implementations is suppose you implement the pruning rules without taking into account what have changed since the last time. That will of course maintain the correctness but you will end up applying unnecessary operations. Are the two variants significantly different in the case of set variables?




I'm asking this because using modifications events lead to more involved code and is very easy to get it wrong. But on the other hand, is something I will keep doing for performance reasons.?




Regards,

Gustavo
?
Gustavo

On Wed, Aug 20, 2014 at 3:27 AM, Guido Tack <tack at gecode.org> wrote:

> Hi Gustavo,
> modification events are really sets of modifications, e.g. if you have only a lower bound modification the event is ME_SET_GLB, for only upper bound it's ME_SET_LUB, but if both have been modified you get ME_SET_BB.  
> You guessed correctly: The testSetEventLB function returns true if the argument event contains a lower bound modification (so it could be ME_SET_GLB, ME_SET_BB, ME_SET_CGLB or ME_SET_CBB).  The versions with multiple arguments test whether any of them contains a lower bound modification (the implementation computes the union of the events and then does the check).
> Cheers,
> Guido
> On 20 Aug 2014, at 12:33 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com> wrote:
>> Dear all,
>> 
>> I am trying to write a propagator and I really would like to take advantage of the modification event information offered by the geocode kernel in the respective argument to the propagate method. To that end, I am looking at set propagators as an example. In concrete I am looking at the code of the intersection propagator in inter.hpp.
>> 
>> That implementation calls testSetEventLB defined in common.hpp. My question is concrete: does this function returns true when the modification event passed as parameter signals a modification of the lower bound?. My intuition from its definition and the internal functions it uses tell me so but I would like to corroborate it with you.
>> 
>> There are other testSetEvent* that take a different number of arguments (all of them being modification events). For example, testSetEventLB with two arguments. Does this one returns true if any of the two events imply modification to the lower bounds?
>> 
>> Best regards, 
>> -- 
>> Gustavo Gutierrez
>> _______________________________________________
>> Gecode users mailing list
>> users at gecode.org
>> https://www.gecode.org/mailman/listinfo/gecode-users
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140820/e1020426/attachment.html>

From cschulte at kth.se  Wed Aug 20 20:13:10 2014
From: cschulte at kth.se (Christian Schulte)
Date: Wed, 20 Aug 2014 20:13:10 +0200
Subject: [gecode-users] Set propagators and modification event delta
In-Reply-To: <1408555575624.b75f6557@Nodemailer>
References: <99D545EE-276E-443B-BA3B-20C95DC4A048@gecode.org>
	<1408555575624.b75f6557@Nodemailer>
Message-ID: <004301cfbca2$67371260$35a53720$@kth.se>

We have measured the impact for integer variables even with different modification events. You can check it here:

              <http://www.gecode.org/~schulte/paper.html?id=SchulteStuckey:TOPLAS:2008> http://www.gecode.org/~schulte/paper.html?id=SchulteStuckey:TOPLAS:2008

 

There might be more to gain for set variables, but I am only guessing here.

 

Cheers

Christian

 

--

Christian Schulte, KTH, web.it.kth.se/~cschulte/

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf Of Gustavo Gutierrez
Sent: Wednesday, August 20, 2014 07:26 PM
To: Guido Tack
Cc: gecode list
Subject: Re: [gecode-users] Set propagators and modification event delta

 

Hi Guido,

 

Thanks for the answer. Did you measured the impact of using modification events in the propagate method versus normal implementations of the propagators?  

 

What I mean by normal implementations is suppose you implement the pruning rules without taking into account what have changed since the last time. That will of course maintain the correctness but you will end up applying unnecessary operations. Are the two variants significantly different in the case of set variables?

 

I'm asking this because using modifications events lead to more involved code and is very easy to get it wrong. But on the other hand, is something I will keep doing for performance reasons. 

 

Regards,

Gustavo

?
Gustavo 

 

On Wed, Aug 20, 2014 at 3:27 AM, Guido Tack <tack at gecode.org <mailto:tack at gecode.org> > wrote:

Hi Gustavo, 

modification events are really sets of modifications, e.g. if you have only a lower bound modification the event is ME_SET_GLB, for only upper bound it's ME_SET_LUB, but if both have been modified you get ME_SET_BB. 

You guessed correctly: The testSetEventLB function returns true if the argument event contains a lower bound modification (so it could be ME_SET_GLB, ME_SET_BB, ME_SET_CGLB or ME_SET_CBB). The versions with multiple arguments test whether any of them contains a lower bound modification (the implementation computes the union of the events and then does the check). 

Cheers, 
Guido 

On 20 Aug 2014, at 12:33 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com <mailto:gustavo.ggutierrez at gmail.com> > wrote: 

> Dear all, 
> 
> I am trying to write a propagator and I really would like to take advantage of the modification event information offered by the geocode kernel in the respective argument to the propagate method. To that end, I am looking at set propagators as an example. In concrete I am looking at the code of the intersection propagator in inter.hpp. 
> 
> That implementation calls testSetEventLB defined in common.hpp. My question is concrete: does this function returns true when the modification event passed as parameter signals a modification of the lower bound?. My intuition from its definition and the internal functions it uses tell me so but I would like to corroborate it with you. 
> 
> There are other testSetEvent* that take a different number of arguments (all of them being modification events). For example, testSetEventLB with two arguments. Does this one returns true if any of the two events imply modification to the lower bounds? 
> 
> Best regards, 
> -- 
> Gustavo Gutierrez 
> _______________________________________________ 
> Gecode users mailing list 
> users at gecode.org <mailto:users at gecode.org>  
> https://www.gecode.org/mailman/listinfo/gecode-users 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140820/66e027bb/attachment.html>

From gustavo.ggutierrez at gmail.com  Wed Aug 20 21:18:35 2014
From: gustavo.ggutierrez at gmail.com (Gustavo Gutierrez)
Date: Wed, 20 Aug 2014 12:18:35 -0700 (PDT)
Subject: [gecode-users] Set propagators and modification event delta
In-Reply-To: <004301cfbca2$67371260$35a53720$@kth.se>
References: <004301cfbca2$67371260$35a53720$@kth.se>
Message-ID: <1408562314610.cef06d94@Nodemailer>

Hi Christian,


Thanks a lot for the paper reference. It was indeed the kind of experimentation I was looking for. I have two further questions, the first of them ?I probably know the answer already but I just one confirmation.




1) Suppose you have two solvers for the same csp that only differ in the first one not using any optimization like modification events or dynamic scheduling of propagators. The second one uses the optimization so described in the paper you pointed out. Given that both solvers are applied to the same problem instance the search trees must be the same, right?. My guess here is founded on the fact that we talk about an optimization but in both cases every solver will compute the same fix point for every node in the search tree.?




2) Let suppose a solver that uses both finite domains and finite sets. Let me suppose also for this question that propagating on set variables is more expensive that on integer variables (probably due to the domain representation ). Now, if there are two propagators in the solver that report the same cost, for instance binary::high does the geode kernel make any distinction between them when they are going to be executed?.




My last question is derived from the following use case. How do I force the execution of all propagators on set variables after all the propagators on finite variables have been executed.?




Regards,

Gustavo
?
Gustavo

On Wed, Aug 20, 2014 at 1:12 PM, Christian Schulte <cschulte at kth.se>
wrote:

> We have measured the impact for integer variables even with different modification events. You can check it here:
>               <http://www.gecode.org/~schulte/paper.html?id=SchulteStuckey:TOPLAS:2008> http://www.gecode.org/~schulte/paper.html?id=SchulteStuckey:TOPLAS:2008
>  
> There might be more to gain for set variables, but I am only guessing here.
>  
> Cheers
> Christian
>  
> --
> Christian Schulte, KTH, web.it.kth.se/~cschulte/
>  
> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf Of Gustavo Gutierrez
> Sent: Wednesday, August 20, 2014 07:26 PM
> To: Guido Tack
> Cc: gecode list
> Subject: Re: [gecode-users] Set propagators and modification event delta
>  
> Hi Guido,
>  
> Thanks for the answer. Did you measured the impact of using modification events in the propagate method versus normal implementations of the propagators?  
>  
> What I mean by normal implementations is suppose you implement the pruning rules without taking into account what have changed since the last time. That will of course maintain the correctness but you will end up applying unnecessary operations. Are the two variants significantly different in the case of set variables?
>  
> I'm asking this because using modifications events lead to more involved code and is very easy to get it wrong. But on the other hand, is something I will keep doing for performance reasons. 
>  
> Regards,
> Gustavo
> ?
> Gustavo 
>  
> On Wed, Aug 20, 2014 at 3:27 AM, Guido Tack <tack at gecode.org <mailto:tack at gecode.org> > wrote:
> Hi Gustavo, 
> modification events are really sets of modifications, e.g. if you have only a lower bound modification the event is ME_SET_GLB, for only upper bound it's ME_SET_LUB, but if both have been modified you get ME_SET_BB. 
> You guessed correctly: The testSetEventLB function returns true if the argument event contains a lower bound modification (so it could be ME_SET_GLB, ME_SET_BB, ME_SET_CGLB or ME_SET_CBB). The versions with multiple arguments test whether any of them contains a lower bound modification (the implementation computes the union of the events and then does the check). 
> Cheers, 
> Guido 
> On 20 Aug 2014, at 12:33 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com <mailto:gustavo.ggutierrez at gmail.com> > wrote: 
>> Dear all, 
>> 
>> I am trying to write a propagator and I really would like to take advantage of the modification event information offered by the geocode kernel in the respective argument to the propagate method. To that end, I am looking at set propagators as an example. In concrete I am looking at the code of the intersection propagator in inter.hpp. 
>> 
>> That implementation calls testSetEventLB defined in common.hpp. My question is concrete: does this function returns true when the modification event passed as parameter signals a modification of the lower bound?. My intuition from its definition and the internal functions it uses tell me so but I would like to corroborate it with you. 
>> 
>> There are other testSetEvent* that take a different number of arguments (all of them being modification events). For example, testSetEventLB with two arguments. Does this one returns true if any of the two events imply modification to the lower bounds? 
>> 
>> Best regards, 
>> -- 
>> Gustavo Gutierrez 
>> _______________________________________________ 
>> Gecode users mailing list 
>> users at gecode.org <mailto:users at gecode.org>  
>> https://www.gecode.org/mailman/listinfo/gecode-users 
>  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140820/b6ca7619/attachment-0001.html>

From tack at gecode.org  Thu Aug 21 02:03:15 2014
From: tack at gecode.org (Guido Tack)
Date: Thu, 21 Aug 2014 10:03:15 +1000
Subject: [gecode-users] Set propagators and modification event delta
In-Reply-To: <1408562314610.cef06d94@Nodemailer>
References: <004301cfbca2$67371260$35a53720$@kth.se>
	<1408562314610.cef06d94@Nodemailer>
Message-ID: <8A4112E5-60E2-48E8-88BB-75DDEF4E587A@gecode.org>

On 21 Aug 2014, at 5:18 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com> wrote:

> Hi Christian,
> 
> Thanks a lot for the paper reference. It was indeed the kind of experimentation I was looking for. I have two further questions, the first of them  I probably know the answer already but I just one confirmation.
> 
> 1) Suppose you have two solvers for the same csp that only differ in the first one not using any optimization like modification events or dynamic scheduling of propagators. The second one uses the optimization so described in the paper you pointed out. Given that both solvers are applied to the same problem instance the search trees must be the same, right?. My guess here is founded on the fact that we talk about an optimization but in both cases every solver will compute the same fix point for every node in the search tree. 

That's correct (as long as the propagators are monotonic, which most of them are).

> 2) Let suppose a solver that uses both finite domains and finite sets. Let me suppose also for this question that propagating on set variables is more expensive that on integer variables (probably due to the domain representation ). Now, if there are two propagators in the solver that report the same cost, for instance binary::high does the geode kernel make any distinction between them when they are going to be executed?.

No, the variable type does not have an influence on the scheduling.  You'd have to give your set propagators a higher cost if you want them to be scheduled after the integer propagators.

> My last question is derived from the following use case. How do I force the execution of all propagators on set variables after all the propagators on finite variables have been executed. 

As I said, give them higher cost.  But you probably won't be able to guarantee execution order (and a propagator for x subset y might be a lot cheaper than alldifferent on an array of integer variables!).

Cheers,
Guido


> 
> Regards,
> Gustavo
> ?
> Gustavo
> 
> 
> On Wed, Aug 20, 2014 at 1:12 PM, Christian Schulte <cschulte at kth.se> wrote:
> 
> We have measured the impact for integer variables even with different modification events. You can check it here:
> 
> 
> 
>              http://www.gecode.org/~schulte/paper.html?id=SchulteStuckey:TOPLAS:2008
> 
> 
> 
> 
>  
> 
> There might be more to gain for set variables, but I am only guessing here.
> 
> 
> 
> 
>  
> 
> Cheers
> 
> 
> 
> Christian
> 
> 
> 
> 
>  
> 
> --
> 
> 
> 
> Christian Schulte, KTH, web.it.kth.se/~cschulte/
> 
> 
> 
> 
>  
> 
> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf Of Gustavo Gutierrez
> Sent: Wednesday, August 20, 2014 07:26 PM
> To: Guido Tack
> Cc: gecode list
> Subject: Re: [gecode-users] Set propagators and modification event delta
> 
> 
> 
> 
>  
> Hi Guido,
> 
> 
> 
>  
> Thanks for the answer. Did you measured the impact of using modification events in the propagate method versus normal implementations of the propagators?  
> 
> 
> 
>  
> What I mean by normal implementations is suppose you implement the pruning rules without taking into account what have changed since the last time. That will of course maintain the correctness but you will end up applying unnecessary operations. Are the two variants significantly different in the case of set variables?
> 
> 
> 
>  
> I'm asking this because using modifications events lead to more involved code and is very easy to get it wrong. But on the other hand, is something I will keep doing for performance reasons. 
> 
> 
> 
>  
> Regards,
> 
> 
> Gustavo
> 
> 
> ?
> Gustavo
> 
> 
> 
>  
> On Wed, Aug 20, 2014 at 3:27 AM, Guido Tack <tack at gecode.org> wrote:
> 
> 
> Hi Gustavo, 
> 
> modification events are really sets of modifications, e.g. if you have only a lower bound modification the event is ME_SET_GLB, for only upper bound it's ME_SET_LUB, but if both have been modified you get ME_SET_BB. 
> 
> You guessed correctly: The testSetEventLB function returns true if the argument event contains a lower bound modification (so it could be ME_SET_GLB, ME_SET_BB, ME_SET_CGLB or ME_SET_CBB). The versions with multiple arguments test whether any of them contains a lower bound modification (the implementation computes the union of the events and then does the check). 
> 
> Cheers, 
> Guido 
> 
> On 20 Aug 2014, at 12:33 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com> wrote: 
> 
> > Dear all, 
> > 
> > I am trying to write a propagator and I really would like to take advantage of the modification event information offered by the geocode kernel in the respective argument to the propagate method. To that end, I am looking at set propagators as an example. In concrete I am looking at the code of the intersection propagator in inter.hpp. 
> > 
> > That implementation calls testSetEventLB defined in common.hpp. My question is concrete: does this function returns true when the modification event passed as parameter signals a modification of the lower bound?. My intuition from its definition and the internal functions it uses tell me so but I would like to corroborate it with you. 
> > 
> > There are other testSetEvent* that take a different number of arguments (all of them being modification events). For example, testSetEventLB with two arguments. Does this one returns true if any of the two events imply modification to the lower bounds? 
> > 
> > Best regards, 
> > -- 
> > Gustavo Gutierrez 
> > _______________________________________________ 
> > Gecode users mailing list 
> > users at gecode.org 
> > https://www.gecode.org/mailman/listinfo/gecode-users
> 
> 
> 
>  
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140821/59614c40/attachment.html>

From gustavo.ggutierrez at gmail.com  Thu Aug 21 04:25:45 2014
From: gustavo.ggutierrez at gmail.com (Gustavo Gutierrez)
Date: Wed, 20 Aug 2014 19:25:45 -0700 (PDT)
Subject: [gecode-users] Set propagators and modification event delta
In-Reply-To: <8A4112E5-60E2-48E8-88BB-75DDEF4E587A@gecode.org>
References: <8A4112E5-60E2-48E8-88BB-75DDEF4E587A@gecode.org>
Message-ID: <1408587944232.f26576d7@Nodemailer>

Thanks much for your help!


Regards,

Gustavo
?
Gustavo

On Wed, Aug 20, 2014 at 7:03 PM, Guido Tack <tack at gecode.org> wrote:

> On 21 Aug 2014, at 5:18 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com> wrote:
>> Hi Christian,
>> 
>> Thanks a lot for the paper reference. It was indeed the kind of experimentation I was looking for. I have two further questions, the first of them  I probably know the answer already but I just one confirmation.
>> 
>> 1) Suppose you have two solvers for the same csp that only differ in the first one not using any optimization like modification events or dynamic scheduling of propagators. The second one uses the optimization so described in the paper you pointed out. Given that both solvers are applied to the same problem instance the search trees must be the same, right?. My guess here is founded on the fact that we talk about an optimization but in both cases every solver will compute the same fix point for every node in the search tree. 
> That's correct (as long as the propagators are monotonic, which most of them are).
>> 2) Let suppose a solver that uses both finite domains and finite sets. Let me suppose also for this question that propagating on set variables is more expensive that on integer variables (probably due to the domain representation ). Now, if there are two propagators in the solver that report the same cost, for instance binary::high does the geode kernel make any distinction between them when they are going to be executed?.
> No, the variable type does not have an influence on the scheduling.  You'd have to give your set propagators a higher cost if you want them to be scheduled after the integer propagators.
>> My last question is derived from the following use case. How do I force the execution of all propagators on set variables after all the propagators on finite variables have been executed. 
> As I said, give them higher cost.  But you probably won't be able to guarantee execution order (and a propagator for x subset y might be a lot cheaper than alldifferent on an array of integer variables!).
> Cheers,
> Guido
>> 
>> Regards,
>> Gustavo
>> ?
>> Gustavo
>> 
>> 
>> On Wed, Aug 20, 2014 at 1:12 PM, Christian Schulte <cschulte at kth.se> wrote:
>> 
>> We have measured the impact for integer variables even with different modification events. You can check it here:
>> 
>> 
>> 
>>              http://www.gecode.org/~schulte/paper.html?id=SchulteStuckey:TOPLAS:2008
>> 
>> 
>> 
>> 
>>  
>> 
>> There might be more to gain for set variables, but I am only guessing here.
>> 
>> 
>> 
>> 
>>  
>> 
>> Cheers
>> 
>> 
>> 
>> Christian
>> 
>> 
>> 
>> 
>>  
>> 
>> --
>> 
>> 
>> 
>> Christian Schulte, KTH, web.it.kth.se/~cschulte/
>> 
>> 
>> 
>> 
>>  
>> 
>> From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf Of Gustavo Gutierrez
>> Sent: Wednesday, August 20, 2014 07:26 PM
>> To: Guido Tack
>> Cc: gecode list
>> Subject: Re: [gecode-users] Set propagators and modification event delta
>> 
>> 
>> 
>> 
>>  
>> Hi Guido,
>> 
>> 
>> 
>>  
>> Thanks for the answer. Did you measured the impact of using modification events in the propagate method versus normal implementations of the propagators?  
>> 
>> 
>> 
>>  
>> What I mean by normal implementations is suppose you implement the pruning rules without taking into account what have changed since the last time. That will of course maintain the correctness but you will end up applying unnecessary operations. Are the two variants significantly different in the case of set variables?
>> 
>> 
>> 
>>  
>> I'm asking this because using modifications events lead to more involved code and is very easy to get it wrong. But on the other hand, is something I will keep doing for performance reasons. 
>> 
>> 
>> 
>>  
>> Regards,
>> 
>> 
>> Gustavo
>> 
>> 
>> ?
>> Gustavo
>> 
>> 
>> 
>>  
>> On Wed, Aug 20, 2014 at 3:27 AM, Guido Tack <tack at gecode.org> wrote:
>> 
>> 
>> Hi Gustavo, 
>> 
>> modification events are really sets of modifications, e.g. if you have only a lower bound modification the event is ME_SET_GLB, for only upper bound it's ME_SET_LUB, but if both have been modified you get ME_SET_BB. 
>> 
>> You guessed correctly: The testSetEventLB function returns true if the argument event contains a lower bound modification (so it could be ME_SET_GLB, ME_SET_BB, ME_SET_CGLB or ME_SET_CBB). The versions with multiple arguments test whether any of them contains a lower bound modification (the implementation computes the union of the events and then does the check). 
>> 
>> Cheers, 
>> Guido 
>> 
>> On 20 Aug 2014, at 12:33 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com> wrote: 
>> 
>> > Dear all, 
>> > 
>> > I am trying to write a propagator and I really would like to take advantage of the modification event information offered by the geocode kernel in the respective argument to the propagate method. To that end, I am looking at set propagators as an example. In concrete I am looking at the code of the intersection propagator in inter.hpp. 
>> > 
>> > That implementation calls testSetEventLB defined in common.hpp. My question is concrete: does this function returns true when the modification event passed as parameter signals a modification of the lower bound?. My intuition from its definition and the internal functions it uses tell me so but I would like to corroborate it with you. 
>> > 
>> > There are other testSetEvent* that take a different number of arguments (all of them being modification events). For example, testSetEventLB with two arguments. Does this one returns true if any of the two events imply modification to the lower bounds? 
>> > 
>> > Best regards, 
>> > -- 
>> > Gustavo Gutierrez 
>> > _______________________________________________ 
>> > Gecode users mailing list 
>> > users at gecode.org 
>> > https://www.gecode.org/mailman/listinfo/gecode-users
>> 
>> 
>> 
>>  
>> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140820/bc594027/attachment-0001.html>

From cschulte at kth.se  Thu Aug 21 10:06:47 2014
From: cschulte at kth.se (Christian Schulte)
Date: Thu, 21 Aug 2014 10:06:47 +0200
Subject: [gecode-users] Set propagators and modification event delta
In-Reply-To: <1408587944232.f26576d7@Nodemailer>
References: <8A4112E5-60E2-48E8-88BB-75DDEF4E587A@gecode.org>
	<1408587944232.f26576d7@Nodemailer>
Message-ID: <008601cfbd16$dae3b500$90ab1f00$@kth.se>

There is one more thing: when giving the cost for a propagator in Gecode, you give its complexity and an additional hint whether it has a low or high constant factor. This is then rolled into a cost value by the kernel and used for scheduling. So you have an influence by choosing either a high or low constant factor.

 

And as Guido said, simple set propagators are more costly than simple integer propagators. But many integer propagators _do_ something sophisticated and hence costly: build a graph, etc, Set propagators tend to not do that.

 

One thing that I always wanted to do, but never did is the following: choose a set of benchmarks (must be large) and experimentally determine good cost factors for them. But that would take gazillion years to run.

 

Cheers

Christian

 

--

Christian Schulte, Professor of Computer Science, KTH,  www.ict.kth.se/~cschulte/

 

 

From: Gustavo Gutierrez [mailto:gustavo.ggutierrez at gmail.com] 
Sent: Thursday, August 21, 2014 4:26 AM
To: Guido Tack
Cc: Christian Schulte; gecode list
Subject: Re: [gecode-users] Set propagators and modification event delta

 

Thanks much for your help!

 

Regards,

Gustavo

?
Gustavo 

 

On Wed, Aug 20, 2014 at 7:03 PM, Guido Tack <tack at gecode.org> wrote:

On 21 Aug 2014, at 5:18 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com> wrote:





Hi Christian,

 

Thanks a lot for the paper reference. It was indeed the kind of experimentation I was looking for. I have two further questions, the first of them  I probably know the answer already but I just one confirmation.

 

1) Suppose you have two solvers for the same csp that only differ in the first one not using any optimization like modification events or dynamic scheduling of propagators. The second one uses the optimization so described in the paper you pointed out. Given that both solvers are applied to the same problem instance the search trees must be the same, right?. My guess here is founded on the fact that we talk about an optimization but in both cases every solver will compute the same fix point for every node in the search tree. 

 

That's correct (as long as the propagators are monotonic, which most of them are).

 

2) Let suppose a solver that uses both finite domains and finite sets. Let me suppose also for this question that propagating on set variables is more expensive that on integer variables (probably due to the domain representation ). Now, if there are two propagators in the solver that report the same cost, for instance binary::high does the geode kernel make any distinction between them when they are going to be executed?.

 

No, the variable type does not have an influence on the scheduling.  You'd have to give your set propagators a higher cost if you want them to be scheduled after the integer propagators.





My last question is derived from the following use case. How do I force the execution of all propagators on set variables after all the propagators on finite variables have been executed. 

 

As I said, give them higher cost.  But you probably won't be able to guarantee execution order (and a propagator for x subset y might be a lot cheaper than alldifferent on an array of integer variables!).

 

Cheers,

Guido

 





 

Regards,

Gustavo

?
Gustavo 

 

On Wed, Aug 20, 2014 at 1:12 PM, Christian Schulte <cschulte at kth.se> wrote:

We have measured the impact for integer variables even with different modification events. You can check it here:

 

 

              <http://www.gecode.org/~schulte/paper.html?id=SchulteStuckey:TOPLAS:2008> http://www.gecode.org/~schulte/paper.html?id=SchulteStuckey:TOPLAS:2008

 

 

 

 

 

There might be more to gain for set variables, but I am only guessing here.

 

 

 

 

 

Cheers

 

 

Christian

 

 

 

 

 

--

 

 

Christian Schulte, KTH, web.it.kth.se/~cschulte/

 

 

 

 

 

From: users-bounces at gecode.org [mailto:users-bounces at gecode.org] On Behalf Of Gustavo Gutierrez
Sent: Wednesday, August 20, 2014 07:26 PM
To: Guido Tack
Cc: gecode list
Subject: Re: [gecode-users] Set propagators and modification event delta

 

 

 

 

Hi Guido,

 

 

 

Thanks for the answer. Did you measured the impact of using modification events in the propagate method versus normal implementations of the propagators?  

 

 

 

What I mean by normal implementations is suppose you implement the pruning rules without taking into account what have changed since the last time. That will of course maintain the correctness but you will end up applying unnecessary operations. Are the two variants significantly different in the case of set variables?

 

 

 

I'm asking this because using modifications events lead to more involved code and is very easy to get it wrong. But on the other hand, is something I will keep doing for performance reasons. 

 

 

 

Regards,

 

Gustavo

 

?
Gustavo 

 

 

 

On Wed, Aug 20, 2014 at 3:27 AM, Guido Tack <tack at gecode.org> wrote:

 

Hi Gustavo, 

modification events are really sets of modifications, e.g. if you have only a lower bound modification the event is ME_SET_GLB, for only upper bound it's ME_SET_LUB, but if both have been modified you get ME_SET_BB. 

You guessed correctly: The testSetEventLB function returns true if the argument event contains a lower bound modification (so it could be ME_SET_GLB, ME_SET_BB, ME_SET_CGLB or ME_SET_CBB). The versions with multiple arguments test whether any of them contains a lower bound modification (the implementation computes the union of the events and then does the check). 

Cheers, 
Guido 

On 20 Aug 2014, at 12:33 am, Gustavo Gutierrez <gustavo.ggutierrez at gmail.com> wrote: 

> Dear all, 
> 
> I am trying to write a propagator and I really would like to take advantage of the modification event information offered by the geocode kernel in the respective argument to the propagate method. To that end, I am looking at set propagators as an example. In concrete I am looking at the code of the intersection propagator in inter.hpp. 
> 
> That implementation calls testSetEventLB defined in common.hpp. My question is concrete: does this function returns true when the modification event passed as parameter signals a modification of the lower bound?. My intuition from its definition and the internal functions it uses tell me so but I would like to corroborate it with you. 
> 
> There are other testSetEvent* that take a different number of arguments (all of them being modification events). For example, testSetEventLB with two arguments. Does this one returns true if any of the two events imply modification to the lower bounds? 
> 
> Best regards, 
> -- 
> Gustavo Gutierrez 
> _______________________________________________ 
> Gecode users mailing list 
> users at gecode.org 
> https://www.gecode.org/mailman/listinfo/gecode-users 

 

 

 

 

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://www.gecode.org/pipermail/users/attachments/20140821/88236033/attachment.html>

