=== modified file 'gecode/set/int.hh'
--- gecode/set/int.hh	2008-12-14 14:14:03 +0000
+++ gecode/set/int.hh	2008-12-14 14:20:02 +0000
@@ -84,6 +84,40 @@
   };
 
   /**
+   * \brief %Propagator for not minimum element
+   *
+   * Requires \code #include "gecode/set/int.hh" \endcode
+   * \ingroup FuncSetProp
+   */
+  template <class View>
+  class NotMinElement :
+    public IntSetPropagator<View,PC_SET_ANY,Gecode::Int::PC_INT_BND> {
+  protected:
+    using IntSetPropagator<View,PC_SET_ANY,Gecode::Int::PC_INT_BND>::x0;
+    using IntSetPropagator<View,PC_SET_ANY,Gecode::Int::PC_INT_BND>::x1;
+    /// Constructor for cloning \a p
+    NotMinElement(Space* home, bool share,NotMinElement& p);
+    /// Constructor for posting
+    NotMinElement(Space* home, View, Gecode::Int::IntView);
+  public:
+    /// Copy propagator during cloning
+    GECODE_SET_EXPORT virtual Actor*      copy(Space* home,bool);
+    /// Perform propagation
+    GECODE_SET_EXPORT virtual ExecStatus propagate(Space* home, ModEventDelta med);
+    /// Post propagator for \a x is not the minimal element of \a s 
+    static ExecStatus post(Space* home, View s, Gecode::Int::IntView x);
+    /// Specification for this propagator
+    GECODE_SET_EXPORT
+    virtual Reflection::ActorSpec spec(const Space* home,
+                                        Reflection::VarMap& m) const;
+    /// Post using specification
+    static void post(Space* home, Reflection::VarMap& vars,
+                     const Reflection::ActorSpec& spec);
+    /// Name of this propagator
+    static Support::Symbol ati(void);
+  };
+
+  /**
    * \brief %Propagator for maximum element
    *
    * Requires \code #include "gecode/set/int.hh" \endcode

=== modified file 'gecode/set/int/minmax.icc'
--- gecode/set/int/minmax.icc	2008-12-12 09:17:43 +0000
+++ gecode/set/int/minmax.icc	2008-12-14 14:20:02 +0000
@@ -40,7 +40,7 @@
  */
 
 
-
+#include <iostream>
 #include "gecode/set.hh"
 #include "gecode/int.hh"
 
@@ -155,6 +155,156 @@
 
   template <class View>
   forceinline
+  NotMinElement<View>::NotMinElement(Space* home, View y0, Gecode::Int::IntView y1)
+    : IntSetPropagator<View,PC_SET_ANY,
+                       Gecode::Int::PC_INT_BND> (home, y0, y1) {}
+
+  template <class View>
+  forceinline ExecStatus
+  NotMinElement<View>::post(Space* home, View x0, Gecode::Int::IntView x1) {
+    (void) new (home) NotMinElement(home,x0,x1);
+    return ES_OK;
+  }
+
+  template <class View>
+  forceinline
+  NotMinElement<View>::NotMinElement(Space* home, bool share, NotMinElement& p)
+    : IntSetPropagator<View,PC_SET_ANY,
+                       Gecode::Int::PC_INT_BND> (home, share, p) {}
+
+  template <class View>
+  Actor*
+  NotMinElement<View>::copy(Space* home, bool share) {
+   return new (home) NotMinElement(home,share,*this);
+  }
+
+  template <class View>
+  Support::Symbol
+  NotMinElement<View>::ati(void) {
+   return Reflection::mangle<View>("Gecode::Set::Int::NotMinElement");
+  }
+
+  template <class View>
+  Reflection::ActorSpec
+  NotMinElement<View>::spec(const Space* home, Reflection::VarMap& m) const {
+   return IntSetPropagator<View,PC_SET_ANY,Gecode::Int::PC_INT_BND>
+     ::spec(home, m, ati());
+  }
+
+  template <class View>
+  void
+  NotMinElement<View>::post(Space* home, Reflection::VarMap& vars,
+                         const Reflection::ActorSpec& spec) {
+    spec.checkArity(2);
+    View x0(home, vars, spec[0]);
+    Gecode::Int::IntView x1(home, vars, spec[1]);
+    (void) post(home,x0,x1);
+  }
+
+  template <class View>
+  ExecStatus
+  NotMinElement<View>::propagate(Space* home, ModEventDelta) {
+    // cheap tests for entailment:
+    // if x0 is empty, then entailed
+    // if max(x1) < min(x0.lub) or min(x1) > max(x0.lub), then entailed
+    // if min(x0.glb) < min(x1), then entailed
+    if ((x0.cardMax() == 0) ||
+        ((x1.max() < x0.lubMin()) || (x1.min() > x0.lubMax())) ||
+        ((x0.glbSize() > 0) && (x0.glbMin() < x1.min())))
+      return ES_SUBSUMED(this, home);
+    // if x1 is determined and = x0.lub.min: remove it from x0,
+    // then entailed
+    if (x1.assigned() && x1.val()==x0.lubMin())
+      {
+        GECODE_ME_CHECK(x0.exclude(home,x1.val()));
+        return ES_SUBSUMED(this, home);
+      }
+    // if min(x0) is decided: remove min(x0) from the domain of x1
+    // then entailed
+    if (x0.glbMin() == x0.lubMin())
+    {
+      GECODE_ME_CHECK(x1.nq(home,x0.glbMin()));
+      return ES_SUBSUMED(this, home);
+    }
+    // if x1 is determined and = x0.glb.min, then we need at least
+    // one more element; if there is only one below, then we must
+    // take it.
+    if (x1.assigned() && x0.glbSize() > 0 && x1.val()==x0.glbMin())
+      {
+        if (x0.cardMin() == x0.glbSize())
+          GECODE_ME_CHECK(x0.cardMin(home, x0.cardMin()+1));
+        // if there is only 1 unknown below x1, then we must take it
+        UnknownRanges<View> ur(x0);
+        // the iterator is not empty: otherwise x0 would be determined
+        // and min(x0) would have been decided and the preceding if
+        // would have caught it.  Also, the first range is not above
+        // x1 otherwise the very first if would have caught it.
+        // so let's check if the very first range of unknowns is of
+        // size 1 and there is no second one or it starts above x1.
+        if (ur.width()==1)
+          {
+            int i=ur.min();
+            ++ur;
+            if (!ur() || ur.min()>x1.val())
+              {
+                GECODE_ME_CHECK(x0.include(home,i));
+                return ES_SUBSUMED(this, home);
+              }
+          }
+      }
+    // if dom(x1) and lub(x0) are disjoint, then entailed;
+    {
+      LubRanges<View> ub(x0);
+      Gecode::Int::ViewRanges<Gecode::Int::IntView> d(x1);
+      Gecode::Iter::Ranges::Inter<LubRanges<View>,
+        Gecode::Int::ViewRanges<Gecode::Int::IntView> > ir(ub,d);
+      if (!ir()) return ES_SUBSUMED(this, home);
+    }
+    // x0 is fated to eventually contain at least x0.cardMin elements.
+    // therefore min(x0) <= x0.cardMin-th largest element of x0.lub
+    // if x1 > than that, then entailed.
+    {
+      // to find the x0.cardMin-th largest element of x0.lub, we need
+      // some sort of reverse range iterator. we will need to fake one
+      // by storing the ranges of the forward iterator in an array.
+      // first we need to know how large the array needs to be. so, let's
+      // count the ranges:
+      int num_ranges = 0;
+      for (LubRanges<View> ur(x0); ur(); ++ur, ++num_ranges) {}
+      // create an array for storing min and max of each range
+      GECODE_AUTOARRAY(int, _ur, num_ranges*2);
+      // now, we fill the array:
+      int i = 0;
+      for (LubRanges<View> ur(x0); ur(); ++ur, ++i) {
+        _ur[2*i  ] = ur.min();
+        _ur[2*i+1] = ur.max();
+      }
+      // now we search from the top the range that contains the
+      // nth largest value.
+      int n = x0.cardMin();
+      int nth_largest = BndSet::MAX_OF_EMPTY;
+      for (int i=num_ranges; i--; ) {
+        // number of values in range
+        int num_values = _ur[2*i+1]-_ur[2*i]+1;
+        // does the range contain the value?
+        if (num_values >= n)
+          {
+            // record it and exit the loop
+            nth_largest = _ur[2*i+1]-n+1;
+            break;
+          }
+        // otherwise, we skipped num_values
+        n -= num_values;
+      }
+      // if x1.min > nth_largest, then entailed
+      if (x1.min() > nth_largest)
+        return ES_SUBSUMED(this, home);
+    }
+    return ES_FIX;
+  }
+
+  template <class View>
+  forceinline
   MaxElement<View>::MaxElement(Space* home, View y0, Gecode::Int::IntView y1)
     : IntSetPropagator<View,PC_SET_ANY,
                        Gecode::Int::PC_INT_BND> (home, y0, y1) {}

