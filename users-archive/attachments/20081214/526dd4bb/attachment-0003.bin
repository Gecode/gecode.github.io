=== modified file 'gecode/set/int.hh'
--- gecode/set/int.hh	2008-12-14 14:20:02 +0000
+++ gecode/set/int.hh	2008-12-14 14:41:16 +0000
@@ -152,6 +152,40 @@
   };
 
   /**
+   * \brief %Propagator for not maximum element
+   *
+   * Requires \code #include "gecode/set/int.hh" \endcode
+   * \ingroup FuncSetProp
+   */
+  template <class View>
+  class NotMaxElement :
+    public IntSetPropagator<View,PC_SET_ANY,Gecode::Int::PC_INT_BND> {
+  protected:
+    using IntSetPropagator<View,PC_SET_ANY,Gecode::Int::PC_INT_BND>::x0;
+    using IntSetPropagator<View,PC_SET_ANY,Gecode::Int::PC_INT_BND>::x1;
+    /// Constructor for cloning \a p
+    NotMaxElement(Space* home, bool share,NotMaxElement& p);
+    /// Constructor for posting
+    NotMaxElement(Space* home, View, Gecode::Int::IntView);
+  public:
+    /// Copy propagator during cloning
+    GECODE_SET_EXPORT virtual Actor*      copy(Space* home,bool);
+    /// Perform propagation
+    GECODE_SET_EXPORT virtual ExecStatus propagate(Space* home, ModEventDelta med);
+    /// Post propagator for \a x is not the largest element of \a s 
+    static ExecStatus post(Space* home, View s, Gecode::Int::IntView x);
+    /// Specification for this propagator
+    GECODE_SET_EXPORT
+    virtual Reflection::ActorSpec spec(const Space* home,
+                                        Reflection::VarMap& m) const;
+    /// Post using specification
+    static void post(Space* home, Reflection::VarMap& vars,
+                     const Reflection::ActorSpec& spec);
+    /// Name of this propagator
+    static Support::Symbol ati(void);
+  };
+
+  /**
    * \brief %Propagator for cardinality
    *
    * Requires \code #include "gecode/set/int.hh" \endcode

=== modified file 'gecode/set/int/minmax.icc'
--- gecode/set/int/minmax.icc	2008-12-14 14:20:02 +0000
+++ gecode/set/int/minmax.icc	2008-12-14 14:41:16 +0000
@@ -373,6 +373,136 @@
 
     return ES_FIX;
   }  
+
+  template <class View>
+  forceinline
+  NotMaxElement<View>::NotMaxElement(Space* home, View y0, Gecode::Int::IntView y1)
+    : IntSetPropagator<View,PC_SET_ANY,
+                       Gecode::Int::PC_INT_BND> (home, y0, y1) {}
+
+  template <class View>
+  forceinline
+  NotMaxElement<View>::NotMaxElement(Space* home, bool share, NotMaxElement& p)
+    : IntSetPropagator<View,PC_SET_ANY,
+                       Gecode::Int::PC_INT_BND> (home, share, p) {}
+
+  template <class View>
+  ExecStatus
+  NotMaxElement<View>::post(Space* home, View x0,
+                              Gecode::Int::IntView x1) {
+    (void) new (home) NotMaxElement(home,x0,x1);
+    return ES_OK;
+  }
+
+  template <class View>
+  Actor*
+  NotMaxElement<View>::copy(Space* home, bool share) {
+    return new (home) NotMaxElement(home,share,*this);
+  }
+
+  template <class View>
+  Support::Symbol
+  NotMaxElement<View>::ati(void) {
+    return Reflection::mangle<View>("Gecode::Set::Int::NotMaxElement");
+  }
+
+  template <class View>
+  Reflection::ActorSpec
+  NotMaxElement<View>::spec(const Space* home, Reflection::VarMap& m) const {
+    return IntSetPropagator<View,PC_SET_ANY,Gecode::Int::PC_INT_BND>
+      ::spec(home, m, ati());
+  }
+
+  template <class View>
+  void
+  NotMaxElement<View>::post(Space* home, Reflection::VarMap& vars,
+                         const Reflection::ActorSpec& spec) {
+    spec.checkArity(2);
+    View x0(home, vars, spec[0]);
+    Gecode::Int::IntView x1(home, vars, spec[1]);
+    (void) new (home) NotMaxElement<View>(home,x0,x1);
+  }
+
+  template <class View>
+  ExecStatus
+  NotMaxElement<View>::propagate(Space* home, ModEventDelta) {
+    // cheap tests for entailment:
+    // if x0 is empty, then entailed
+    // if max(x1) < min(x0.lub) or min(x1) > max(x0.lub), then entailed
+    // if max(x0.glb) > max(x1), then entailed
+    if ((x0.cardMax() == 0) ||
+        ((x1.max() < x0.lubMin()) || (x1.min() > x0.lubMax())) ||
+        ((x0.glbSize() > 0) && (x0.glbMax() > x1.max())))
+      return ES_SUBSUMED(this, home);
+    // if x1 is determined and = max(x0.lub): remove it from x0,
+    // then entailed
+    if (x1.assigned() && x1.val()==x0.lubMax())
+      {
+        GECODE_ME_CHECK(x0.exclude(home,x1.val()));
+        return ES_SUBSUMED(this, home);
+      }
+    // if max(x0) is decided: remove max(x0) from the domain of x1
+    // then entailed
+    if (x0.glbMax() == x0.lubMax())
+      {
+        GECODE_ME_CHECK(x1.nq(home,x0.glbMax()));
+        return ES_SUBSUMED(this, home);
+      }
+    // if x1 is determined and = max(x0.glb), then we need at least
+    // one more element; if there is only one above, then we must
+    // take it.
+    if (x1.assigned() && x0.glbSize() > 0 && x1.val()==x0.glbMax())
+      {
+        if (x0.cardMin() == x0.glbSize())
+          GECODE_ME_CHECK(x0.cardMin(home, x0.cardMin()+1));
+        // if there is only 1 unknown above x1, then we must take it
+        UnknownRanges<View> ur(x0);
+        // there is at least one unknown above x1 otherwise it would
+        // have been caught by the if for x1=max(x0.lub)
+        while (ur.min() < x1.val()) ++ur;
+        // if the first range above x1 contains just 1 element,
+        // and is the last range, then take that element
+        if (ur.width() == 1)
+          {
+            int i = ur.min();
+            ++ur;
+            if (!ur()) // last range
+              {
+                GECODE_ME_CHECK(x0.include(home,i));
+                return ES_SUBSUMED(this, home);
+              }
+          }
+      }
+    // if dom(x1) and lub(x0) are disjoint, then entailed
+    {
+      LubRanges<View> ub(x0);
+      Gecode::Int::ViewRanges<Gecode::Int::IntView> d(x1);
+      Gecode::Iter::Ranges::Inter<LubRanges<View>,
+        Gecode::Int::ViewRanges<Gecode::Int::IntView> > ir(ub,d);
+      if (!ir()) return ES_SUBSUMED(this, home);
+    }
+    // x0 is fated to eventually contain at least x0.cardMin elements.
+    // therefore max(x0) >= x0.cardMin-th smallest element of x0.lub.
+    // if x1 < than that, then entailed.
+    {
+      unsigned int n = x0.cardMin();
+      int nth_smallest = BndSet::MIN_OF_EMPTY;
+      for (LubRanges<View> ur(x0); ur(); ++ur) {
+        if (ur.width() >= n)
+          {
+            // record it and exit the loop
+            nth_smallest = ur.min() + n - 1;
+            break;
+          }
+        // otherwise, we skipped ur.width() values
+        n -= ur.width();
+      }
+      // if x1.max < nth_smallest, then entailed
+      if (x1.max() < nth_smallest)
+        return ES_SUBSUMED(this, home);
+    }
+    return ES_FIX;
+  }  
 }}}
 
 // STATISTICS: set-prop

