=== modified file 'gecode/serialization/register.cc'
--- gecode/serialization/register.cc	2008-12-14 14:50:16 +0000
+++ gecode/serialization/register.cc	2008-12-14 15:11:10 +0000
@@ -7574,6 +7574,18 @@
           return;
         }
 #endif
+#if defined(GECODE_HAS_SET_VARS)
+        if (isVar<Gecode::SetVar>(vm, spec[0]) &&
+            isVar<Gecode::IntVar>(vm, spec[1]) &&
+            isVar<Gecode::BoolVar>(vm, spec[2]))
+        {
+          Gecode::SetVar x0(vm.var(spec[0]->toVar()));
+          Gecode::IntVar x1(vm.var(spec[1]->toVar()));
+          Gecode::BoolVar x2(vm.var(spec[2]->toVar()));
+          Gecode::min(home, x0,x1,x2);
+          return;
+        }
+#endif
         throw Gecode::Reflection::ReflectionException("Argument type mismatch for Gecode::Post::min");
       }
       break;

=== modified file 'gecode/set.hh'
--- gecode/set.hh	2008-12-14 14:50:16 +0000
+++ gecode/set.hh	2008-12-14 15:11:10 +0000
@@ -820,6 +820,11 @@
   GECODE_SET_EXPORT void
   min(Space* home, SetVar s, IntVar x, bool b=true);
   
+  /** \brief Post reified propagator for \a b iff \a x is the minimal element
+   *  of \a s (which may be empty) */
+  GECODE_SET_EXPORT void
+  min(Space* home, SetVar s, IntVar x, BoolVar b);
+  
   /** \brief When \a b is true, post propagator that propagates that \a x is the
    *  maximal element of \a s, and that \a s is not empty.  When \a b is false,
    *  post propagator that \a x is not the max of \a s (which may be empty) */

=== modified file 'gecode/set/int.cc'
--- gecode/set/int.cc	2008-12-14 14:50:16 +0000
+++ gecode/set/int.cc	2008-12-14 15:11:10 +0000
@@ -126,6 +126,13 @@
       GECODE_ES_FAIL(home,Set::Int::NotMinElement<Set::SetView>::post(home,s,x));
     }
   }
+
+  void
+  min(Space* home, SetVar s, IntVar x, BoolVar b) {
+    if (home->failed()) return;
+    GECODE_ES_FAIL(home,Set::Int::ReMinElement<Set::SetView>::post(home,s,x,b));
+  }
+
   void
   max(Space* home, SetVar s, IntVar x, bool b){
     if (home->failed()) return;

