<tt>
&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;Hi&nbsp;all,&lt;br&gt;&lt;br&gt;&lt;/div&gt;I&nbsp;am&nbsp;wondering&nbsp;if&nbsp;I&nbsp;use&nbsp;Gecode&nbsp;the&nbsp;right&nbsp;way&nbsp;since&nbsp;I&nbsp;get&nbsp;poor&nbsp;performances&nbsp;on&nbsp;a&nbsp;simple&nbsp;optimal&nbsp;allocation&nbsp;problem.&nbsp;The&nbsp;B&amp;B&nbsp;search&nbsp;algorithm&nbsp;keeps&nbsp;improving&nbsp;the&nbsp;cost&nbsp;but&nbsp;without&nbsp;ever&nbsp;converging&nbsp;(even&nbsp;after&nbsp;several&nbsp;minutes)&nbsp;while&nbsp;the&nbsp;same&nbsp;problem&nbsp;is&nbsp;solved&nbsp;in&nbsp;less&nbsp;than&nbsp;100ms&nbsp;with&nbsp;the&nbsp;CBC&nbsp;solver&nbsp;from&nbsp;COIN.&nbsp;I&nbsp;must&nbsp;say&nbsp;that&nbsp;I&nbsp;am&nbsp;more&nbsp;comfortable&nbsp;with&nbsp;operation&nbsp;research&nbsp;algorithms&nbsp;than&nbsp;with&nbsp;CP&nbsp;ones,&nbsp;so&nbsp;it&nbsp;is&nbsp;possible&nbsp;that&nbsp;I&nbsp;misuse&nbsp;Gecode.&lt;br&gt;&lt;br&gt;&lt;/div&gt;The&nbsp;problem&nbsp;consists&nbsp;in&nbsp;assigning&nbsp;objects&nbsp;in&nbsp;A&nbsp;to&nbsp;objects&nbsp;in&nbsp;B&nbsp;so&nbsp;as&nbsp;to&nbsp;maximize&nbsp;the&nbsp;overall&nbsp;revenue.&lt;br&gt;Allocations&nbsp;are&nbsp;optional,&nbsp;i.e.&nbsp;a&nbsp;given&nbsp;object&nbsp;in&nbsp;B&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;have&nbsp;an&nbsp;assigned&nbsp;object&nbsp;from&nbsp;A&nbsp;if&nbsp;it&nbsp;decreases&nbsp;the&nbsp;overall&nbsp;revenue.&lt;br&gt;By&nbsp;abusing&nbsp;the&nbsp;notation&nbsp;I&nbsp;represent&nbsp;A&nbsp;and&nbsp;B&nbsp;as&nbsp;positive&nbsp;integers&nbsp;and&nbsp;the&nbsp;corresponding&nbsp;object&nbsp;sets&nbsp;as&nbsp;{0,...,A-1}&nbsp;and&nbsp;{0,...,B-1}&lt;br&gt;&lt;br&gt;ILP&nbsp;model:&lt;br&gt; &nbsp;*&nbsp;Decision&nbsp;variables:&nbsp;x(a,b)&nbsp;in&nbsp;{0,1}&nbsp;for&nbsp;each&nbsp;a&nbsp;in&nbsp;{0,...,A-1}&nbsp;and&nbsp;b&nbsp;in&nbsp;{0,...,B-1}&lt;br&gt; &nbsp;*&nbsp;R(a,b)=floor(A*B*cos(2*PI*a*b/A*B))&nbsp;is&nbsp;the&nbsp;revenue&nbsp;of&nbsp;the&nbsp;allocation&nbsp;pair&nbsp;(a,b)&lt;br&gt; &nbsp;*&nbsp;max&nbsp;sum_{a&nbsp;in&nbsp;{0,...,A-1},&nbsp;b&nbsp;in&nbsp;{0,...,B-1}}&nbsp;x(a,b)&nbsp;*&nbsp;R(a,b)&lt;br&gt; &nbsp;*&nbsp;for&nbsp;each&nbsp;a&nbsp;in&nbsp;{0,...,A-1}:&nbsp;sum(b&nbsp;in&nbsp;{0,...,B-1})&nbsp;x(a,b)&nbsp;&lt;=&nbsp;1&lt;br&gt; &nbsp;*&nbsp;for&nbsp;each&nbsp;b&nbsp;in&nbsp;{0,...,B-1}:&nbsp;sum(a&nbsp;in&nbsp;{0,...,A-1})&nbsp;x(a,b)&nbsp;&lt;=&nbsp;1&lt;br&gt;&lt;br&gt;CP&nbsp;model:&lt;br&gt; &nbsp;*&nbsp;Decision&nbsp;variables:&lt;br&gt;     &nbsp;-&nbsp;x(b)&nbsp;in&nbsp;{0,...,A}&nbsp;for&nbsp;each&nbsp;b&nbsp;in&nbsp;{0,...,B-1};&nbsp;x(b)=A&nbsp;when&nbsp;no&nbsp;object&nbsp;from&nbsp;A&nbsp;is&nbsp;assigned&nbsp;to&nbsp;b&lt;br&gt;     &nbsp;-&nbsp;y(b)&nbsp;=&nbsp;R(x(b),b)&nbsp;in&nbsp;{0,...}&nbsp;if&nbsp;x(b)&nbsp;!=&nbsp;A&nbsp;else&nbsp;0,&nbsp;for&nbsp;each&nbsp;b&nbsp;in&nbsp;{0,...,B-1}&lt;br&gt;&lt;/div&gt;&lt;div&gt; &nbsp;*&nbsp;with&nbsp;R(a,b)=floor(A*B*cos(2*PI*a*b/A*B))&nbsp;is&nbsp;the&nbsp;revenue&nbsp;of&nbsp;the&nbsp;allocation&nbsp;pair&nbsp;(a,b)&lt;/div&gt;&lt;div&gt; &nbsp;*&nbsp;max&nbsp;sum_{b&nbsp;in&nbsp;{0,...,B-1}}&nbsp;y(b)&lt;br&gt; &nbsp;*&nbsp;for&nbsp;each&nbsp;b&nbsp;in&nbsp;{0,...,B-1}:&nbsp;y(b)&nbsp;=&nbsp;floor(A*B*cos(2*PI*x(b)*b/A*B))&nbsp;if&nbsp;x(b)&nbsp;!=&nbsp;A&nbsp;else&nbsp;0&lt;br&gt; &nbsp;*&nbsp;alldistinct(x)&lt;br&gt;&lt;/div&gt; &nbsp;*&nbsp;branching&nbsp;with:&nbsp;branch(*this,&nbsp;x,&nbsp;INT_VAR_SIZE_MIN(),&nbsp;INT_VAL_MIN());&lt;br&gt;&lt;br&gt;&lt;/div&gt;In&nbsp;my&nbsp;test&nbsp;I&nbsp;use&nbsp;A=200&nbsp;and&nbsp;B=100.&lt;br&gt;&lt;/div&gt;The&nbsp;ILP&nbsp;CBC&nbsp;solver&nbsp;can&nbsp;even&nbsp;solve&nbsp;the&nbsp;problem&nbsp;with&nbsp;A=2000&nbsp;and&nbsp;B=1000&nbsp;like&nbsp;a&nbsp;charm.&lt;br&gt;&lt;/div&gt;&lt;div&gt;Note&nbsp;that&nbsp;the&nbsp;number&nbsp;of&nbsp;variables&nbsp;in&nbsp;the&nbsp;ILP&nbsp;model&nbsp;is&nbsp;much&nbsp;larger&nbsp;than&nbsp;in&nbsp;the&nbsp;CP&nbsp;model.&lt;br&gt;&lt;/div&gt;I&nbsp;tried&nbsp;also&nbsp;to&nbsp;use&nbsp;Gecode&nbsp;with&nbsp;the&nbsp;ILP&nbsp;model&nbsp;but&nbsp;the&nbsp;performances&nbsp;are&nbsp;poor&nbsp;too.&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Why&nbsp;can&#39;t&nbsp;Gecode&nbsp;solve&nbsp;this&nbsp;simple&nbsp;problem?&nbsp;Did&nbsp;I&nbsp;make&nbsp;something&nbsp;wrong?&lt;br&gt;&lt;/div&gt;&lt;div&gt;Are&nbsp;MILP&nbsp;solvers&nbsp;much&nbsp;better&nbsp;than&nbsp;CP&nbsp;ones&nbsp;for&nbsp;such&nbsp;optimization&nbsp;problems?&nbsp;&lt;br&gt;&lt;/div&gt;&lt;div&gt;The&nbsp;entire&nbsp;code&nbsp;is&nbsp;given&nbsp;below.&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Many&nbsp;thanks&nbsp;in&nbsp;advance!&lt;br&gt;&lt;/div&gt;&lt;div&gt;Florent&lt;br&gt;&lt;br&gt;#include&nbsp;&lt;gecode/driver.hh&gt;&lt;br&gt;#include&nbsp;&lt;gecode/int.hh&gt;&lt;br&gt;#include&nbsp;&lt;gecode/minimodel.hh&gt;&lt;br&gt;&lt;br&gt;using&nbsp;namespace&nbsp;Gecode;&lt;br&gt;&lt;br&gt;class&nbsp;Allocation&nbsp;:&nbsp;public&nbsp;MaximizeScript&nbsp;{&lt;br&gt;protected:&lt;br&gt;   &nbsp;static&nbsp;const&nbsp;int&nbsp;A&nbsp;=&nbsp;200;&nbsp;&lt;br&gt;   &nbsp;static&nbsp;const&nbsp;int&nbsp;B&nbsp;=&nbsp;100;&lt;br&gt;   &nbsp;IntVarArray&nbsp;x;&lt;br&gt;   &nbsp;IntVarArray&nbsp;y;&lt;br&gt;   &nbsp;IntVar&nbsp;total_reward;&lt;br&gt;&lt;br&gt;public:&lt;br&gt;   &nbsp;Allocation(const&nbsp;SizeOptions&amp;&nbsp;opt)&lt;br&gt;   &nbsp;:&nbsp;MaximizeScript(opt),&lt;br&gt;     &nbsp;x(*this,&nbsp;B,&nbsp;0,&nbsp;A),&lt;br&gt;     &nbsp;y(*this,&nbsp;B,&nbsp;Int::Limits::min,&nbsp;Int::Limits::max),&lt;br&gt;     &nbsp;total_reward(*this,&nbsp;Int::Limits::min,&nbsp;Int::Limits::max)&nbsp;{&lt;br&gt;       &nbsp;IntArgs&nbsp;rewards((A+1)*B);&lt;br&gt;       &nbsp;double&nbsp;PI&nbsp;=&nbsp;std::acos(-1.0);&lt;br&gt;       &nbsp;for&nbsp;(unsigned&nbsp;int&nbsp;b&nbsp;=&nbsp;0&nbsp;;&nbsp;b&nbsp;&lt;&nbsp;B&nbsp;;&nbsp;b++)&nbsp;{&lt;br&gt;           &nbsp;for&nbsp;(unsigned&nbsp;int&nbsp;a&nbsp;=&nbsp;0&nbsp;;&nbsp;a&nbsp;&lt;&nbsp;A&nbsp;;&nbsp;a++)&nbsp;{&lt;br&gt;               &nbsp;rewards[a&nbsp;+&nbsp;b&nbsp;*&nbsp;(A+1)]&nbsp;=&nbsp;static_cast&lt;int&gt;(std::floor(A*B*std::cos(2*PI*((double)&nbsp;a*b)/((double)&nbsp;A*B))));&lt;br&gt;               &nbsp;if&nbsp;(rewards[a&nbsp;+&nbsp;b&nbsp;*&nbsp;(A+1)]&nbsp;&lt;&nbsp;0.0)&nbsp;{&lt;br&gt;                   &nbsp;rel(*this,&nbsp;x[b]&nbsp;!=&nbsp;a);&lt;br&gt;               &nbsp;}&lt;br&gt;      &nbsp; &nbsp;  &nbsp;}&lt;br&gt;           &nbsp;rewards[A*(b+1)&nbsp;+&nbsp;b]&nbsp;=&nbsp;0.0;&lt;br&gt;       &nbsp;}&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;       &nbsp;IntSharedArray&nbsp;sc(rewards);&lt;br&gt;       &nbsp;for&nbsp;(unsigned&nbsp;int&nbsp;b&nbsp;=&nbsp;0&nbsp;;&nbsp;b&nbsp;&lt;&nbsp;B&nbsp;;&nbsp;b++)&nbsp;{&lt;br&gt;           &nbsp;rel(*this,&nbsp;y[b]&nbsp;==&nbsp;element(sc,&nbsp;x[b]&nbsp;+&nbsp;b&nbsp;*&nbsp;(A+1)));&lt;br&gt;       &nbsp;}&lt;br&gt;&lt;br&gt;       &nbsp;distinct(*this,&nbsp;x);&lt;br&gt;&lt;br&gt;       &nbsp;rel(*this,&nbsp;total_reward&nbsp;==&nbsp;sum(y));&lt;br&gt;&lt;br&gt;       &nbsp;branch(*this,&nbsp;x,&nbsp;INT_VAR_SIZE_MIN(),&nbsp;INT_VAL_MIN());&lt;br&gt;//     &nbsp;branch(*this,&nbsp;x,&nbsp;INT_VAR_DEGREE_MIN(),&nbsp;INT_VAL_MIN());&lt;br&gt;&lt;/div&gt;&lt;div&gt;   &nbsp;}&lt;br&gt;&lt;br&gt;   &nbsp;virtual&nbsp;void<br>
&nbsp;&nbsp;print(std::ostream&amp;&nbsp;os)&nbsp;const&nbsp;{&lt;br&gt;       &nbsp;os&nbsp;&lt;&lt;&nbsp;&quot;total_reward:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;total_reward&nbsp;&lt;&lt;&nbsp;std::endl;&lt;br&gt;       &nbsp;for(int&nbsp;b&nbsp;=&nbsp;0;&nbsp;b&nbsp;&lt;&nbsp;B;&nbsp;b++)&nbsp;{&lt;br&gt;           &nbsp;os&nbsp;&lt;&lt;&nbsp;x[b]&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;&quot;;&lt;br&gt;       &nbsp;}&lt;br&gt;       &nbsp;os&nbsp;&lt;&lt;&nbsp;std::endl;&lt;br&gt;   &nbsp;}&lt;br&gt;&lt;br&gt;   &nbsp;virtual&nbsp;IntVar&nbsp;cost(void)&nbsp;const&nbsp;{&lt;br&gt;       &nbsp;return&nbsp;total_reward;&lt;br&gt;   &nbsp;}&lt;br&gt;&lt;br&gt;   &nbsp;Allocation(bool&nbsp;share,&nbsp;Allocation&amp;&nbsp;s)&lt;br&gt;   &nbsp;:&nbsp;MaximizeScript(share,s)&nbsp;{&lt;br&gt;       &nbsp;x.update(*this,&nbsp;share,&nbsp;s.x);&lt;br&gt;       &nbsp;y.update(*this,&nbsp;share,&nbsp;s.y);&lt;br&gt;       &nbsp;total_reward.update(*this,&nbsp;share,&nbsp;s.total_reward);&lt;br&gt;   &nbsp;}&lt;br&gt;&lt;br&gt;   &nbsp;virtual&nbsp;Space*<br>
&nbsp;&nbsp;copy(bool&nbsp;share)&nbsp;{&lt;br&gt;       &nbsp;return&nbsp;new&nbsp;Allocation(share,*this);&lt;br&gt;   &nbsp;}&lt;br&gt;&lt;br&gt;};&lt;br&gt;&lt;br&gt;int<br>
main(int&nbsp;argc,&nbsp;char*&nbsp;argv[])&nbsp;{&lt;br&gt;   &nbsp;SizeOptions&nbsp;opt(&quot;Allocation&quot;);&lt;br&gt;   &nbsp;opt.solutions(0);&lt;br&gt;   &nbsp;opt.iterations(20000);&lt;br&gt;   &nbsp;opt.parse(argc,argv);&lt;br&gt;   &nbsp;MaximizeScript::run&lt;Allocation,BAB,SizeOptions&gt;(opt);&lt;br&gt;&lt;/div&gt;&lt;div&gt;   &nbsp;return&nbsp;0;&lt;br&gt;}&lt;br&gt;&lt;/div&gt;&lt;/div&gt;<br>

</tt>
